#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/stew.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW';
  package App::stew;use 5.008001;use strict;use warnings;our$VERSION="0.01";1;
APP_STEW

$fatpacked{"App/stew/builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_BUILDER';
  package App::stew::builder;use strict;use warnings;use Cwd qw(abs_path getcwd);use Carp qw(croak);use File::Path qw(rmtree);use File::Basename qw(basename dirname);use App::stew::util qw(cmd info debug error _chdir _mkpath _copy _rmtree _tree);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{root_dir}=$params{root_dir};$self->{build_dir}=$params{build_dir};$self->{repo}=$params{repo};$self->{snapshot}=$params{snapshot};return$self}sub build {my$self=shift;my ($stew_tree)=@_;my$stew=$stew_tree->{stew};croak '$ENV{PREFIX} not defined' unless$ENV{PREFIX};_mkpath($ENV{PREFIX});debug sprintf "Building '%s'...",$stew->package;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);my$cwd=getcwd();my$tree=[];eval {_rmtree$work_dir;_mkpath($work_dir);_chdir($work_dir);debug sprintf "Checking dependencies...";$self->_check_dependencies($stew,$stew_tree);my$dist_path=$self->{repo}->mirror_dist_dest($stew->name,$stew->version);my$dist_archive=basename$dist_path;my ($dist_name)=$dist_archive =~ m/^(.*)\.tar\.gz$/;_chdir($work_dir);$tree=$self->_build_from_source($stew,$dist_name);if (!$stew->is('cross-platform')){_chdir($work_dir);cmd("tar czhf $dist_archive -C $dist_name/$ENV{PREFIX}/ .");debug sprintf "Saving '%s' as '$dist_path'...",$stew->package;_mkpath(dirname$dist_path);_copy$dist_archive,$dist_path}_chdir($cwd)}or do {my$e=$@;_chdir($cwd);die$e};return$tree}sub _build_from_source {my$self=shift;my ($stew,$dist_name)=@_;_mkpath($ENV{PREFIX});_mkpath$dist_name;$ENV{DESTDIR}=abs_path($dist_name);my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_mkpath$work_dir;_chdir($work_dir);my$sources;if ($stew->url){my$src_file=$self->{repo}->mirror_file($stew->url,File::Spec->catfile($self->{repo}->{mirror_path},'src'));_copy($src_file,$work_dir);$sources++}elsif ($stew->file){my$src_file=$self->{repo}->mirror_src($stew->file);_copy($src_file,$work_dir);$sources++}if (my@files=$stew->files){for my$file (@files){my$src_file=$self->{repo}->mirror_src($file);_copy($src_file,$work_dir);$sources++}}die "No sources provided\n" unless$sources;debug sprintf "Preparing '%s'...",$stew->package;$self->_run_stew_phase($stew,'prepare');debug sprintf "Building '%s'...",$stew->package;$self->_run_stew_phase($stew,'build');debug sprintf "Installing '%s'...",$stew->package;$self->_run_stew_phase($stew,'install');debug sprintf "Cleaning '%s'...",$stew->package;$self->_run_stew_phase($stew,'cleanup');_mkpath "$ENV{DESTDIR}/$ENV{PREFIX}";_chdir "$ENV{DESTDIR}/$ENV{PREFIX}";my$files=_tree('.','.');die "Build has not produced any files\n" unless @$files;return$files}sub _run_stew_phase {my$self=shift;my ($stew,$phase)=@_;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_mkpath$work_dir;_chdir($work_dir);$stew->run($phase)}sub _check_dependencies {my$self=shift;my ($stew,$tree)=@_;my$build_dir=$self->{build_dir};my$work_dir=File::Spec->catfile($build_dir,$stew->package);my@depends=@{$tree->{dependencies}|| []};for my$tree (@depends){my$stew=$tree->{stew};die$stew->package ." is not up to date\n" unless$self->{snapshot}->is_up_to_date($stew->name,$stew->version)}}1;
APP_STEW_BUILDER

$fatpacked{"App/stew/cmd/autoremove.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_AUTOREMOVE';
  package App::stew::cmd::autoremove;use strict;use warnings;use base 'App::stew::cmd::base';use Getopt::Long qw(GetOptionsFromArray);use App::stew::snapshot;use App::stew::uninstaller;use App::stew::util qw(info);sub run {my$self=shift;my (@argv)=@_;my$opt_prefix='local';my$opt_base;my$opt_dry_run;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"dry-run"=>\$opt_dry_run,)or die "error";error("--base is required")unless$opt_base;my$snapshot=App::stew::snapshot->new(base=>$opt_base,prefix=>$opt_prefix);$snapshot->load;my$uninstaller=App::stew::uninstaller->new(base=>$opt_base,prefix=>$opt_prefix);my@not_required=$snapshot->list_not_required;if ($opt_dry_run){info sprintf "Will remove '%s'",join(', ',@not_required)}else {$uninstaller->uninstall(@not_required)}info "Done"}1;
APP_STEW_CMD_AUTOREMOVE

$fatpacked{"App/stew/cmd/base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_BASE';
  package App::stew::cmd::base;use strict;use warnings;sub new {my$class=shift;my$self={};bless$self,$class;return$self}1;
APP_STEW_CMD_BASE

$fatpacked{"App/stew/cmd/build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_BUILD';
  package App::stew::cmd::build;use strict;use warnings;use base 'App::stew::cmd::base';use Getopt::Long qw(GetOptionsFromArray);use Cwd qw(cwd abs_path);use File::Path qw(mkpath);use File::Spec;use App::stew::repo;use App::stew::builder;use App::stew::index;use App::stew::tree;use App::stew::env;use App::stew::util qw(info debug error);sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';my$opt_repo;my$opt_os;my$opt_arch;my$opt_build_dir='build';my$opt_verbose;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"repo=s"=>\$opt_repo,"os=s"=>\$opt_os,"arch=s"=>\$opt_arch,"build-dir=s"=>\$opt_build_dir,"verbose"=>\$opt_verbose,)or die "error";$opt_os ||= App::stew::env->detect_os;$opt_arch ||= App::stew::env->detect_arch;error("--base is required")unless$opt_base;error("--repo is required")unless$opt_repo;mkpath($opt_base);$opt_base=abs_path($opt_base);my$root_dir=abs_path(cwd());my$build_dir=abs_path($opt_build_dir);mkpath($build_dir);$ENV{STEW_LOG_LEVEL}=$opt_verbose ? 1 : 0;$ENV{STEW_LOG_FILE}="$build_dir/stew.log";unlink$ENV{STEW_LOG_FILE};my$repo=App::stew::repo->new(path=>$opt_repo,mirror_path=>"$build_dir/.cache",os=>$opt_os,arch=>$opt_arch);my$index=App::stew::index->new(repo=>$repo);my$snapshot=App::stew::snapshot->new(base=>$opt_base,prefix=>$opt_prefix);$snapshot->load;my@trees;for my$package (@argv){my$tree=App::stew::tree->new(repo=>$repo,index=>$index);my$dump=$tree->build($package);push@trees,$dump}$ENV{STEW_OS}=$opt_os;$ENV{STEW_ARCH}=$opt_arch;$ENV{PREFIX}=File::Spec->catfile($opt_base,$opt_prefix);App::stew::env->new(prefix=>$ENV{PREFIX})->setup;my$builder=App::stew::builder->new(root_dir=>$root_dir,build_dir=>$build_dir,repo=>$repo,snapshot=>$snapshot,);for my$tree (@trees){$builder->build($tree)}info "Done"}1;
APP_STEW_CMD_BUILD

$fatpacked{"App/stew/cmd/exec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_EXEC';
  package App::stew::cmd::exec;use strict;use warnings;use base 'App::stew::cmd::base';use Getopt::Long qw(GetOptionsFromArray);use Cwd qw(abs_path);use File::Spec;use App::stew::env;use App::stew::util qw(info debug error);sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,)or die "error";error("--base is required")unless$opt_base;$opt_base=abs_path($opt_base);my$prefix=File::Spec->catfile($opt_base,$opt_prefix);App::stew::env->new(prefix=>$prefix)->setup;exec(@argv)}1;
APP_STEW_CMD_EXEC

$fatpacked{"App/stew/cmd/help.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_HELP';
  package App::stew::cmd::help;use strict;use warnings;use base 'App::stew::cmd::base';use Pod::Find qw(pod_where);use Pod::Usage qw(pod2usage);use App::stew::cmdbuilder;sub run {my$self=shift;my ($command)=@_;my$command_instance=App::stew::cmdbuilder->new->build($command);pod2usage(-input=>pod_where({-inc=>1},ref($command_instance)),-verbose=>2)}1;
APP_STEW_CMD_HELP

$fatpacked{"App/stew/cmd/install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_INSTALL';
  package App::stew::cmd::install;use strict;use warnings;use base 'App::stew::cmd::base';use Getopt::Long qw(GetOptionsFromArray);use Cwd qw(cwd abs_path);use File::Path qw(mkpath);use File::Spec;use App::stew::repo;use App::stew::installer;use App::stew::snapshot;use App::stew::index;use App::stew::tree;use App::stew::env;use App::stew::util qw(info debug error slurp_file);sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';my$opt_repo=$ENV{STEW_REPO};my$opt_force_platform;my$opt_os;my$opt_arch;my$opt_build='build';my$opt_dry_run;my$opt_verbose;my$opt_from_source;my$opt_from_source_recursive;my$opt_reinstall;my$opt_keep_files;my$opt_cache;my$opt_stewfile;my$opt_help;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"repo=s"=>\$opt_repo,"force-platform"=>\$opt_force_platform,"os=s"=>\$opt_os,"arch=s"=>\$opt_arch,"build=s"=>\$opt_build,"dry-run"=>\$opt_dry_run,"verbose"=>\$opt_verbose,"from-source"=>\$opt_from_source,"from-source-recursive"=>\$opt_from_source_recursive,"reinstall"=>\$opt_reinstall,"keep-files"=>\$opt_keep_files,"cache"=>\$opt_cache,"stewfile=s"=>\$opt_stewfile,"help"=>\$opt_help,)or die "error";if ($opt_help){App::stew::cmd::help->new->run('install');return}error("--base is required")unless$opt_base;error("--repo is required")unless$opt_repo;mkpath($opt_base);$opt_base=abs_path($opt_base);mkpath($opt_build);my$root_dir=abs_path(cwd());my$build_dir=abs_path($opt_build);$ENV{STEW_LOG_LEVEL}=$opt_verbose ? 1 : 0;$ENV{STEW_LOG_FILE}="$build_dir/stew.log";unlink$ENV{STEW_LOG_FILE};my$snapshot=App::stew::snapshot->new(base=>$opt_base,prefix=>$opt_prefix);$snapshot->load;my$local_settings=$snapshot->local_settings;my$os_forced=!!$opt_os;$opt_os ||= $local_settings->{os}|| App::stew::env->detect_os;$opt_arch ||= $local_settings->{arch}|| App::stew::env->detect_arch;my$repo=App::stew::repo->new(path=>$opt_repo,mirror_path=>"$build_dir/.cache",os=>$opt_os,arch=>$opt_arch,cache=>$opt_cache,);my$index=App::stew::index->new(repo=>$repo);my$platform="$opt_os-$opt_arch";warn "Installing for '$platform'\n";if (!$os_forced &&!$opt_force_platform &&!$opt_from_source &&!$local_settings->{os}&&!$local_settings->{arch}){if (!$index->platform_available($opt_os,$opt_arch)){my$platforms=$index->list_platforms;warn "Platform '$platform' is not available. " ."Maybe you want --from-source or --force-platform?\n";if (@$platforms){warn "Available platforms are: \n\n";warn join("\n",map {"    --os $_->{os} --arch $_->{arch}"}@$platforms)."\n\n"}else {warn "No platforms available\n\n"}error 'Fail to detect platform'}}if ($opt_stewfile || (@argv==1 && $argv[0]eq '.')){my$stewfile=abs_path($opt_stewfile // 'stewfile');die "stewfile '$stewfile' not found\n" unless -f $stewfile;@argv=grep {$_ &&!/^#/}split /(?:\r?\n)+/,slurp_file($stewfile)}if (!@argv){info 'Nothing to install';return}$ENV{STEW_OS}=$opt_os;$ENV{STEW_ARCH}=$opt_arch;$ENV{PREFIX}=File::Spec->catfile($opt_base,$opt_prefix);my@trees;for my$package (@argv){my$resolved=$index->resolve($package);error sprintf "Unknown package '%s'",$package unless$resolved;if (!$opt_reinstall && $snapshot->is_up_to_date($resolved)){info sprintf "'%s' is up to date",$resolved;next}my$tree=App::stew::tree->new(repo=>$repo,index=>$index);my$dump=$tree->build($package);push@trees,$dump}App::stew::env->new(prefix=>$ENV{PREFIX})->setup;my$installer=App::stew::installer->new(base=>$opt_base,root_dir=>$root_dir,build_dir=>$build_dir,repo=>$repo,snapshot=>$snapshot,from_source=>$opt_from_source,from_source_recursive=>$opt_from_source_recursive,reinstall=>$opt_reinstall,keep_files=>$opt_keep_files,);for my$tree (@trees){$installer->install($tree)}$snapshot->local_settings->{os}=$opt_os;$snapshot->local_settings->{arch}=$opt_arch;$snapshot->store;info "Done"}1;
APP_STEW_CMD_INSTALL

$fatpacked{"App/stew/cmd/list_installed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_LIST_INSTALLED';
  package App::stew::cmd::list_installed;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use App::stew::snapshot;use App::stew::util qw(info debug error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;return$self}sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix)or die "error";error("--base is required")unless$opt_base;my$snapshot=App::stew::snapshot->new(base=>$opt_base,prefix=>$opt_prefix)->load;for my$key (sort keys %$snapshot){next if$key eq '_';next if$snapshot->{$key}->{dependency};print "$key $snapshot->{$key}->{version}\n"}}1;
APP_STEW_CMD_LIST_INSTALLED

$fatpacked{"App/stew/cmd/uninstall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_UNINSTALL';
  package App::stew::cmd::uninstall;use strict;use warnings;use base 'App::stew::cmd::base';use Getopt::Long qw(GetOptionsFromArray);use App::stew::snapshot;use App::stew::uninstaller;use App::stew::util qw(error info);sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';my$opt_force;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"force"=>\$opt_force,)or die "error";error("--base is required")unless$opt_base;my$snapshot=App::stew::snapshot->new(base=>$opt_base,prefix=>$opt_prefix);$snapshot->load;my$uninstaller=App::stew::uninstaller->new(base=>$opt_base,prefix=>$opt_prefix);if (!$opt_force){for my$package (@argv){next unless$snapshot->is_dependency($package);error "Cannot remove '$package' since it is was installed " ."as dependency and can break other packages" if$snapshot->is_required($package)}}$uninstaller->uninstall(@argv);info 'Done'}1;
APP_STEW_CMD_UNINSTALL

$fatpacked{"App/stew/cmdbuilder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMDBUILDER';
  package App::stew::cmdbuilder;use strict;use warnings;use List::Util qw(max first);use Pod::Usage qw(pod2usage);use App::stew::cmd::install;use App::stew::cmd::build;use App::stew::cmd::list_installed;use App::stew::cmd::uninstall;use App::stew::cmd::autoremove;use App::stew::cmd::exec;use App::stew::cmd::help;my@COMMANDS=('install','uninstall','build','list-installed','autoremove','exec','help',);sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub build {my$self=shift;my ($command)=@_;my$offset=max map {length}@COMMANDS;if (!$command ||!first {$_ eq $command}@COMMANDS){pod2usage()}return$self->_command_to_class($command)->new}sub _command_to_class {my$self=shift;my ($command)=@_;$command =~ s/-/_/g;return 'App::stew::cmd::' .$command}1;
APP_STEW_CMDBUILDER

$fatpacked{"App/stew/env.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_ENV';
  package App::stew::env;use strict;use warnings;use Config;use App::stew::util qw(debug error slurp_file);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{prefix}=$params{prefix}|| error 'prefix required';return$self}sub setup {my$self=shift;my$prefix=$self->{prefix};$ENV{PERL5LIB}="";$ENV{PERL_LOCAL_LIB_ROOT}="";$ENV{PERL_MB_OPT}="--installdirs site";$ENV{PERL_MM_OPT}="INSTALLDIRS=site";$ENV{PERL_CPANM_OPT}="";_unshift_env(PATH=>"$prefix/bin");_unshift_env(LIBPATH=>"$prefix/lib:$prefix/lib64");_unshift_env(LIBRARY_PATH=>"$prefix/lib:$prefix/lib64");_unshift_env(LD_LIBRARY_PATH=>"$prefix/lib:$prefix/lib64");_unshift_env(CPATH=>"$prefix/include");_unshift_env(C_INCLUDE_PATH=>"$prefix/include");_unshift_env(CPLUS_INCLUDE_PATH=>"$prefix/include")}sub detect_os {my$self=shift;my$os=$self->_osname;if ($os eq 'linux'){require Linux::Distribution;my$dist_name=Linux::Distribution::distribution_name()|| 'generic';my$dist_version=eval {Linux::Distribution::distribution_version()};if ($dist_version && $dist_version =~ m/^(\d+(?:\.\d+)?)/){$dist_version=$1}else {$dist_version=undef}$os .= "-$dist_name";$os .= "-$dist_version" if$dist_version}elsif ($os eq 'darwin'){my$cmd='sw_vers';my$output=$self->_run_cmd($cmd);my ($dist_version)=$output =~ m/ProductVersion:\s+(\d+\.\d+)/;$os .= "-osx";$os .= "-$dist_version" if$dist_version}elsif ($os eq 'cygwin'){my$cmd='uname -r';my$output=$self->_run_cmd($cmd);my ($dist_version)=$output =~ m/^(\d+\.\d+)/;$os="windows-$os";$os .= "-$dist_version" if$dist_version}return$os}sub detect_arch {my$self=shift;my$arch;chomp($arch ||= `uname -m`);$arch=lc$arch;return$arch}sub _osname {$^O}sub _run_cmd {my$self=shift;my ($cmd)=@_;return `$cmd`}sub _unshift_env {my ($var,$value)=@_;if ($ENV{$var}){$ENV{$var}="$value:$ENV{$var}"}else {$ENV{$var}=$value}debug "Setting ENV{$var}=$ENV{$var}"}1;
APP_STEW_ENV

$fatpacked{"App/stew/file/perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_FILE_PERL';
  package App::stew::file::perl;use strict;use warnings;use YAML::Tiny ();use App::stew::util qw(slurp_file error listify);sub new {my$class=shift;my (%params)=@_;my$file=$params{file};my$content=$params{content};my$stew_class=$class->_sandbox($file,$content);return$stew_class->new}sub _sandbox {my$self=shift;my ($file,$content)=@_;my$class_name='stew::_build_' ._rand_str();my$package=<<"EOP";eval$package or error("Error compiling '$file': $@");return$class_name}sub _rand_str {my@alpha=('0' .. '9','a' .. 'z','A' .. 'Z');my$str='';$str .= $alpha[rand($#alpha)]for 1 .. 16;return$str}1;
      package $class_name;
      use strict;
      use warnings;
      use App::stew::util qw(cmd);
      my \$name;
      my \$version;
      my \$package;
      my \$file;
      my \@files;
      my \$url;
      my \@depends;
      my \@flags;
      my \@os;
  
      sub new {
          my \$class = shift;
  
          my \$self = {};
          bless \$self, \$class;
  
          return \$self;
      }
  
      sub name    { \$name }
      sub version { \$version }
      sub package { \$package }
      sub file    { \$file }
      sub files   { \@files }
      sub url     { \$url }
      sub depends { \@depends }
      sub flags   { \@flags }
      sub os      { \@os }
  
      my \$phases = {};
      sub prepare(&)  { \$phases->{prepare}  = shift }
      sub build(&)    { \$phases->{build}    = shift }
      sub install(&)  { \$phases->{install}  = shift }
      sub cleanup(&)  { \$phases->{cleanup}  = shift }
  
      sub phase { \$phases->{\$_[1]} }
  
      sub is {
          my \$self = shift;
          my (\$flag) = \@_;
  
          return !!grep { \$_ eq \$flag } \$self->flags;
      }
  
      sub run {
          my \$self = shift;
          my (\$phase) = \@_;
  
          if (\$phases->{\$phase}) {
              my \@commands = \$phases->{\$phase}->();
  
              cmd(\@commands);
          }
  
          return;
      }
      $content
      1;
  EOP
APP_STEW_FILE_PERL

$fatpacked{"App/stew/file/yml.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_FILE_YML';
  package App::stew::file::yml;use strict;use warnings;use YAML::Tiny ();use Cwd qw(getcwd);use App::stew::util qw(slurp_file error listify cmd _chdir);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;my$file=$params{file};my$content=$params{content};$self->_parse_yaml($content);return$self}sub name {my$self=shift;return$self->{yaml}->{name}}sub version {my$self=shift;return$self->{yaml}->{version}}sub package {my$self=shift;return$self->{yaml}->{package}}sub url {my$self=shift;return$self->{yaml}->{url}}sub file {my$self=shift;return$self->{yaml}->{file}}sub files {my$self=shift;my@sources=listify$self->{yaml}->{files};push@sources,listify$self->{yaml}->{sources};return grep {defined}@sources}sub os {my$self=shift;return grep {defined}listify$self->{yaml}->{os}}sub flags {my$self=shift;return grep {defined}listify$self->{yaml}->{flags}}sub is {my$self=shift;my ($flag)=\@_;return!!grep {$_ eq $flag}$self->flags}sub depends {my$self=shift;return listify$self->{yaml}->{depends}}sub run {my$self=shift;my ($phase)=@_;my$steps=$self->{yaml}->{$phase};my$cwd=getcwd();for my$step (@$steps){if (my$cmd=$step->{cmd}){$cmd=$self->_parse_dynamic_var($cmd);cmd($cmd)}elsif (my$chdir=$step->{chdir}){$chdir=$self->_parse_dynamic_var($chdir);_chdir($chdir)}elsif (my$env=$step->{env}){for my$key (keys %$env){$ENV{$key}=$env->{$key}}}}_chdir($cwd)}sub _parse_yaml {my$self=shift;my ($content)=@_;my$yaml=YAML::Tiny->read_string($content);$yaml=$yaml->[0];$yaml->{PREFIX}=$ENV{PREFIX};$yaml->{OS}=$ENV{STEW_OS};$yaml->{ARCH}=$ENV{STEW_ARCH};$yaml=_walk($yaml,sub {return unless defined $_[0];$_[0]=~ s/\{\{([_a-zA-Z0-9]+)\}\}/defined $yaml->{$1} ? $yaml->{$1} : ''/ge;return $_[0]});$self->{yaml}=$yaml}sub _parse_dynamic_var {my$self=shift;my ($template)=@_;$template =~ s/\$\{([_a-zA-Z0-9]+)\}/$ENV{$1}/ge;return$template}sub _walk {my ($tree,$cb)=@_;unless (ref$tree){$tree=$cb->($tree);return$tree}if (ref$tree eq 'HASH'){for my$key (keys %$tree){$tree->{$key}=_walk($tree->{$key},$cb)}return$tree}elsif (ref$tree eq 'ARRAY'){for my$value (@$tree){$value=_walk($value,$cb)}return$tree}else {die 'Unexpected ref=' .ref($tree)}}1;
APP_STEW_FILE_YML

$fatpacked{"App/stew/fileparser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_FILEPARSER';
  package App::stew::fileparser;use strict;use warnings;use App::stew::file::perl;use App::stew::file::yml;use App::stew::util qw(slurp_file);my%CACHE;sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub parse {my$class=shift;my ($stew_file)=@_;return$CACHE{"$stew_file"}if$CACHE{"$stew_file"};my$content=slurp_file($stew_file);my$stew;if ($content =~ m/^---/){$stew=App::stew::file::yml->new(file=>$stew_file,content=>$content)}else {$stew=App::stew::file::perl->new(file=>$stew_file,content=>$content)}$CACHE{"$stew_file"}=$stew;return$stew}1;
APP_STEW_FILEPARSER

$fatpacked{"App/stew/index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_INDEX';
  package App::stew::index;use strict;use warnings;use Carp qw(croak);use List::Util qw(first);use App::stew::util qw(error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{repo}=$params{repo}or croak 'repo required';return$self}sub resolve {my$self=shift;my ($need)=@_;my$name=$need;my$op;my$version;if ($need =~ m/^(.*?)(==|>=?|<=?)(.*)$/){$name=$1;$op=$2;$version=$3}$self->{index}||= $self->_read_index;my@packages;for my$package (@{$self->{index}}){push@packages,$package if$package->{name}eq $name}if (!$op){my$package=$packages[-1];return unless$package;return$package->{full}}elsif ($op eq '=='){my$package=first {$_->{version}eq $version}@packages;return unless$package;return$package->{full}}elsif ($op eq '>='){my@newer=grep {$_->{version}ge $version}@packages;return unless@newer;return$newer[-1]->{full}}elsif ($op eq '>'){my@packages=grep {$_->{version}gt $version}@packages;return unless@packages;return$packages[-1]->{full}}return}sub list_platforms {my$self=shift;my@platforms;my$index_file=$self->{repo}->mirror_index;my@index;open my$fh,'<',$index_file or error "Can't read index file '$index_file': $!";for my$line (<$fh>){chomp$line;next unless$line =~ m/^dist\/(.*?)\/(.*?)$/;push@platforms,{os=>$1,arch=>$2}}close$fh;return \@platforms}sub platform_available {my$self=shift;my ($os,$arch)=@_;my$platforms=$self->list_platforms;for my$platform (@$platforms){if ($platform->{os}=~ m/^\Q$os\E/ && $arch eq $platform->{arch}){return 1}}return 0}sub _read_index {my$self=shift;my$index_file=$self->{repo}->mirror_index;my@index;open my$fh,'<',$index_file or error "Can't read index file '$index_file': $!";for my$line (<$fh>){chomp$line;next unless$line =~ m/^stew\/(.*?)_(.*?)\.stew$/;push@index,{name=>$1,version=>$2,full=>"$1_$2" }}close$fh;return \@index}1;
APP_STEW_INDEX

$fatpacked{"App/stew/installer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_INSTALLER';
  package App::stew::installer;use strict;use warnings;use Cwd qw(abs_path getcwd);use Carp qw(croak);use File::Path qw(rmtree);use File::Basename qw(basename dirname);use App::stew::builder;use App::stew::util qw(cmd info debug error _chdir _mkpath _rmtree _copy _unlink _tree _tree_diff);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{base}=$params{base};$self->{root_dir}=$params{root_dir};$self->{build_dir}=$params{build_dir};$self->{repo}=$params{repo};$self->{snapshot}=$params{snapshot};$self->{from_source}=$params{from_source};$self->{from_source_recursive}=$params{from_source_recursive};$self->{reinstall}=$params{reinstall};$self->{keep_files}=$params{keep_files};$self->{cache}=$params{cache};return$self}sub install {my$self=shift;my ($stew_tree,%options)=@_;my$is_dependency=!!$options{satisfies};my$stew=$stew_tree->{stew};my$reinstall=!$is_dependency && $self->{reinstall};my$from_source=$self->{from_source_recursive}|| (!$is_dependency && $self->{from_source});if (!$reinstall && $self->{snapshot}->is_up_to_date($stew->name,$stew->version)){debug sprintf "'%s' is up to date",$stew->package;return}elsif ($self->{snapshot}->is_installed($stew->name)){my$uninstaller=App::stew::uninstaller->new(base=>$self->{base});$uninstaller->uninstall($stew->name)}croak '$ENV{PREFIX} not defined' unless$ENV{PREFIX};_mkpath($ENV{PREFIX});debug sprintf "Building & installing '%s'...",$stew->package;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_rmtree$work_dir;_mkpath($work_dir);my$cwd=getcwd();my$tree=[];my@depends;eval {if (my@os=$stew->os){my$match=0;for my$os (@os){if ($ENV{STEW_OS}=~ m/$os/){$match=1;last}}if (!$match){info sprintf "Not supported OS '%s'. Supported are '%s'. Skipping...",$ENV{STEW_OS},join(', ',@os);return$self}}debug "Resolving dependencies...";@depends=$self->_install_dependencies($stew,$stew_tree);if ($self->{snapshot}->is_up_to_date($stew->name,$stew->version)){debug sprintf "'%s' is up to date",$stew->package;return$self}if ($stew->is('cross-platform')){debug 'Cross platform package';my$builder=$self->_build_builder;$tree=$builder->build($stew_tree);my$dist_path=$self->{repo}->mirror_dist_dest($stew->name,$stew->version);my$dist_archive=basename$dist_path;my ($dist_name)=$dist_archive =~ m/^(.*)\.tar\.gz$/;_chdir$work_dir;_chdir "$dist_name/$ENV{PREFIX}";cmd("cp -Ra * $ENV{PREFIX}/")}elsif ($stew->is('meta')){debug 'Meta package'}else {my$dist_path=$self->{repo}->mirror_dist_dest($stew->name,$stew->version);eval {$self->{repo}->mirror_dist($stew->name,$stew->version)};if ($from_source ||!-f $dist_path){my$builder=$self->_build_builder;$tree=$builder->build($stew_tree)}$tree=$self->_install_from_binary($stew,$dist_path)}_chdir($cwd)}or do {my$e=$@;_chdir($cwd);die$e};info sprintf "Done installing '%s'",$stew->package;$self->{snapshot}->mark_installed(name=>$stew->name,version=>$stew->version,files=>$tree,depends=>[map {{name=>$_->{stew}->name,version=>$_->{stew}->version}}@depends ],$is_dependency ? (dependency=>1): ());_rmtree$work_dir unless$self->{keep_files};return$self}sub _install_from_binary {my$self=shift;my ($stew,$dist_path)=@_;debug sprintf "Installing '%s' from binaries '%s'...",$stew->package,$dist_path;my$basename=basename$dist_path;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_mkpath$work_dir;_chdir$work_dir;my ($dist_name)=$basename =~ m/^(.*)\.tar\.gz$/;_rmtree$dist_name;_mkpath$dist_name;_copy($dist_path,"$dist_name/$basename");_chdir$dist_name;cmd("tar xzf $basename");_unlink$basename;cmd("cp -Ra * $ENV{PREFIX}/");return _tree(".",".")}sub _install_dependencies {my$self=shift;my ($stew,$tree)=@_;my@depends=@{$tree->{dependencies}|| []};if (@depends){debug "Found dependencies: " .join(', ',map {$_->{stew}->package}@depends)}for my$tree (@depends){my$stew=$tree->{stew};_chdir($self->{root_dir});$self->install($tree,satisfies=>$stew);_chdir($self->{root_dir})}return@depends}sub _build_builder {my$self=shift;return App::stew::builder->new(root_dir=>$self->{root_dir},build_dir=>$self->{build_dir},repo=>$self->{repo},snapshot=>$self->{snapshot},)}1;
APP_STEW_INSTALLER

$fatpacked{"App/stew/rc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_RC';
  package App::stew::rc;use strict;use warnings;use File::Spec;sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub load {my$self=shift;my$file='.stewrc';my@paths='.';push@paths,$ENV{HOME}if defined$ENV{HOME};for (@paths){my$path=File::Spec->catfile($_,$file);return$self->parse($path)if -f $path}return {}}sub parse {my$self=shift;my ($file)=@_;my@lines=do {open my$fh,'<',$file or die "Can't open '$file': $!";<$fh>};my$section='_';my%options;for my$line (@lines){next unless defined$line && $line !~ m/^\s*#/;chomp$line;$line =~ s{^\s+}{};$line =~ s{\s+$}{};next unless length$line;if ($line =~ m/^\[(.*?)\]$/){$section=$1;next}my ($key,$value)=split /\s+/,$line,2;$options{$section}->{$key}=$value}return \%options}1;
APP_STEW_RC

$fatpacked{"App/stew/repo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_REPO';
  package App::stew::repo;use strict;use warnings;use HTTP::Tiny;use File::Basename qw(dirname basename);use File::Path ();use Carp qw(croak);use Cwd qw(abs_path);use App::stew::util qw(error debug _copy _mkpath sort_by_version);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{path}=$params{path}or croak 'path required';$self->{path}=abs_path($self->{path})unless$self->{path}=~ m/^http/;$self->{path}.= '/' unless$self->{path}=~ m{/$};$self->{mirror_path}=$params{mirror_path}or croak 'mirror_path required';$self->{mirror_path}.= '/' unless$self->{mirror_path}=~ m{/$};$self->{os}=$params{os}or croak 'os required';$self->{arch}=$params{arch}or croak 'arch required';$self->{ua}=$params{ua};$self->{cache}=$params{cache};return$self}sub mirror_stew {my$self=shift;my ($name)=@_;die 'name required' unless$name;my$full_name=$self->{path}.File::Spec->catfile('stew',$name .'.stew');return$self->mirror_file($full_name,File::Spec->catfile($self->{mirror_path},'stew'))}sub mirror_src {my$self=shift;my ($filename)=@_;die 'filename required' unless$filename;my$full_name=$self->{path}.File::Spec->catfile('src',$filename);return$self->mirror_file($full_name,File::Spec->catfile($self->{mirror_path},'src'))}sub mirror_dist_dest {my$self=shift;my ($name,$version)=@_;my$os=$self->{os};my$arch=$self->{arch};return File::Spec->catfile($self->{mirror_path},'dist',$os,$arch,"${name}_${version}_$os-$arch.tar.gz")}sub mirror_dist {my$self=shift;my ($name,$version)=@_;croak 'name required' unless$name;croak 'version required ' unless$version;my$os=$self->{os};my$arch=$self->{arch};my$full_name=$self->{path}.File::Spec->catfile('dist',$os,$arch,"${name}_${version}_$os-$arch.tar.gz");return$self->mirror_file($full_name,File::Spec->catfile($self->{mirror_path},'dist',$os,$arch))}sub mirror_index {my$self=shift;my$to=File::Spec->catfile($self->{mirror_path},'index');if ($self->{cache}){debug("NOT Mirroring index");return$to}my@index;if ($self->{path}=~ m/^http/){my$ua=$self->{ua}|| HTTP::Tiny->new;for my$type (qw(stew src)){my$response=$ua->get("$self->{path}$type");if ($response->{success}){my$content=$response->{content};while ($content =~ m#<a href="(.*?\.(?:stew|tar\.gz))">.*?</a>#g){push@index,"$type/$1"}}}my$response=$ua->get("$self->{path}dist");if ($response->{success}){my$content=$response->{content};my@os;while ($content =~ m#<a href="([^\.].*?)/?">.*?</a>#g){push@os,$1}for my$os (@os){my$response=$ua->get("$self->{path}dist/$os");next unless$response->{success};my$content=$response->{content};while ($content =~ m#<a href="([^\.].*?)/?">.*?</a>#g){push@index,"dist/$os/$1"}}}}else {for my$type (qw(stew src)){opendir my$dh,"$self->{path}/$type" or error "Can't open directory '$self->{path}/$type': $!";push@index,map {"$type/$_"}grep {!/^\./ && -f "$self->{path}/$type/$_"}readdir($dh);closedir$dh}if (opendir my$dh,"$self->{path}/dist"){my@os=grep {!/^\./ && -d "$self->{path}/dist/$_"}readdir($dh);closedir$dh;for my$os (@os){opendir my$dh,"$self->{path}/dist/$os" or next;my@arch=grep {!/^\./ && -d "$self->{path}/dist/$os/$_"}readdir($dh);closedir$dh;for my$arch (@arch){push@index,"dist/$os/$arch"}}}}my@index_sorted=sort_by_version@index;_mkpath dirname$to;open my$fh,'>',$to or die "Can't create file '$to': $!";print$fh "$_\n" for@index_sorted;close$fh;return$to}sub mirror_file {my$self=shift;my ($in,$to_dir)=@_;my$to=File::Spec->catfile($to_dir,basename$in);if ($self->{cache}){debug("NOT Mirroring '$in' to '$to_dir'");return$to}_mkpath($to_dir);debug("Mirroring '$in' to '$to_dir'");if (-e $to){debug("File '$to' exists. Skipping");return$to}if ($in =~ m/^http/){my$ua=$self->{ua}|| HTTP::Tiny->new;my$response;for (1 .. 3){$response=$ua->mirror($in,$to);last if$response->{success};last unless$response->{status}eq '599';debug("Retrying because of $response->{reason}: $response->{content}...\n")}if (!$response->{success}){die "Mirroring '$in' to '$to_dir' failed\n"}}else {error "File '$in' does not exist" unless -f $in;_copy($in,$to)}return$to}1;
APP_STEW_REPO

$fatpacked{"App/stew/snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_SNAPSHOT';
  package App::stew::snapshot;use strict;use warnings;use File::Spec ();use List::Util qw(first);use YAML::Tiny ();use Carp qw(croak);use File::Basename qw(dirname);use App::stew::util qw(error slurp_file write_file _mkpath);my%CACHE_REQUIRED;sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{base}=$params{base};croak 'base is required' unless$self->{base};$self->{prefix}=$params{prefix}|| 'local';$self->{snapshot}={};$self->load;return$self}sub local_settings {my$self=shift;$self->{snapshot}->{_}||= {};return$self->{snapshot}->{_}}sub is_installed {my$self=shift;my ($package)=@_;if ($self->{snapshot}->{$package}){return 1}return 0}sub is_up_to_date {my$self=shift;my ($name,$version)=@_==1 ? split /_/,$_[0],2 : @_;return 0 unless$self->is_installed($name);return 0 unless$self->{snapshot}->{$name}->{version}eq $version;return 1}sub get_package {my$self=shift;my ($package)=@_;return$self->{snapshot}->{$package}}sub list_not_required {my$self=shift;my@not_required;for my$name (keys %{$self->{snapshot}}){push@not_required,$name unless$self->is_required($name)}return sort@not_required}sub is_dependency {my$self=shift;my ($name)=@_;my$info=$self->{snapshot}->{$name};error 'unknown package' unless$info;return!!$info->{dependency}}sub is_required {my$self=shift;my ($name)=@_;my$info=$self->{snapshot}->{$name};error 'unknown package' unless$info;return$CACHE_REQUIRED{$name}if exists$CACHE_REQUIRED{$name};return ($CACHE_REQUIRED{$name}=1)unless$info->{dependency};for my$dependant_name (keys %{$self->{snapshot}}){next if$name eq $dependant_name;my$dependant_info=$self->{snapshot}->{$dependant_name};next unless$dependant_info->{depends}&& (my@depends=@{$dependant_info->{depends}});if (my$depends=first {$name eq $_->{name}}@depends){my$is_required=$self->is_required($dependant_name);return$is_required if$is_required}}return ($CACHE_REQUIRED{$name}=0)}sub load {my$self=shift;my$install_file=$self->_install_file;$install_file=$self->_install_file_old unless -e $install_file;my$installed={};if (-e $install_file){my$content=slurp_file($install_file);if ($content =~ m/^\$VAR1 = /){no strict;$installed=eval$content}else {$installed=YAML::Tiny::Load($content)}}$self->{snapshot}=$installed;return$self->{snapshot}}sub mark_installed {my$self=shift;my (%options)=@_;my$name=delete$options{name};$self->{snapshot}->{$name}={%options};$self->store;return$self}sub mark_uninstalled {my$self=shift;my ($name)=@_;delete$self->{snapshot}->{$name};$self->store;return$self}sub store {my$self=shift;_mkpath(dirname($self->_install_file));write_file($self->_install_file,YAML::Tiny::Dump($self->{snapshot}));unlink$self->_install_file_old;return$self}sub _install_file {my$self=shift;return File::Spec->catfile($self->{base},$self->{prefix},'stew.snapshot')}sub _install_file_old {my$self=shift;return File::Spec->catfile($self->{base},'stew.snapshot')}1;
APP_STEW_SNAPSHOT

$fatpacked{"App/stew/tree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_TREE';
  package App::stew::tree;use strict;use warnings;use Carp qw(croak);use App::stew::fileparser;use App::stew::util qw(error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{repo}=$params{repo}or croak 'repo required';$self->{index}=$params{index}or croak 'index required';return$self}sub build {my$self=shift;my ($stew_expr,%params)=@_;my$stew_name=$self->{index}->resolve($stew_expr);error "Can't find package satisfying '$stew_expr'" unless$stew_name;my$stew_file=$self->_download_stew($stew_name);my$stew=$self->_parse_stew($stew_file);my$tree={stew=>$stew,dependencies=>[]};return$tree if$params{seen}->{$stew_name};$params{seen}->{$stew_name}++;my@depends=$stew->depends;for my$depends (@depends){push @{$tree->{dependencies}},$self->build($depends,%params)}return$tree}sub flatten {my$self=shift;my ($tree)=@_;my@list;for my$dep (@{$tree->{dependencies}}){push@list,$self->flatten($dep)}push@list,$tree->{stew};return@list}sub flatten_dependencies {my$self=shift;my ($tree)=@_;my@list;for my$dep (@{$tree->{dependencies}}){push@list,$self->flatten($dep)}return@list}sub _download_stew {my$self=shift;my ($stew_name)=@_;return$self->{repo}->mirror_stew($stew_name)}sub _parse_stew {my$self=shift;my ($file)=@_;return App::stew::fileparser->parse($file)}1;
APP_STEW_TREE

$fatpacked{"App/stew/uninstaller.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_UNINSTALLER';
  package App::stew::uninstaller;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use App::stew::snapshot;use App::stew::util qw(info debug error _unlink);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{base}=$params{base};$self->{prefix}=$params{prefix}|| 'local';return$self}sub uninstall {my$self=shift;my (@packages)=@_;my$snapshot=App::stew::snapshot->new(base=>$self->{base});$snapshot->load;for my$package (@packages){if (!$snapshot->is_installed($package)){warn "$package not installed. Skipping\n"}else {info sprintf "Uninstalling '%s'...",$package;my$info=$snapshot->get_package($package);for my$file (@{$info->{files}}){_unlink "$self->{base}/$self->{prefix}/$file"}$snapshot->mark_uninstalled($package)}}}1;
APP_STEW_UNINSTALLER

$fatpacked{"App/stew/util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_UTIL';
  package App::stew::util;use strict;use warnings;use base 'Exporter';our@EXPORT_OK=qw(info debug error slurp_file write_file cmd _chdir _mkpath _rmtree _copy _unlink _tree _tree_diff sort_by_version listify);use File::Find qw(find);use Carp qw(croak);use File::Copy qw(copy);use File::Basename qw(dirname);use File::Path qw(mkpath rmtree);sub slurp_file {my ($file)=@_;local $/;open my$fh,'<',$file or error("Can't read file '$file': $!");return <$fh>}sub write_file {my ($file,$content)=@_;open my$fh,'>',$file or error("Can't write file '$file': $!");print$fh $content;close$fh}sub debug {print STDERR @_,"\n" if$ENV{STEW_LOG_LEVEL};_log(@_)}sub info {_log(@_);warn join(' ',@_)."\n"}sub error {_log(@_);die("ERROR: " .join(' ',@_)."\n")}sub _chdir {my ($dir)=@_;debug(qq{Entering '$dir'});die "Directory '$dir' does not exist" unless -d $dir;chdir($dir)}sub _mkpath {my ($dir)=@_;debug(qq{Creating '$dir'});mkpath($dir)}sub _rmtree {my ($dir)=@_;debug(qq{Removing '$dir'});rmtree($dir)}sub _copy {my ($from,$to)=@_;debug(qq{Copying '$from' -> '$to'});copy($from,$to)or croak "Cant copy '$from' -> '$to'"}sub _unlink {my ($file)=@_;debug(qq{Unlinking '$file'});unlink($file)}sub cmd {return unless @_;my$cmd=join ' && ',@_;$cmd="sh -c \"$cmd 2>&1\" 2>&1 >> $ENV{STEW_LOG_FILE}";debug($cmd);my$exit=system($cmd);error("Command failed: $cmd")if$exit}sub _log {open my$fh,'>>',$ENV{STEW_LOG_FILE}or die "Can't open logfile '$ENV{STEW_LOG_FILE}': $!";print$fh @_,"\n";close$fh}sub _tree {my ($dir,$prefix)=@_;my@tree;find(sub {return unless -f $_;my$name=$File::Find::name;if ($prefix){$name =~ s{^$prefix/?}{}}push@tree,$name},$dir);return [sort@tree]}sub _tree_diff {my ($tree1,$tree2)=@_;my@diff;my$diff_pos=0;for (my$pos=0;$pos < @$tree1;$pos++){while ($diff_pos < @$tree2 && $tree1->[$pos]ne $tree2->[$diff_pos]){push@diff,$tree2->[$diff_pos];$diff_pos++}if ($diff_pos < @$tree2 && $tree1->[$pos]eq $tree2->[$diff_pos]){$diff_pos++;next}last if$diff_pos >= @$tree2}while ($diff_pos < @$tree2){push@diff,$tree2->[$diff_pos];$diff_pos++}return \@diff}sub sort_by_version {my (@list)=@_;my%packages;for my$list (@list){if ($list =~ m{^dist/}){$packages{$list}=''}else {my ($pkg,$v,$tail)=$list =~ m/^(.*?)(\d+(?:\.\d+)*(?:_\d+)?(?:[a-z]\d?)?)(\..*)/;die "Can't parse $list" unless$pkg && $v && $tail;my@parts=split /\./,$v;for my$part (@parts){if ($part =~ m/^[0-9]+$/){$part=sprintf '%03d',$part}elsif ($part =~ m/_/){my@subparts=split /_/,$part;$part=join '_',map {$_ =~ m/^[0-9]+$/ ? sprintf('%03d',$_): $_}@subparts}}my$sort_v=join '.',@parts;$packages{"$pkg $sort_v"}={sort_v=>$sort_v,v=>$v,tail=>$tail }}}my@packages=sort keys%packages;my@sorted;for my$package (@packages){my ($name,undef)=split / /,$package,2;my$tail=$packages{$package}? $packages{$package}->{tail}: '';my$v=$packages{$package}? $packages{$package}->{v}: '';push@sorted,"$name$v$tail"}return@sorted}sub listify {my ($value)=@_;return ref$value eq 'ARRAY' ? @$value : ($value)}1;
APP_STEW_UTIL

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.011';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,blib=>'blib',create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my (%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  use 5.004;use strict;use warnings;package Getopt::Long;use vars qw($VERSION);$VERSION=2.50;use vars qw($VERSION_STRING);$VERSION_STRING="2.50";use Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK);@ISA=qw(Exporter);sub GetOptions(@);sub GetOptionsFromArray(@);sub GetOptionsFromString(@);sub Configure(@);sub HelpMessage(@);sub VersionMessage(@);BEGIN {@EXPORT=qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);@EXPORT_OK=qw(&HelpMessage &VersionMessage &Configure &GetOptionsFromArray &GetOptionsFromString)}use vars@EXPORT,@EXPORT_OK;use vars qw($error $debug $major_version $minor_version);use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order $passthrough);use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);my$bundling_values;sub config(@);sub ConfigDefaults();sub ParseOptionSpec($$);sub OptCtl($);sub FindOption($$$$$);sub ValidValue ($$$$$);my$requested_version=0;sub ConfigDefaults() {if (defined$ENV{"POSIXLY_CORRECT"}){$genprefix="(--|-)";$autoabbrev=0;$bundling=0;$getopt_compat=0;$order=$REQUIRE_ORDER}else {$genprefix="(--|-|\\+)";$autoabbrev=1;$bundling=0;$getopt_compat=1;$order=$PERMUTE}$debug=0;$error=0;$ignorecase=1;$passthrough=0;$gnu_compat=0;$longprefix="(--)";$bundling_values=0}sub import {my$pkg=shift;my@syms=();my@config=();my$dest=\@syms;for (@_){if ($_ eq ':config'){$dest=\@config;next}push(@$dest,$_)}local$Exporter::ExportLevel=1;push(@syms,qw(&GetOptions))if@syms;$requested_version=0;$pkg->SUPER::import(@syms);Configure(@config)if@config}($REQUIRE_ORDER,$PERMUTE,$RETURN_IN_ORDER)=(0..2);($major_version,$minor_version)=$VERSION =~ /^(\d+)\.(\d+)/;ConfigDefaults();package Getopt::Long::Parser;my$default_config=do {Getopt::Long::Configure ()};sub new {my$that=shift;my$class=ref($that)|| $that;my%atts=@_;my$self={caller_pkg=>(caller)[0]};bless ($self,$class);if (defined$atts{config}){my$save=Getopt::Long::Configure ($default_config,@{$atts{config}});$self->{settings}=Getopt::Long::Configure ($save);delete ($atts{config})}else {$self->{settings}=$default_config}if (%atts){die(__PACKAGE__.": unhandled attributes: ".join(" ",sort(keys(%atts)))."\n")}$self}sub configure {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings},@_);$self->{settings}=Getopt::Long::Configure ($save)}sub getoptions {my ($self)=shift;return$self->getoptionsfromarray(\@ARGV,@_)}sub getoptionsfromarray {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings});my$ret=0;$Getopt::Long::caller=$self->{caller_pkg};eval {local ($SIG{__DIE__})='DEFAULT';$ret=Getopt::Long::GetOptionsFromArray (@_)};Getopt::Long::Configure ($save);die ($@)if $@;return$ret}package Getopt::Long;use constant CTL_TYPE=>0;use constant CTL_CNAME=>1;use constant CTL_DEFAULT=>2;use constant CTL_DEST=>3;use constant CTL_DEST_SCALAR=>0;use constant CTL_DEST_ARRAY=>1;use constant CTL_DEST_HASH=>2;use constant CTL_DEST_CODE=>3;use constant CTL_AMIN=>4;use constant CTL_AMAX=>5;use constant PAT_INT=>"[-+]?_*[0-9][0-9_]*";use constant PAT_XINT=>"(?:"."[-+]?_*[1-9][0-9_]*"."|"."0x_*[0-9a-f][0-9a-f_]*"."|"."0b_*[01][01_]*"."|"."0[0-7_]*".")";use constant PAT_FLOAT=>"[-+]?"."(?=[0-9.])"."[0-9_]*"."(\.[0-9_]+)?"."([eE][-+]?[0-9_]+)?";sub GetOptions(@) {unshift(@_,\@ARGV);goto&GetOptionsFromArray}sub GetOptionsFromString(@) {my ($string)=shift;require Text::ParseWords;my$args=[Text::ParseWords::shellwords($string)];$caller ||= (caller)[0];my$ret=GetOptionsFromArray($args,@_);return ($ret,$args)if wantarray;if (@$args){$ret=0;warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n")}$ret}sub GetOptionsFromArray(@) {my ($argv,@optionlist)=@_;my$argend='--';my%opctl=();my$pkg=$caller || (caller)[0];my@ret=();my%linkage;my$userlinkage;my$opt;my$prefix=$genprefix;$error='';if ($debug){local ($^W)=0;print STDERR ("Getopt::Long $Getopt::Long::VERSION ","called from package \"$pkg\".","\n  ","argv: ",defined($argv)? UNIVERSAL::isa($argv,'ARRAY')? "(@$argv)" : $argv : "<undef>","\n  ","autoabbrev=$autoabbrev,"."bundling=$bundling,","bundling_values=$bundling_values,","getopt_compat=$getopt_compat,","gnu_compat=$gnu_compat,","order=$order,","\n  ","ignorecase=$ignorecase,","requested_version=$requested_version,","passthrough=$passthrough,","genprefix=\"$genprefix\",","longprefix=\"$longprefix\".","\n")}$userlinkage=undef;if (@optionlist && ref($optionlist[0])and UNIVERSAL::isa($optionlist[0],'HASH')){$userlinkage=shift (@optionlist);print STDERR ("=> user linkage: $userlinkage\n")if$debug}if (@optionlist && $optionlist[0]=~ /^\W+$/ &&!($optionlist[0]eq '<>' && @optionlist > 0 && ref($optionlist[1]))){$prefix=shift (@optionlist);$prefix =~ s/(\W)/\\$1/g;$prefix="([" .$prefix ."])";print STDERR ("=> prefix=\"$prefix\"\n")if$debug}%opctl=();while (@optionlist){my$opt=shift (@optionlist);unless (defined($opt)){$error .= "Undefined argument in option spec\n";next}$opt=$+ if$opt =~ /^$prefix+(.*)$/s;if ($opt eq '<>'){if ((defined$userlinkage)&&!(@optionlist > 0 && ref($optionlist[0]))&& (exists$userlinkage->{$opt})&& ref($userlinkage->{$opt})){unshift (@optionlist,$userlinkage->{$opt})}unless (@optionlist > 0 && ref($optionlist[0])&& ref($optionlist[0])eq 'CODE'){$error .= "Option spec <> requires a reference to a subroutine\n";shift (@optionlist)if@optionlist && ref($optionlist[0]);next}$linkage{'<>'}=shift (@optionlist);next}my ($name,$orig)=ParseOptionSpec ($opt,\%opctl);unless (defined$name){$error .= $orig;shift (@optionlist)if@optionlist && ref($optionlist[0]);next}if (defined$userlinkage){unless (@optionlist > 0 && ref($optionlist[0])){if (exists$userlinkage->{$orig}&& ref($userlinkage->{$orig})){print STDERR ("=> found userlinkage for \"$orig\": ","$userlinkage->{$orig}\n")if$debug;unshift (@optionlist,$userlinkage->{$orig})}else {next}}}if (@optionlist > 0 && ref($optionlist[0])){print STDERR ("=> link \"$orig\" to $optionlist[0]\n")if$debug;my$rl=ref($linkage{$orig}=shift (@optionlist));if ($rl eq "ARRAY"){$opctl{$name}[CTL_DEST]=CTL_DEST_ARRAY}elsif ($rl eq "HASH"){$opctl{$name}[CTL_DEST]=CTL_DEST_HASH}elsif ($rl eq "SCALAR" || $rl eq "REF"){}elsif ($rl eq "CODE"){}else {$error .= "Invalid option linkage for \"$opt\"\n"}}else {my$ov=$orig;$ov =~ s/\W/_/g;if ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;")}elsif ($opctl{$name}[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;")}else {print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;")}}if ($opctl{$name}[CTL_TYPE]eq 'I' && ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY || $opctl{$name}[CTL_DEST]==CTL_DEST_HASH)){$error .= "Invalid option linkage for \"$opt\"\n"}}$error .= "GetOptionsFromArray: 1st parameter is not an array reference\n" unless$argv && UNIVERSAL::isa($argv,'ARRAY');die ($error)if$error;$error=0;if (defined($auto_version)? $auto_version : ($requested_version >= 2.3203)){if (!defined($opctl{version})){$opctl{version}=['','version',0,CTL_DEST_CODE,undef];$linkage{version}=\&VersionMessage}$auto_version=1}if (defined($auto_help)? $auto_help : ($requested_version >= 2.3203)){if (!defined($opctl{help})&&!defined($opctl{'?'})){$opctl{help}=$opctl{'?'}=['','help',0,CTL_DEST_CODE,undef];$linkage{help}=\&HelpMessage}$auto_help=1}if ($debug){my ($arrow,$k,$v);$arrow="=> ";while (($k,$v)=each(%opctl)){print STDERR ($arrow,"\$opctl{$k} = $v ",OptCtl($v),"\n");$arrow="   "}}my$goon=1;while ($goon && @$argv > 0){$opt=shift (@$argv);print STDERR ("=> arg \"",$opt,"\"\n")if$debug;if (defined($opt)&& $opt eq $argend){push (@ret,$argend)if$passthrough;last}my$tryopt=$opt;my$found;my$key;my$arg;my$ctl;($found,$opt,$ctl,$arg,$key)=FindOption ($argv,$prefix,$argend,$opt,\%opctl);if ($found){next unless defined$opt;my$argcnt=0;while (defined$arg){print STDERR ("=> cname for \"$opt\" is ")if$debug;$opt=$ctl->[CTL_CNAME];print STDERR ("\"$ctl->[CTL_CNAME]\"\n")if$debug;if (defined$linkage{$opt}){print STDERR ("=> ref(\$L{$opt}) -> ",ref($linkage{$opt}),"\n")if$debug;if (ref($linkage{$opt})eq 'SCALAR' || ref($linkage{$opt})eq 'REF'){if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")if$debug;if (defined ${$linkage{$opt}}){${$linkage{$opt}}+= $arg}else {${$linkage{$opt}}=$arg}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to ARRAY\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}=[];print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to HASH\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}={};print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}else {print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")if$debug;${$linkage{$opt}}=$arg}}elsif (ref($linkage{$opt})eq 'ARRAY'){print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif (ref($linkage{$opt})eq 'HASH'){print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}elsif (ref($linkage{$opt})eq 'CODE'){print STDERR ("=> &L{$opt}(\"$opt\"",$ctl->[CTL_DEST]==CTL_DEST_HASH ? ", \"$key\"" : "",", \"$arg\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&{$linkage{$opt}}(Getopt::Long::CallBack->new (name=>$opt,ctl=>$ctl,opctl=>\%opctl,linkage=>\%linkage,prefix=>$prefix,),$ctl->[CTL_DEST]==CTL_DEST_HASH ? ($key): (),$arg)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("Invalid REF type \"",ref($linkage{$opt}),"\" in linkage\n");die("Getopt::Long -- internal error!\n")}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){if (defined$userlinkage->{$opt}){print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")if$debug;push (@{$userlinkage->{$opt}},$arg)}else {print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")if$debug;$userlinkage->{$opt}=[$arg]}}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){if (defined$userlinkage->{$opt}){print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")if$debug;$userlinkage->{$opt}->{$key}=$arg}else {print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")if$debug;$userlinkage->{$opt}={$key=>$arg}}}else {if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$L{$opt} += \"$arg\"\n")if$debug;if (defined$userlinkage->{$opt}){$userlinkage->{$opt}+= $arg}else {$userlinkage->{$opt}=$arg}}else {print STDERR ("=>\$L{$opt} = \"$arg\"\n")if$debug;$userlinkage->{$opt}=$arg}}$argcnt++;last if$argcnt >= $ctl->[CTL_AMAX]&& $ctl->[CTL_AMAX]!=-1;undef($arg);if ($argcnt < $ctl->[CTL_AMIN]){if (@$argv){if (ValidValue($ctl,$argv->[0],1,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}warn("Value \"$$argv[0]\" invalid for option $opt\n");$error++}else {warn("Insufficient arguments for option $opt\n");$error++}}if (@$argv && ValidValue($ctl,$argv->[0],0,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}}}elsif ($order==$PERMUTE){my$cb;if (defined ($cb=$linkage{'<>'})){print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&$cb($tryopt)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("=> saving \"$tryopt\" ","(not an option, may permute)\n")if$debug;push (@ret,$tryopt)}next}else {unshift (@$argv,$tryopt);return ($error==0)}}if (@ret && $order==$PERMUTE){print STDERR ("=> restoring \"",join('" "',@ret),"\"\n")if$debug;unshift (@$argv,@ret)}return ($error==0)}sub OptCtl ($) {my ($v)=@_;my@v=map {defined($_)? ($_): ("<undef>")}@$v;"[".join(",","\"$v[CTL_TYPE]\"","\"$v[CTL_CNAME]\"","\"$v[CTL_DEFAULT]\"",("\$","\@","\%","\&")[$v[CTL_DEST]|| 0],$v[CTL_AMIN]|| '',$v[CTL_AMAX]|| '',)."]"}sub ParseOptionSpec ($$) {my ($opt,$opctl)=@_;if ($opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x){return (undef,"Error in option spec: \"$opt\"\n")}my ($names,$spec)=($1,$2);$spec='' unless defined$spec;my$orig;my@names;if (defined$names){@names=split (/\|/,$names);$orig=$names[0]}else {@names=('');$orig=''}my$entry;if ($spec eq '' || $spec eq '+' || $spec eq '!'){$entry=[$spec,$orig,undef,CTL_DEST_SCALAR,0,0]}elsif ($spec =~ /^:(-?\d+|\+)([@%])?$/){my$def=$1;my$dest=$2;my$type=$def eq '+' ? 'I' : 'i';$dest ||= '$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$entry=[$type,$orig,$def eq '+' ? undef : $def,$dest,0,1]}else {my ($mand,$type,$dest)=$spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;return (undef,"Cannot repeat while bundling: \"$opt\"\n")if$bundling && defined($4);my ($mi,$cm,$ma)=($5,$6,$7);return (undef,"{0} is useless in option spec: \"$opt\"\n")if defined($mi)&&!$mi &&!defined($ma)&&!defined($cm);$type='i' if$type eq 'n';$dest ||= '$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$mi=$mand eq '=' ? 1 : 0 unless defined$mi;$mand=$mi ? '=' : ':';$ma=$mi ? $mi : 1 unless defined$ma || defined$cm;return (undef,"Max must be greater than zero in option spec: \"$opt\"\n")if defined($ma)&&!$ma;return (undef,"Max less than min in option spec: \"$opt\"\n")if defined($ma)&& $ma < $mi;$entry=[$type,$orig,undef,$dest,$mi,$ma||-1]}my$dups='';for (@names){$_=lc ($_)if$ignorecase > (($bundling && length($_)==1)? 1 : 0);if (exists$opctl->{$_}){$dups .= "Duplicate specification \"$opt\" for option \"$_\"\n"}if ($spec eq '!'){$opctl->{"no$_"}=$entry;$opctl->{"no-$_"}=$entry;$opctl->{$_}=[@$entry];$opctl->{$_}->[CTL_TYPE]=''}else {$opctl->{$_}=$entry}}if ($dups && $^W){for (split(/\n+/,$dups)){warn($_."\n")}}($names[0],$orig)}sub FindOption ($$$$$) {my ($argv,$prefix,$argend,$opt,$opctl)=@_;print STDERR ("=> find \"$opt\"\n")if$debug;return (0)unless defined($opt);return (0)unless$opt =~ /^($prefix)(.*)$/s;return (0)if$opt eq "-" &&!defined$opctl->{''};$opt=substr($opt,length($1));my$starter=$1;print STDERR ("=> split \"$starter\"+\"$opt\"\n")if$debug;my$optarg;my$rest;if (($starter=~/^$longprefix$/ || ($getopt_compat && ($bundling==0 || $bundling==2)))&& (my$oppos=index($opt,'=',1))> 0){my$optorg=$opt;$opt=substr($optorg,0,$oppos);$optarg=substr($optorg,$oppos + 1);print STDERR ("=> option \"",$opt,"\", optarg = \"$optarg\"\n")if$debug}my$tryopt=$opt;if (($bundling || $bundling_values)&& $starter eq '-'){$tryopt=$ignorecase ? lc($opt): $opt;if ($bundling==2 && length($tryopt)> 1 && defined ($opctl->{$tryopt})){print STDERR ("=> $starter$tryopt overrides unbundling\n")if$debug}elsif ($bundling_values){$tryopt=$opt;$rest=length ($tryopt)> 0 ? substr ($tryopt,1): '';$tryopt=substr ($tryopt,0,1);$tryopt=lc ($tryopt)if$ignorecase > 1;print STDERR ("=> $starter$tryopt unbundled from ","$starter$tryopt$rest\n")if$debug;$optarg=$rest eq '' ? undef : $rest;$rest=undef}else {$tryopt=$opt;$rest=length ($tryopt)> 0 ? substr ($tryopt,1): '';$tryopt=substr ($tryopt,0,1);$tryopt=lc ($tryopt)if$ignorecase > 1;print STDERR ("=> $starter$tryopt unbundled from ","$starter$tryopt$rest\n")if$debug;$rest=undef unless$rest ne ''}}elsif ($autoabbrev && $opt ne ""){my@names=sort(keys (%$opctl));$opt=lc ($opt)if$ignorecase;$tryopt=$opt;my$pat=quotemeta ($opt);my@hits=grep (/^$pat/,@names);print STDERR ("=> ",scalar(@hits)," hits (@hits) with \"$pat\" ","out of ",scalar(@names),"\n")if$debug;unless ((@hits <= 1)|| (grep ($_ eq $opt,@hits)==1)){my%hit;for (@hits){my$hit=$opctl->{$_}->[CTL_CNAME]if defined$opctl->{$_}->[CTL_CNAME];$hit="no" .$hit if$opctl->{$_}->[CTL_TYPE]eq '!';$hit{$hit}=1}if (keys(%hit)==2){if ($auto_version && exists($hit{version})){delete$hit{version}}elsif ($auto_help && exists($hit{help})){delete$hit{help}}}unless (keys(%hit)==1){return (0)if$passthrough;warn ("Option ",$opt," is ambiguous (",join(", ",@hits),")\n");$error++;return (1,undef)}@hits=keys(%hit)}if (@hits==1 && $hits[0]ne $opt){$tryopt=$hits[0];$tryopt=lc ($tryopt)if$ignorecase > (($bundling && length($tryopt)==1)? 1 : 0);print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")if$debug}}elsif ($ignorecase){$tryopt=lc ($opt)}my$ctl=$opctl->{$tryopt};unless (defined$ctl){return (0)if$passthrough;if ($bundling==1 && length($starter)==1){$opt=substr($opt,0,1);unshift (@$argv,$starter.$rest)if defined$rest}if ($opt eq ""){warn ("Missing option after ",$starter,"\n")}else {warn ("Unknown option: ",$opt,"\n")}$error++;return (1,undef)}$opt=$tryopt;print STDERR ("=> found ",OptCtl($ctl)," for \"",$opt,"\"\n")if$debug;my$type=$ctl->[CTL_TYPE];my$arg;if ($type eq '' || $type eq '!' || $type eq '+'){if (defined$optarg){return (0)if$passthrough;warn ("Option ",$opt," does not take an argument\n");$error++;undef$opt;undef$optarg if$bundling_values}elsif ($type eq '' || $type eq '+'){$arg=1}else {$opt =~ s/^no-?//i;$arg=0}unshift (@$argv,$starter.$rest)if defined$rest;return (1,$opt,$ctl,$arg)}my$mand=$ctl->[CTL_AMIN];if ($gnu_compat){my$optargtype=0;if (defined($optarg)){$optargtype=(length($optarg)==0)? 1 : 2}elsif (defined$rest || @$argv > 0){$optargtype=3}if(($optargtype==0)&&!$mand){my$val =defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: $type eq 's' ? '' : 0;return (1,$opt,$ctl,$val)}return (1,$opt,$ctl,$type eq 's' ? '' : 0)if$optargtype==1}if (defined$optarg ? ($optarg eq ''):!(defined$rest || @$argv > 0)){if ($mand){return (0)if$passthrough;warn ("Option ",$opt," requires an argument\n");$error++;return (1,undef)}if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}return (1,$opt,$ctl,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: $type eq 's' ? '' : 0)}$arg=(defined$rest ? $rest : (defined$optarg ? $optarg : shift (@$argv)));my$key;if ($ctl->[CTL_DEST]==CTL_DEST_HASH && defined$arg){($key,$arg)=($arg =~ /^([^=]*)=(.*)$/s)? ($1,$2): ($arg,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: ($mand ? undef : ($type eq 's' ? "" : 1)));if (!defined$arg){warn ("Option $opt, key \"$key\", requires a value\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}}my$key_valid=$ctl->[CTL_DEST]==CTL_DEST_HASH ? "[^=]+=" : "";if ($type eq 's'){return (1,$opt,$ctl,$arg,$key)if$mand;return (1,$opt,$ctl,$arg,$key)if$ctl->[CTL_DEST]==CTL_DEST_HASH;return (1,$opt,$ctl,$arg,$key)if defined$optarg || defined$rest;return (1,$opt,$ctl,$arg,$key)if$arg eq "-";if ($arg eq $argend || $arg =~ /^$prefix.+/){unshift (@$argv,$arg);$arg=''}}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/si){($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/si){$arg =~ tr/_//d;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (",$type eq 'o' ? "extended " : '',"number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}$arg=defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: 0}}}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/s){$arg =~ tr/_//d;($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/){$arg =~ tr/_//d}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (real number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);$arg=0.0}}}else {die("Getopt::Long internal error (Can't happen)\n")}return (1,$opt,$ctl,$arg,$key)}sub ValidValue ($$$$$) {my ($ctl,$arg,$mand,$argend,$prefix)=@_;if ($ctl->[CTL_DEST]==CTL_DEST_HASH){return 0 unless$arg =~ /[^=]+=(.*)/;$arg=$1}my$type=$ctl->[CTL_TYPE];if ($type eq 's'){return (1)if$mand;return (1)if$arg eq "-";return 0 if$arg eq $argend || $arg =~ /^$prefix.+/;return 1}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;return$arg =~ /^$o_valid$/si}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;return$arg =~ /^$o_valid$/}die("ValidValue: Cannot happen\n")}sub Configure (@) {my (@options)=@_;my$prevconfig=[$error,$debug,$major_version,$minor_version,$caller,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix,$bundling_values ];if (ref($options[0])eq 'ARRAY'){($error,$debug,$major_version,$minor_version,$caller,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix,$bundling_values)=@{shift(@options)}}my$opt;for$opt (@options){my$try=lc ($opt);my$action=1;if ($try =~ /^no_?(.*)$/s){$action=0;$try=$+}if (($try eq 'default' or $try eq 'defaults')&& $action){ConfigDefaults ()}elsif (($try eq 'posix_default' or $try eq 'posix_defaults')){local$ENV{POSIXLY_CORRECT};$ENV{POSIXLY_CORRECT}=1 if$action;ConfigDefaults ()}elsif ($try eq 'auto_abbrev' or $try eq 'autoabbrev'){$autoabbrev=$action}elsif ($try eq 'getopt_compat'){$getopt_compat=$action;$genprefix=$action ? "(--|-|\\+)" : "(--|-)"}elsif ($try eq 'gnu_getopt'){if ($action){$gnu_compat=1;$bundling=1;$getopt_compat=0;$genprefix="(--|-)";$order=$PERMUTE;$bundling_values=0}}elsif ($try eq 'gnu_compat'){$gnu_compat=$action;$bundling=0;$bundling_values=1}elsif ($try =~ /^(auto_?)?version$/){$auto_version=$action}elsif ($try =~ /^(auto_?)?help$/){$auto_help=$action}elsif ($try eq 'ignorecase' or $try eq 'ignore_case'){$ignorecase=$action}elsif ($try eq 'ignorecase_always' or $try eq 'ignore_case_always'){$ignorecase=$action ? 2 : 0}elsif ($try eq 'bundling'){$bundling=$action;$bundling_values=0 if$action}elsif ($try eq 'bundling_override'){$bundling=$action ? 2 : 0;$bundling_values=0 if$action}elsif ($try eq 'bundling_values'){$bundling_values=$action;$bundling=0 if$action}elsif ($try eq 'require_order'){$order=$action ? $REQUIRE_ORDER : $PERMUTE}elsif ($try eq 'permute'){$order=$action ? $PERMUTE : $REQUIRE_ORDER}elsif ($try eq 'pass_through' or $try eq 'passthrough'){$passthrough=$action}elsif ($try =~ /^prefix=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .quotemeta($genprefix).")";eval {'' =~ /$genprefix/};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^prefix_pattern=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .$genprefix .")" unless$genprefix =~ /^\(.*\)$/;eval {'' =~ m"$genprefix"};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^long_prefix_pattern=(.+)$/ && $action){$longprefix=$1;$longprefix="(" .$longprefix .")" unless$longprefix =~ /^\(.*\)$/;eval {'' =~ m"$longprefix"};die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n")if $@}elsif ($try eq 'debug'){$debug=$action}else {die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")}}$prevconfig}sub config (@) {Configure (@_)}sub VersionMessage(@) {my$pa=setup_pa_args("version",@_);my$v=$main::VERSION;my$fh=$pa->{-output}|| (($pa->{-exitval}eq "NOEXIT" || $pa->{-exitval}< 2)? \*STDOUT : \*STDERR);print$fh (defined($pa->{-message})? $pa->{-message}: (),$0,defined$v ? " version $v" : (),"\n","(",__PACKAGE__,"::","GetOptions"," version ",defined($Getopt::Long::VERSION_STRING)? $Getopt::Long::VERSION_STRING : $VERSION,";"," Perl version ",$] >= 5.006 ? sprintf("%vd",$^V): $],")\n");exit($pa->{-exitval})unless$pa->{-exitval}eq "NOEXIT"}sub HelpMessage(@) {eval {require Pod::Usage;import Pod::Usage;1}|| die("Cannot provide help: cannot load Pod::Usage\n");pod2usage(setup_pa_args("help",@_))}sub setup_pa_args($@) {my$tag=shift;@_=()if @_==2 && $_[0]eq $tag;my$pa;if (@_ > 1){$pa={@_ }}else {$pa=shift || {}}if (UNIVERSAL::isa($pa,'HASH')){$pa->{-message}=$pa->{-msg};delete($pa->{-msg})}elsif ($pa =~ /^-?\d+$/){$pa={-exitval=>$pa }}else {$pa={-message=>$pa }}$pa->{-verbose}=0 unless exists($pa->{-verbose});$pa->{-exitval}=0 unless exists($pa->{-exitval});$pa}sub VERSION {$requested_version=$_[1];shift->SUPER::VERSION(@_)}package Getopt::Long::CallBack;sub new {my ($pkg,%atts)=@_;bless {%atts },$pkg}sub name {my$self=shift;''.$self->{name}}use overload '""'=>\&name,fallback=>1;1;
GETOPT_LONG

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  package HTTP::Tiny;use strict;use warnings;our$VERSION='0.070';sub _croak {require Carp;Carp::croak(@_)}my@attributes;BEGIN {@attributes=qw(cookie_jar default_headers http_proxy https_proxy keep_alive local_address max_redirect max_size proxy no_proxy SSL_options verify_SSL);my%persist_ok=map {;$_=>1}qw(cookie_jar default_headers max_redirect max_size);no strict 'refs';no warnings 'uninitialized';for my$accessor (@attributes){*{$accessor}=sub {@_ > 1 ? do {delete $_[0]->{handle}if!$persist_ok{$accessor}&& $_[1]ne $_[0]->{$accessor};$_[0]->{$accessor}=$_[1]}: $_[0]->{$accessor}}}}sub agent {my($self,$agent)=@_;if(@_ > 1){$self->{agent}=(defined$agent && $agent =~ / $/)? $agent .$self->_agent : $agent}return$self->{agent}}sub timeout {my ($self,$timeout)=@_;if (@_ > 1){$self->{timeout}=$timeout;if ($self->{handle}){$self->{handle}->timeout($timeout)}}return$self->{timeout}}sub new {my($class,%args)=@_;my$self={max_redirect=>5,timeout=>defined$args{timeout}? $args{timeout}: 60,keep_alive=>1,verify_SSL=>$args{verify_SSL}|| $args{verify_ssl}|| 0,no_proxy=>$ENV{no_proxy},};bless$self,$class;$class->_validate_cookie_jar($args{cookie_jar})if$args{cookie_jar};for my$key (@attributes){$self->{$key}=$args{$key}if exists$args{$key}}$self->agent(exists$args{agent}? $args{agent}: $class->_agent);$self->_set_proxies;return$self}sub _set_proxies {my ($self)=@_;if (!exists$self->{proxy}){$self->{proxy}=$ENV{all_proxy}|| $ENV{ALL_PROXY}}if (defined$self->{proxy}){$self->_split_proxy('generic proxy'=>$self->{proxy})}else {delete$self->{proxy}}if (!exists$self->{http_proxy}){local$ENV{HTTP_PROXY}if$ENV{REQUEST_METHOD};$self->{http_proxy}=$ENV{http_proxy}|| $ENV{HTTP_PROXY}|| $self->{proxy}}if (defined$self->{http_proxy}){$self->_split_proxy(http_proxy=>$self->{http_proxy});$self->{_has_proxy}{http}=1}else {delete$self->{http_proxy}}if (!exists$self->{https_proxy}){$self->{https_proxy}=$ENV{https_proxy}|| $ENV{HTTPS_PROXY}|| $self->{proxy}}if ($self->{https_proxy}){$self->_split_proxy(https_proxy=>$self->{https_proxy});$self->{_has_proxy}{https}=1}else {delete$self->{https_proxy}}unless (ref$self->{no_proxy}eq 'ARRAY'){$self->{no_proxy}=(defined$self->{no_proxy})? [split /\s*,\s*/,$self->{no_proxy}]: []}return}for my$sub_name (qw/get head put post delete/){my$req_method=uc$sub_name;no strict 'refs';eval <<"HERE"}sub post_form {my ($self,$url,$data,$args)=@_;(@_==3 || @_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ ."\n");my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}delete$args->{headers};return$self->request('POST',$url,{%$args,content=>$self->www_form_urlencode($data),headers=>{%$headers,'content-type'=>'application/x-www-form-urlencoded' },})}sub mirror {my ($self,$url,$file,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ ."\n");if (exists$args->{headers}){my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}$args->{headers}=$headers}if (-e $file and my$mtime=(stat($file))[9]){$args->{headers}{'if-modified-since'}||= $self->_http_date($mtime)}my$tempfile=$file .int(rand(2**31));require Fcntl;sysopen my$fh,$tempfile,Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()or _croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);binmode$fh;$args->{data_callback}=sub {print {$fh}$_[0]};my$response=$self->request('GET',$url,$args);close$fh or _croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);if ($response->{success}){rename$tempfile,$file or _croak(qq/Error replacing $file with $tempfile: $!\n/);my$lm=$response->{headers}{'last-modified'};if ($lm and my$mtime=$self->_parse_http_date($lm)){utime$mtime,$mtime,$file}}$response->{success}||= $response->{status}eq '304';unlink$tempfile;return$response}my%idempotent=map {$_=>1}qw/GET HEAD PUT DELETE OPTIONS TRACE/;sub request {my ($self,$method,$url,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ ."\n");$args ||= {};my$response;for (0 .. 1){$response=eval {$self->_request($method,$url,$args)};last unless $@ && $idempotent{$method}&& $@ =~ m{^(?:Socket closed|Unexpected end)}}if (my$e=$@){if (ref$e eq 'HASH' && exists$e->{status}){$e->{redirects}=delete$args->{_redirects}if @{$args->{_redirects}|| []};return$e}$e="$e";$response={url=>$url,success=>q{},status=>599,reason=>'Internal Exception',content=>$e,headers=>{'content-type'=>'text/plain','content-length'=>length$e,},(@{$args->{_redirects}|| []}? (redirects=>delete$args->{_redirects}): ()),}}return$response}sub www_form_urlencode {my ($self,$data)=@_;(@_==2 && ref$data)or _croak(q/Usage: $http->www_form_urlencode(DATAREF)/ ."\n");(ref$data eq 'HASH' || ref$data eq 'ARRAY')or _croak("form data must be a hash or array reference\n");my@params=ref$data eq 'HASH' ? %$data : @$data;@params % 2==0 or _croak("form data reference must have an even number of terms\n");my@terms;while(@params){my ($key,$value)=splice(@params,0,2);if (ref$value eq 'ARRAY'){unshift@params,map {$key=>$_}@$value}else {push@terms,join("=",map {$self->_uri_escape($_)}$key,$value)}}return join("&",(ref$data eq 'ARRAY')? (@terms): (sort@terms))}sub can_ssl {my ($self)=@_;my($ok,$reason)=(1,'');local@INC=@INC;pop@INC if$INC[-1]eq '.';unless (eval {require IO::Socket::SSL;IO::Socket::SSL->VERSION(1.42)}){$ok=0;$reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/}unless (eval {require Net::SSLeay;Net::SSLeay->VERSION(1.49)}){$ok=0;$reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/}if (ref($self)&& ($self->{verify_SSL}|| $self->{SSL_options}{SSL_verify_mode})){my$handle=HTTP::Tiny::Handle->new(SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},);unless (eval {$handle->_find_CA_file;1}){$ok=0;$reason .= "$@"}}wantarray ? ($ok,$reason): $ok}sub connected {my ($self)=@_;if ($self->{handle}&& $self->{handle}{fh}){my$socket=$self->{handle}{fh};if ($socket->connected){return wantarray ? ($socket->peerhost,$socket->peerport): join(':',$socket->peerhost,$socket->peerport)}}return}my%DefaultPort=(http=>80,https=>443,);sub _agent {my$class=ref($_[0])|| $_[0];(my$default_agent=$class)=~ s{::}{-}g;return$default_agent ."/" .$class->VERSION}sub _request {my ($self,$method,$url,$args)=@_;my ($scheme,$host,$port,$path_query,$auth)=$self->_split_url($url);my$request={method=>$method,scheme=>$scheme,host=>$host,port=>$port,host_port=>($port==$DefaultPort{$scheme}? $host : "$host:$port"),uri=>$path_query,headers=>{},};my$peer=$args->{peer}|| $host;my$handle=delete$self->{handle};if ($handle){unless ($handle->can_reuse($scheme,$host,$port,$peer)){$handle->close;undef$handle}}$handle ||= $self->_open_handle($request,$scheme,$host,$port,$peer);$self->_prepare_headers_and_cb($request,$args,$url,$auth);$handle->write_request($request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');$self->_update_cookie_jar($url,$response)if$self->{cookie_jar};my@redir_args=$self->_maybe_redirect($request,$response,$args);my$known_message_length;if ($method eq 'HEAD' || $response->{status}=~ /^[23]04/){$known_message_length=1}else {my$cb_args=@redir_args ? +{}: $args;my$data_cb=$self->_prepare_data_cb($response,$cb_args);$known_message_length=$handle->read_body($data_cb,$response)}if ($self->{keep_alive}&& $known_message_length && $response->{protocol}eq 'HTTP/1.1' && ($response->{headers}{connection}|| '')ne 'close'){$self->{handle}=$handle}else {$handle->close}$response->{success}=substr($response->{status},0,1)eq '2';$response->{url}=$url;if (@redir_args){push @{$args->{_redirects}},$response;return$self->_request(@redir_args,$args)}$response->{redirects}=delete$args->{_redirects}if @{$args->{_redirects}};return$response}sub _open_handle {my ($self,$request,$scheme,$host,$port,$peer)=@_;my$handle=HTTP::Tiny::Handle->new(timeout=>$self->{timeout},SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},local_address=>$self->{local_address},keep_alive=>$self->{keep_alive});if ($self->{_has_proxy}{$scheme}&&!grep {$host =~ /\Q$_\E$/}@{$self->{no_proxy}}){return$self->_proxy_connect($request,$handle)}else {return$handle->connect($scheme,$host,$port,$peer)}}sub _proxy_connect {my ($self,$request,$handle)=@_;my@proxy_vars;if ($request->{scheme}eq 'https'){_croak(qq{No https_proxy defined})unless$self->{https_proxy};@proxy_vars=$self->_split_proxy(https_proxy=>$self->{https_proxy});if ($proxy_vars[0]eq 'https'){_croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}})}}else {_croak(qq{No http_proxy defined})unless$self->{http_proxy};@proxy_vars=$self->_split_proxy(http_proxy=>$self->{http_proxy})}my ($p_scheme,$p_host,$p_port,$p_auth)=@proxy_vars;if (length$p_auth &&!defined$request->{headers}{'proxy-authorization'}){$self->_add_basic_auth_header($request,'proxy-authorization'=>$p_auth)}$handle->connect($p_scheme,$p_host,$p_port,$p_host);if ($request->{scheme}eq 'https'){$self->_create_proxy_tunnel($request,$handle)}else {$request->{uri}="$request->{scheme}://$request->{host_port}$request->{uri}"}return$handle}sub _split_proxy {my ($self,$type,$proxy)=@_;my ($scheme,$host,$port,$path_query,$auth)=eval {$self->_split_url($proxy)};unless(defined($scheme)&& length($scheme)&& length($host)&& length($port)&& $path_query eq '/'){_croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n})}return ($scheme,$host,$port,$auth)}sub _create_proxy_tunnel {my ($self,$request,$handle)=@_;$handle->_assert_ssl;my$agent=exists($request->{headers}{'user-agent'})? $request->{headers}{'user-agent'}: $self->{agent};my$connect_request={method=>'CONNECT',uri=>"$request->{host}:$request->{port}",headers=>{host=>"$request->{host}:$request->{port}",'user-agent'=>$agent,}};if ($request->{headers}{'proxy-authorization'}){$connect_request->{headers}{'proxy-authorization'}=delete$request->{headers}{'proxy-authorization'}}$handle->write_request($connect_request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');unless (substr($response->{status},0,1)eq '2'){die$response}$handle->start_ssl($request->{host});return}sub _prepare_headers_and_cb {my ($self,$request,$args,$url,$auth)=@_;for ($self->{default_headers},$args->{headers}){next unless defined;while (my ($k,$v)=each %$_){$request->{headers}{lc$k}=$v;$request->{header_case}{lc$k}=$k}}if (exists$request->{headers}{'host'}){die(qq/The 'Host' header must not be provided as header option\n/)}$request->{headers}{'host'}=$request->{host_port};$request->{headers}{'user-agent'}||= $self->{agent};$request->{headers}{'connection'}="close" unless$self->{keep_alive};if (defined$args->{content}){if (ref$args->{content}eq 'CODE'){$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'transfer-encoding'}='chunked' unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=$args->{content}}elsif (length$args->{content}){my$content=$args->{content};if ($] ge '5.008'){utf8::downgrade($content,1)or die(qq/Wide character in request message body\n/)}$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'content-length'}=length$content unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=sub {substr$content,0,length$content,''}}$request->{trailer_cb}=$args->{trailer_callback}if ref$args->{trailer_callback}eq 'CODE'}if ($self->{cookie_jar}){my$cookies=$self->cookie_jar->cookie_header($url);$request->{headers}{cookie}=$cookies if length$cookies}if (length$auth &&!defined$request->{headers}{authorization}){$self->_add_basic_auth_header($request,'authorization'=>$auth)}return}sub _add_basic_auth_header {my ($self,$request,$header,$auth)=@_;require MIME::Base64;$request->{headers}{$header}="Basic " .MIME::Base64::encode_base64($auth,"");return}sub _prepare_data_cb {my ($self,$response,$args)=@_;my$data_cb=$args->{data_callback};$response->{content}='';if (!$data_cb || $response->{status}!~ /^2/){if (defined$self->{max_size}){$data_cb=sub {$_[1]->{content}.= $_[0];die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)if length $_[1]->{content}> $self->{max_size}}}else {$data_cb=sub {$_[1]->{content}.= $_[0]}}}return$data_cb}sub _update_cookie_jar {my ($self,$url,$response)=@_;my$cookies=$response->{headers}->{'set-cookie'};return unless defined$cookies;my@cookies=ref$cookies ? @$cookies : $cookies;$self->cookie_jar->add($url,$_)for@cookies;return}sub _validate_cookie_jar {my ($class,$jar)=@_;for my$method (qw/add cookie_header/){_croak(qq/Cookie jar must provide the '$method' method\n/)unless ref($jar)&& ref($jar)->can($method)}return}sub _maybe_redirect {my ($self,$request,$response,$args)=@_;my$headers=$response->{headers};my ($status,$method)=($response->{status},$request->{method});$args->{_redirects}||= [];if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))and $headers->{location}and @{$args->{_redirects}}< $self->{max_redirect}){my$location=($headers->{location}=~ /^\//)? "$request->{scheme}://$request->{host_port}$headers->{location}" : $headers->{location};return (($status eq '303' ? 'GET' : $method),$location)}return}sub _split_url {my$url=pop;my ($scheme,$host,$path_query)=$url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)> or die(qq/Cannot parse URL: '$url'\n/);$scheme=lc$scheme;$path_query="/$path_query" unless$path_query =~ m<\A/>;my$auth='';if ((my$i=index$host,'@')!=-1){$auth=substr$host,0,$i,'';substr$host,0,1,'';$auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}my$port=$host =~ s/:(\d*)\z// && length $1 ? $1 : $scheme eq 'http' ? 80 : $scheme eq 'https' ? 443 : undef;return ($scheme,(length$host ? lc$host : "localhost"),$port,$path_query,$auth)}my$DoW="Sun|Mon|Tue|Wed|Thu|Fri|Sat";my$MoY="Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";sub _http_date {my ($sec,$min,$hour,$mday,$mon,$year,$wday)=gmtime($_[1]);return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",substr($DoW,$wday*4,3),$mday,substr($MoY,$mon*4,3),$year+1900,$hour,$min,$sec)}sub _parse_http_date {my ($self,$str)=@_;require Time::Local;my@tl_parts;if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/){@tl_parts=($5,$4,$3,$2,(index($MoY,$1)/4),$6)}return eval {my$t=@tl_parts ? Time::Local::timegm(@tl_parts): -1;$t < 0 ? undef : $t}}my%escapes=map {chr($_)=>sprintf("%%%02X",$_)}0..255;$escapes{' '}="+";my$unsafe_char=qr/[^A-Za-z0-9\-\._~]/;sub _uri_escape {my ($self,$str)=@_;if ($] ge '5.008'){utf8::encode($str)}else {$str=pack("U*",unpack("C*",$str))if (length$str==do {use bytes;length$str});$str=pack("C*",unpack("C*",$str))}$str =~ s/($unsafe_char)/$escapes{$1}/ge;return$str}package HTTP::Tiny::Handle;use strict;use warnings;use Errno qw[EINTR EPIPE];use IO::Socket qw[SOCK_STREAM];use Socket qw[SOL_SOCKET SO_KEEPALIVE];my$SOCKET_CLASS=$ENV{PERL_HTTP_TINY_IPV4_ONLY}? 'IO::Socket::INET' : eval {require IO::Socket::IP;IO::Socket::IP->VERSION(0.25)}? 'IO::Socket::IP' : 'IO::Socket::INET';sub BUFSIZE () {32768}my$Printable=sub {local $_=shift;s/\r/\\r/g;s/\n/\\n/g;s/\t/\\t/g;s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;$_};my$Token=qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;my$Field_Content=qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;sub new {my ($class,%args)=@_;return bless {rbuf=>'',timeout=>60,max_line_size=>16384,max_header_lines=>64,verify_SSL=>0,SSL_options=>{},%args },$class}sub timeout {my ($self,$timeout)=@_;if (@_ > 1){$self->{timeout}=$timeout;if ($self->{fh}&& $self->{fh}->can('timeout')){$self->{fh}->timeout($timeout)}}return$self->{timeout}}sub connect {@_==5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ ."\n");my ($self,$scheme,$host,$port,$peer)=@_;if ($scheme eq 'https'){$self->_assert_ssl}elsif ($scheme ne 'http'){die(qq/Unsupported URL scheme '$scheme'\n/)}$self->{fh}=$SOCKET_CLASS->new(PeerHost=>$peer,PeerPort=>$port,$self->{local_address}? (LocalAddr=>$self->{local_address}): (),Proto=>'tcp',Type=>SOCK_STREAM,Timeout=>$self->{timeout},)or die(qq/Could not connect to '$host:$port': $@\n/);binmode($self->{fh})or die(qq/Could not binmode() socket: '$!'\n/);if ($self->{keep_alive}){unless (defined($self->{fh}->setsockopt(SOL_SOCKET,SO_KEEPALIVE,1))){CORE::close($self->{fh});die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/)}}$self->start_ssl($host)if$scheme eq 'https';$self->{scheme}=$scheme;$self->{host}=$host;$self->{peer}=$peer;$self->{port}=$port;$self->{pid}=$$;$self->{tid}=_get_tid();return$self}sub start_ssl {my ($self,$host)=@_;if (ref($self->{fh})eq 'IO::Socket::SSL'){unless ($self->{fh}->stop_SSL){my$ssl_err=IO::Socket::SSL->errstr;die(qq/Error halting prior SSL connection: $ssl_err/)}}my$ssl_args=$self->_ssl_args($host);IO::Socket::SSL->start_SSL($self->{fh},%$ssl_args,SSL_create_ctx_callback=>sub {my$ctx=shift;Net::SSLeay::CTX_set_mode($ctx,Net::SSLeay::MODE_AUTO_RETRY())},);unless (ref($self->{fh})eq 'IO::Socket::SSL'){my$ssl_err=IO::Socket::SSL->errstr;die(qq/SSL connection failed for $host: $ssl_err\n/)}}sub close {@_==1 || die(q/Usage: $handle->close()/ ."\n");my ($self)=@_;CORE::close($self->{fh})or die(qq/Could not close socket: '$!'\n/)}sub write {@_==2 || die(q/Usage: $handle->write(buf)/ ."\n");my ($self,$buf)=@_;if ($] ge '5.008'){utf8::downgrade($buf,1)or die(qq/Wide character in write()\n/)}my$len=length$buf;my$off=0;local$SIG{PIPE}='IGNORE';while (){$self->can_write or die(qq/Timed out while waiting for socket to become ready for writing\n/);my$r=syswrite($self->{fh},$buf,$len,$off);if (defined$r){$len -= $r;$off += $r;last unless$len > 0}elsif ($!==EPIPE){die(qq/Socket closed by remote server: $!\n/)}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not write to SSL socket: '$err'\n /)}else {die(qq/Could not write to socket: '$!'\n/)}}}return$off}sub read {@_==2 || @_==3 || die(q/Usage: $handle->read(len [, allow_partial])/ ."\n");my ($self,$len,$allow_partial)=@_;my$buf='';my$got=length$self->{rbuf};if ($got){my$take=($got < $len)? $got : $len;$buf=substr($self->{rbuf},0,$take,'');$len -= $take}while ($len > 0){$self->can_read or die(q/Timed out while waiting for socket to become ready for reading/ ."\n");my$r=sysread($self->{fh},$buf,$len,length$buf);if (defined$r){last unless$r;$len -= $r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}if ($len &&!$allow_partial){die(qq/Unexpected end of stream\n/)}return$buf}sub readline {@_==1 || die(q/Usage: $handle->readline()/ ."\n");my ($self)=@_;while (){if ($self->{rbuf}=~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x){return $1}if (length$self->{rbuf}>= $self->{max_line_size}){die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/)}$self->can_read or die(qq/Timed out while waiting for socket to become ready for reading\n/);my$r=sysread($self->{fh},$self->{rbuf},BUFSIZE,length$self->{rbuf});if (defined$r){last unless$r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}die(qq/Unexpected end of stream while looking for line\n/)}sub read_header_lines {@_==1 || @_==2 || die(q/Usage: $handle->read_header_lines([headers])/ ."\n");my ($self,$headers)=@_;$headers ||= {};my$lines=0;my$val;while (){my$line=$self->readline;if (++$lines >= $self->{max_header_lines}){die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/)}elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x){my ($field_name)=lc $1;if (exists$headers->{$field_name}){for ($headers->{$field_name}){$_=[$_]unless ref $_ eq "ARRAY";push @$_,$2;$val=\$_->[-1]}}else {$val=\($headers->{$field_name}=$2)}}elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x){$val or die(qq/Unexpected header continuation line\n/);next unless length $1;$$val .= ' ' if length $$val;$$val .= $1}elsif ($line =~ /\A \x0D?\x0A \z/x){last}else {die(q/Malformed header line: / .$Printable->($line)."\n")}}return$headers}sub write_request {@_==2 || die(q/Usage: $handle->write_request(request)/ ."\n");my($self,$request)=@_;$self->write_request_header(@{$request}{qw/method uri headers header_case/});$self->write_body($request)if$request->{cb};return}my@rfc_request_headers=qw(Accept Accept-Charset Accept-Encoding Accept-Language Authorization Cache-Control Connection Content-Length Expect From Host If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer Transfer-Encoding Upgrade User-Agent Via);my@other_request_headers=qw(Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin X-XSS-Protection);my%HeaderCase=map {lc($_)=>$_}@rfc_request_headers,@other_request_headers;sub write_header_lines {(@_ >= 2 && @_ <= 4 && ref $_[1]eq 'HASH')|| die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ ."\n");my($self,$headers,$header_case,$prefix_data)=@_;$header_case ||= {};my$buf=(defined$prefix_data ? $prefix_data : '');my%seen;for my$k (qw/host cache-control expect max-forwards pragma range te/){next unless exists$headers->{$k};$seen{$k}++;my$field_name=$HeaderCase{$k};my$v=$headers->{$k};for (ref$v eq 'ARRAY' ? @$v : $v){$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}while (my ($k,$v)=each %$headers){my$field_name=lc$k;next if$seen{$field_name};if (exists$HeaderCase{$field_name}){$field_name=$HeaderCase{$field_name}}else {if (exists$header_case->{$field_name}){$field_name=$header_case->{$field_name}}else {$field_name =~ s/\b(\w)/\u$1/g}$field_name =~ /\A $Token+ \z/xo or die(q/Invalid HTTP header field name: / .$Printable->($field_name)."\n");$HeaderCase{lc$field_name}=$field_name}for (ref$v eq 'ARRAY' ? @$v : $v){s/\x0D?\x0A\s+/ /g;die(qq/Invalid HTTP header field value ($field_name): / .$Printable->($_)."\n")unless $_ eq '' || /\A $Field_Content \z/xo;$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}$buf .= "\x0D\x0A";return$self->write($buf)}sub read_body {@_==3 || die(q/Usage: $handle->read_body(callback, response)/ ."\n");my ($self,$cb,$response)=@_;my$te=$response->{headers}{'transfer-encoding'}|| '';my$chunked=grep {/chunked/i}(ref$te eq 'ARRAY' ? @$te : $te);return$chunked ? $self->read_chunked_body($cb,$response): $self->read_content_body($cb,$response)}sub write_body {@_==2 || die(q/Usage: $handle->write_body(request)/ ."\n");my ($self,$request)=@_;if ($request->{headers}{'content-length'}){return$self->write_content_body($request)}else {return$self->write_chunked_body($request)}}sub read_content_body {@_==3 || @_==4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ ."\n");my ($self,$cb,$response,$content_length)=@_;$content_length ||= $response->{headers}{'content-length'};if (defined$content_length){my$len=$content_length;while ($len > 0){my$read=($len > BUFSIZE)? BUFSIZE : $len;$cb->($self->read($read,0),$response);$len -= $read}return length($self->{rbuf})==0}my$chunk;$cb->($chunk,$response)while length($chunk=$self->read(BUFSIZE,1));return}sub write_content_body {@_==2 || die(q/Usage: $handle->write_content_body(request)/ ."\n");my ($self,$request)=@_;my ($len,$content_length)=(0,$request->{headers}{'content-length'});while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_content()\n/)}$len += $self->write($data)}$len==$content_length or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);return$len}sub read_chunked_body {@_==3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ ."\n");my ($self,$cb,$response)=@_;while (){my$head=$self->readline;$head =~ /\A ([A-Fa-f0-9]+)/x or die(q/Malformed chunk head: / .$Printable->($head)."\n");my$len=hex($1)or last;$self->read_content_body($cb,$response,$len);$self->read(2)eq "\x0D\x0A" or die(qq/Malformed chunk: missing CRLF after chunk data\n/)}$self->read_header_lines($response->{headers});return 1}sub write_chunked_body {@_==2 || die(q/Usage: $handle->write_chunked_body(request)/ ."\n");my ($self,$request)=@_;my$len=0;while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_chunked_body()\n/)}$len += length$data;my$chunk=sprintf '%X',length$data;$chunk .= "\x0D\x0A";$chunk .= $data;$chunk .= "\x0D\x0A";$self->write($chunk)}$self->write("0\x0D\x0A");if (ref$request->{trailer_cb}eq 'CODE'){$self->write_header_lines($request->{trailer_cb}->())}else {$self->write("\x0D\x0A")}return$len}sub read_response_header {@_==1 || die(q/Usage: $handle->read_response_header()/ ."\n");my ($self)=@_;my$line=$self->readline;$line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x or die(q/Malformed Status-Line: / .$Printable->($line)."\n");my ($protocol,$version,$status,$reason)=($1,$2,$3,$4);die (qq/Unsupported HTTP protocol: $protocol\n/)unless$version =~ /0*1\.0*[01]/;return {status=>$status,reason=>$reason,headers=>$self->read_header_lines,protocol=>$protocol,}}sub write_request_header {@_==5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ ."\n");my ($self,$method,$request_uri,$headers,$header_case)=@_;return$self->write_header_lines($headers,$header_case,"$method $request_uri HTTP/1.1\x0D\x0A")}sub _do_timeout {my ($self,$type,$timeout)=@_;$timeout=$self->{timeout}unless defined$timeout && $timeout >= 0;my$fd=fileno$self->{fh};defined$fd && $fd >= 0 or die(qq/select(2): 'Bad file descriptor'\n/);my$initial=time;my$pending=$timeout;my$nfound;vec(my$fdset='',$fd,1)=1;while (){$nfound=($type eq 'read')? select($fdset,undef,undef,$pending): select(undef,$fdset,undef,$pending);if ($nfound==-1){$!==EINTR or die(qq/select(2): '$!'\n/);redo if!$timeout || ($pending=$timeout - (time - $initial))> 0;$nfound=0}last}$!=0;return$nfound}sub can_read {@_==1 || @_==2 || die(q/Usage: $handle->can_read([timeout])/ ."\n");my$self=shift;if (ref($self->{fh})eq 'IO::Socket::SSL'){return 1 if$self->{fh}->pending}return$self->_do_timeout('read',@_)}sub can_write {@_==1 || @_==2 || die(q/Usage: $handle->can_write([timeout])/ ."\n");my$self=shift;return$self->_do_timeout('write',@_)}sub _assert_ssl {my($ok,$reason)=HTTP::Tiny->can_ssl();die$reason unless$ok}sub can_reuse {my ($self,$scheme,$host,$port,$peer)=@_;return 0 if $self->{pid}!=$$ || $self->{tid}!=_get_tid()|| length($self->{rbuf})|| $scheme ne $self->{scheme}|| $host ne $self->{host}|| $port ne $self->{port}|| $peer ne $self->{peer}|| eval {$self->can_read(0)}|| $@ ;return 1}sub _find_CA_file {my$self=shift();my$ca_file=defined($self->{SSL_options}->{SSL_ca_file})? $self->{SSL_options}->{SSL_ca_file}: $ENV{SSL_CERT_FILE};if (defined$ca_file){unless (-r $ca_file){die qq/SSL_ca_file '$ca_file' not found or not readable\n/}return$ca_file}local@INC=@INC;pop@INC if$INC[-1]eq '.';return Mozilla::CA::SSL_ca_file()if eval {require Mozilla::CA;1};for my$ca_bundle ("/etc/ssl/certs/ca-certificates.crt","/etc/pki/tls/certs/ca-bundle.crt","/etc/ssl/ca-bundle.pem","/etc/openssl/certs/ca-certificates.crt","/etc/ssl/cert.pem","/usr/local/share/certs/ca-root-nss.crt","/etc/pki/tls/cacert.pem","/etc/certs/ca-certificates.crt",){return$ca_bundle if -e $ca_bundle}die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/ .qq/Try installing Mozilla::CA from CPAN\n/}sub _get_tid {no warnings 'reserved';return threads->can("tid")? threads->tid : 0}sub _ssl_args {my ($self,$host)=@_;my%ssl_args;if (Net::SSLeay::OPENSSL_VERSION_NUMBER()>= 0x01000000){$ssl_args{SSL_hostname}=$host,}if ($self->{verify_SSL}){$ssl_args{SSL_verifycn_scheme}='http';$ssl_args{SSL_verifycn_name}=$host;$ssl_args{SSL_verify_mode}=0x01;$ssl_args{SSL_ca_file}=$self->_find_CA_file}else {$ssl_args{SSL_verifycn_scheme}='none';$ssl_args{SSL_verify_mode}=0x00}for my$k (keys %{$self->{SSL_options}}){$ssl_args{$k}=$self->{SSL_options}{$k}if$k =~ m/^SSL_/}return \%ssl_args}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or _croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
HTTP_TINY

$fatpacked{"Linux/Distribution.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LINUX_DISTRIBUTION';
  package Linux::Distribution;use 5.006000;use strict;use warnings;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(distribution_name distribution_version);our$VERSION='0.23';our$release_files_directory='/etc';our$standard_release_file='lsb-release';our%release_files=('gentoo-release'=>'gentoo','fedora-release'=>'fedora','centos-release'=>'centos','enterprise-release'=>'oracle enterprise linux','turbolinux-release'=>'turbolinux','mandrake-release'=>'mandrake','mandrakelinux-release'=>'mandrakelinux','debian_version'=>'debian','debian_release'=>'debian','SuSE-release'=>'suse','knoppix-version'=>'knoppix','yellowdog-release'=>'yellowdog','slackware-version'=>'slackware','slackware-release'=>'slackware','redflag-release'=>'redflag','redhat-release'=>'redhat','redhat_version'=>'redhat','conectiva-release'=>'conectiva','immunix-release'=>'immunix','tinysofa-release'=>'tinysofa','trustix-release'=>'trustix','adamantix_version'=>'adamantix','yoper-release'=>'yoper','arch-release'=>'arch','libranet_version'=>'libranet','va-release'=>'va-linux','pardus-release'=>'pardus','system-release'=>'amazon','CloudLinux-release'=>'CloudLinux',);our%version_match=('gentoo'=>'Gentoo Base System release (.*)','debian'=>'(.+)','suse'=>'VERSION = (.*)','fedora'=>'Fedora(?: Core)? release (\d+) \(','redflag'=>'Red Flag (?:Desktop|Linux) (?:release |\()(.*?)(?: \(.+)?\)','redhat'=>'Red Hat(?: Enterprise)? Linux(?: Server)? release (.*) \(','oracle enterprise linux'=>'Enterprise Linux Server release (.+) \(','slackware'=>'^Slackware (.+)$','pardus'=>'^Pardus (.+)$','centos'=>'^CentOS(?: Linux)? release (.+) \(','scientific'=>'^Scientific Linux release (.+) \(','amazon'=>'Amazon Linux AMI release (.+)$','CloudLinux'=>'CloudLinux Server release (\S+)');if ($^O ne 'linux'){}sub new {my%self=('DISTRIB_ID'=>'','DISTRIB_RELEASE'=>'','DISTRIB_CODENAME'=>'','DISTRIB_DESCRIPTION'=>'','release_file'=>'','pattern'=>'');return bless \%self}sub distribution_name {my$self=shift || new();my$distro;if ($distro=$self->_get_lsb_info()){return$distro if ($distro)}for (qw(enterprise-release fedora-release CloudLinux-release)){if (-f "$release_files_directory/$_" &&!-l "$release_files_directory/$_"){if (-f "$release_files_directory/$_" &&!-l "$release_files_directory/$_"){$self->{'DISTRIB_ID'}=$release_files{$_};$self->{'release_file'}=$_;return$self->{'DISTRIB_ID'}}}}for (keys%release_files){if (-f "$release_files_directory/$_" &&!-l "$release_files_directory/$_"){if (-f "$release_files_directory/$_" &&!-l "$release_files_directory/$_"){if ($release_files{$_}eq 'redhat'){for my$rhel_deriv ('centos','scientific',){$self->{'pattern'}=$version_match{$rhel_deriv};$self->{'release_file'}='redhat-release';if ($self->_get_file_info()){$self->{'DISTRIB_ID'}=$rhel_deriv;$self->{'release_file'}=$_;return$self->{'DISTRIB_ID'}}}$self->{'pattern'}=''}$self->{'release_file'}=$_;$self->{'DISTRIB_ID'}=$release_files{$_};return$self->{'DISTRIB_ID'}}}}undef}sub distribution_version {my$self=shift || new();my$release;return$release if ($release=$self->_get_lsb_info('DISTRIB_RELEASE'));if (!$self->{'DISTRIB_ID'}){$self->distribution_name()or die 'No version because no distro.'}$self->{'pattern'}=$version_match{$self->{'DISTRIB_ID'}};$release=$self->_get_file_info();$self->{'DISTRIB_RELEASE'}=$release;return$release}sub _get_lsb_info {my$self=shift;my$field=shift || 'DISTRIB_ID';my$tmp=$self->{'release_file'};if (-r "$release_files_directory/" .$standard_release_file){$self->{'release_file'}=$standard_release_file;$self->{'pattern'}=$field .'=["]?([^"]+)["]?';my$info=$self->_get_file_info();if ($info){$self->{$field}=$info;return$info}}$self->{'release_file'}=$tmp;$self->{'pattern'}='';undef}sub _get_file_info {my$self=shift;open my$fh,'<',"$release_files_directory/" .$self->{'release_file'}or die 'Cannot open file: '.$release_files_directory.'/' .$self->{'release_file'};my$info='';local $_;while (<$fh>){chomp $_;($info)=$_ =~ m/$self->{'pattern'}/;return "\L$info" if$info}undef}1;
LINUX_DISTRIBUTION

$fatpacked{"Module/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD';
  package Module::Build;use 5.006;use strict;use warnings;use File::Spec ();use File::Path ();use File::Basename ();use Perl::OSType ();use Module::Build::Base;our@ISA=qw(Module::Build::Base);our$VERSION='0.4224';$VERSION=eval$VERSION;sub _interpose_module {my ($self,$mod)=@_;eval "use $mod";die $@ if $@;no strict 'refs';my$top_class=$mod;while (@{"${top_class}::ISA"}){last if ${"${top_class}::ISA"}[0]eq $ISA[0];$top_class=${"${top_class}::ISA"}[0]}@{"${top_class}::ISA"}=@ISA;@ISA=($mod)}if (grep {-e File::Spec->catfile($_,qw(Module Build Platform),$^O).'.pm'}@INC){__PACKAGE__->_interpose_module("Module::Build::Platform::$^O")}elsif (my$ostype=os_type()){__PACKAGE__->_interpose_module("Module::Build::Platform::$ostype")}else {warn "Unknown OS type '$^O' - using default settings\n"}sub os_type {return Perl::OSType::os_type()}sub is_vmsish {return Perl::OSType::is_os_type('VMS')}sub is_windowsish {return Perl::OSType::is_os_type('Windows')}sub is_unixish {return Perl::OSType::is_os_type('Unix')}1;
MODULE_BUILD

$fatpacked{"Module/Build/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_BASE';
  package Module::Build::Base;use 5.006;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Carp;use Cwd ();use File::Copy ();use File::Find ();use File::Path ();use File::Basename ();use File::Spec 0.82 ();use File::Compare ();use Module::Build::Dumper ();use Text::ParseWords ();use Module::Metadata;use Module::Build::Notes;use Module::Build::Config;use version;sub new {my$self=shift()->_construct(@_);$self->{invoked_action}=$self->{action}||= 'Build_PL';$self->cull_args(@ARGV);die "Too early to specify a build action '$self->{action}'.  Do 'Build $self->{action}' instead.\n" if$self->{action}&& $self->{action}ne 'Build_PL';$self->check_manifest;$self->auto_require;if(grep {!$_}$self->check_prereq,$self->check_autofeatures){$self->log_warn(<<EOF);unless ($self->dist_name eq 'Module-Build' || $ENV{PERL5_CPANPLUS_IS_RUNNING}|| $ENV{PERL5_CPAN_IS_RUNNING}){$self->log_warn("Run 'Build installdeps' to install missing prerequisites.\n\n")}}$self->{properties}{_added_to_INC}=[$self->_added_to_INC ];$self->set_bundle_inc;$self->dist_name;$self->dist_version;$self->release_status;$self->_guess_module_name unless$self->module_name;$self->_find_nested_builds;return$self}sub resume {my$package=shift;my$self=$package->_construct(@_);$self->read_config;my@added_earlier=@{$self->{properties}{_added_to_INC}|| []};@INC=($self->_added_to_INC,@added_earlier,$self->_default_INC);unless ($package->isa($self->build_class)){my$build_class=$self->build_class;my$config_dir=$self->config_dir || '_build';my$build_lib=File::Spec->catdir($config_dir,'lib');unshift(@INC,$build_lib);unless ($build_class->can('new')){eval "require $build_class; 1" or die "Failed to re-load '$build_class': $@"}return$build_class->resume(@_)}unless ($self->_perl_is_same($self->{properties}{perl})){my$perl=$self->find_perl_interpreter;die(<<"DIEFATAL")}$self->cull_args(@ARGV);unless ($self->allow_mb_mismatch){my$mb_version=$Module::Build::VERSION;if ($mb_version ne $self->{properties}{mb_version}){$self->log_warn(<<"MISMATCH")}}$self->{invoked_action}=$self->{action}||= 'build';return$self}sub new_from_context {my ($package,%args)=@_;$package->run_perl_script('Build.PL',[],[$package->unparse_args(\%args)]);return$package->resume}sub current {local@ARGV;return shift()->resume}sub _construct {my ($package,%input)=@_;my$args=delete$input{args}|| {};my$config=delete$input{config}|| {};my$self=bless {args=>{%$args},config=>Module::Build::Config->new(values=>$config),properties=>{base_dir=>$package->cwd,mb_version=>$Module::Build::VERSION,%input,},phash=>{},stash=>{},},$package;$self->_set_defaults;my ($p,$ph)=($self->{properties},$self->{phash});for (qw(notes config_data features runtime_params cleanup auto_features)){my$file=File::Spec->catfile($self->config_dir,$_);$ph->{$_}=Module::Build::Notes->new(file=>$file);$ph->{$_}->restore if -e $file;if (exists$p->{$_}){my$vals=delete$p->{$_};for my$k (sort keys %$vals){$self->$_($k,$vals->{$k})}}}$p->{perl}=$self->find_perl_interpreter or $self->log_warn("Warning: Can't locate your perl binary");my$blibdir=sub {File::Spec->catdir($p->{blib},@_)};$p->{bindoc_dirs}||= [$blibdir->("script")];$p->{libdoc_dirs}||= [$blibdir->("lib"),$blibdir->("arch")];$p->{dist_author}=[$p->{dist_author}]if defined$p->{dist_author}and not ref$p->{dist_author};$p->{requires}=delete$p->{prereq}if defined$p->{prereq};$p->{script_files}=delete$p->{scripts}if defined$p->{scripts};for ('extra_compiler_flags','extra_linker_flags'){$p->{$_}=[$self->split_like_shell($p->{$_})]if exists$p->{$_}}for ('include_dirs'){$p->{$_}=[$p->{$_}]if exists$p->{$_}&&!ref$p->{$_}}$self->add_to_cleanup(@{delete$p->{add_to_cleanup}})if$p->{add_to_cleanup};return$self}sub log_info {my$self=shift;print @_ if ref($self)&& ($self->verbose ||!$self->quiet)}sub log_verbose {my$self=shift;print @_ if ref($self)&& $self->verbose}sub log_debug {my$self=shift;print @_ if ref($self)&& $self->debug}sub log_warn {shift;if (@_ and $_[-1]!~ /\n$/){my (undef,$file,$line)=caller();warn @_," at $file line $line.\n"}else {warn @_}}sub _default_install_paths {my$self=shift;my$c=$self->{config};my$p={};my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');my$bindoc=$c->get('installman1dir')|| undef;my$libdoc=$c->get('installman3dir')|| undef;my$binhtml=$c->get('installhtml1dir')|| $c->get('installhtmldir')|| undef;my$libhtml=$c->get('installhtml3dir')|| $c->get('installhtmldir')|| undef;$p->{install_sets}={core=>{lib=>$c->get('installprivlib'),arch=>$c->get('installarchlib'),bin=>$c->get('installbin'),script=>$c->get('installscript'),bindoc=>$bindoc,libdoc=>$libdoc,binhtml=>$binhtml,libhtml=>$libhtml,},site=>{lib=>$c->get('installsitelib'),arch=>$c->get('installsitearch'),bin=>$c->get('installsitebin')|| $c->get('installbin'),script=>$c->get('installsitescript')|| $c->get('installsitebin')|| $c->get('installscript'),bindoc=>$c->get('installsiteman1dir')|| $bindoc,libdoc=>$c->get('installsiteman3dir')|| $libdoc,binhtml=>$c->get('installsitehtml1dir')|| $binhtml,libhtml=>$c->get('installsitehtml3dir')|| $libhtml,},vendor=>{lib=>$c->get('installvendorlib'),arch=>$c->get('installvendorarch'),bin=>$c->get('installvendorbin')|| $c->get('installbin'),script=>$c->get('installvendorscript')|| $c->get('installvendorbin')|| $c->get('installscript'),bindoc=>$c->get('installvendorman1dir')|| $bindoc,libdoc=>$c->get('installvendorman3dir')|| $libdoc,binhtml=>$c->get('installvendorhtml1dir')|| $binhtml,libhtml=>$c->get('installvendorhtml3dir')|| $libhtml,},};$p->{original_prefix}={core=>$c->get('installprefixexp')|| $c->get('installprefix')|| $c->get('prefixexp')|| $c->get('prefix')|| '',site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',};$p->{original_prefix}{site}||= $p->{original_prefix}{core};$p->{install_base_relpaths}={lib=>['lib','perl5'],arch=>['lib','perl5',$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],};$p->{prefix_relpaths}={core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},};return$p}sub _find_nested_builds {my$self=shift;my$r=$self->recurse_into or return;my ($file,@r);if (!ref($r)&& $r eq 'auto'){local*DH;opendir DH,$self->base_dir or die "Can't scan directory " .$self->base_dir ." for nested builds: $!";while (defined($file=readdir DH)){my$subdir=File::Spec->catdir($self->base_dir,$file);next unless -d $subdir;push@r,$subdir if -e File::Spec->catfile($subdir,'Build.PL')}}$self->recurse_into(\@r)}sub cwd {return Cwd::cwd()}sub _quote_args {my ($self,@args)=@_;my@quoted;for (@args){if (/^[^\s*?!\$<>;\\|'"\[\]\{\}]+$/){push@quoted,$_}else {s/('+)/'"$1"'/g;push@quoted,qq('$_')}}return join " ",@quoted}sub _backticks {my ($self,@cmd)=@_;if ($self->have_forkpipe){local*FH;my$pid=open*FH,"-|";if ($pid){return wantarray ? <FH> : join '',<FH>}else {die "Can't execute @cmd: $!\n" unless defined$pid;exec {$cmd[0]}@cmd}}else {my$cmd=$self->_quote_args(@cmd);return `$cmd`}}sub have_forkpipe {1}sub _perl_is_same {my ($self,$perl)=@_;my@cmd=($perl);if ($ENV{PERL_CORE}){push@cmd,'-I' .File::Spec->catdir(File::Basename::dirname($perl),'lib')}push@cmd,qw(-MConfig=myconfig -e print -e myconfig);return$self->_backticks(@cmd)eq Config->myconfig}{my$known_perl;sub find_perl_interpreter {my$self=shift;return$known_perl if defined($known_perl);return$known_perl=$self->_discover_perl_interpreter}}sub _discover_perl_interpreter {my$proto=shift;my$c=ref($proto)? $proto->{config}: 'Module::Build::Config';my$perl=$^X;my$perl_basename=File::Basename::basename($perl);my@potential_perls;push(@potential_perls,$perl)if File::Spec->file_name_is_absolute($perl);my$abs_perl=File::Spec->rel2abs($perl);push(@potential_perls,$abs_perl);if ($ENV{PERL_CORE}){require ExtUtils::CBuilder;my$perl_src=Cwd::realpath(ExtUtils::CBuilder->perl_src);if (defined($perl_src)&& length($perl_src)){my$uninstperl=File::Spec->rel2abs(File::Spec->catfile($perl_src,$perl_basename));push(@potential_perls,$uninstperl)}}else {push(@potential_perls,$c->get('perlpath'));push(@potential_perls,map File::Spec->catfile($_,$perl_basename),File::Spec->path())}my$exe=$c->get('exe_ext');for my$thisperl (@potential_perls){if (defined$exe){$thisperl .= $exe unless$thisperl =~ m/$exe$/i}if (-f $thisperl && $proto->_perl_is_same($thisperl)){return$thisperl}}my@paths=map File::Basename::dirname($_),@potential_perls;die "Can't locate the perl binary used to run this script " ."in (@paths)\n"}sub find_command {my ($self,$command)=@_;if(File::Spec->file_name_is_absolute($command)){return$self->_maybe_command($command)}else {for my$dir (File::Spec->path){my$abs=File::Spec->catfile($dir,$command);return$abs if$abs=$self->_maybe_command($abs)}}}sub _maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d $file;return}sub _is_interactive {return -t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT))}sub _is_unattended {my$self=shift;return$ENV{PERL_MM_USE_DEFAULT}|| (!$self->_is_interactive && eof STDIN)}sub _readline {my$self=shift;return undef if$self->_is_unattended;my$answer=<STDIN>;chomp$answer if defined$answer;return$answer}sub prompt {my$self=shift;my$mess=shift or die "prompt() called without a prompt message";my@def;@def=(shift)if @_;my@dispdef=scalar(@def)? ('[',(defined($def[0])? $def[0].' ' : ''),']'): (' ','');local $|=1;print "$mess ",@dispdef;if ($self->_is_unattended &&!@def){die <<EOF}my$ans=$self->_readline();if (!defined($ans)or!length($ans)){print "$dispdef[1]\n";$ans=scalar(@def)? $def[0]: ''}return$ans}sub y_n {my$self=shift;my ($mess,$def)=@_;die "y_n() called without a prompt message" unless$mess;die "Invalid default value: y_n() default must be 'y' or 'n'" if$def && $def !~ /^[yn]/i;my$answer;while (1){$answer=$self->prompt(@_);return 1 if$answer =~ /^y/i;return 0 if$answer =~ /^n/i;local $|=1;print "Please answer 'y' or 'n'.\n"}}sub current_action {shift->{action}}sub invoked_action {shift->{invoked_action}}sub notes {shift()->{phash}{notes}->access(@_)}sub config_data {shift()->{phash}{config_data}->access(@_)}sub runtime_params {shift->{phash}{runtime_params}->read(@_ ? shift : ())}sub auto_features {shift()->{phash}{auto_features}->access(@_)}sub features {my$self=shift;my$ph=$self->{phash};if (@_){my$key=shift;if ($ph->{features}->exists($key)){return$ph->{features}->access($key,@_)}if (my$info=$ph->{auto_features}->access($key)){my$disabled;for my$type (@{$self->prereq_action_types}){next if$type eq 'description' || $type eq 'recommends' ||!exists$info->{$type};my$prereqs=$info->{$type};for my$modname (sort keys %$prereqs){my$spec=$prereqs->{$modname};my$status=$self->check_installed_status($modname,$spec);if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}return$ph->{features}->access($key,@_)}my%features;my%auto_features=$ph->{auto_features}->access();while (my ($name,$info)=each%auto_features){my$failures=$self->prereq_failures($info);my$disabled=grep(/^(?:\w+_)?(?:requires|conflicts)$/,keys %$failures)? 1 : 0;$features{$name}=$disabled ? 0 : 1}%features=(%features,$ph->{features}->access());return wantarray ? %features : \%features}BEGIN {*feature=\&features}sub _mb_feature {my$self=shift;if (($self->module_name || '')eq 'Module::Build'){return$self->feature(@_)}else {require Module::Build::ConfigData;return Module::Build::ConfigData->feature(@_)}}sub _warn_mb_feature_deps {my$self=shift;my$name=shift;$self->log_warn("The '$name' feature is not available.  Please install missing\n" ."feature dependencies and try again.\n".$self->_feature_deps_msg($name)."\n")}sub add_build_element {my ($self,$elem)=@_;my$elems=$self->build_elements;push @$elems,$elem unless grep {$_ eq $elem}@$elems}sub ACTION_config_data {my$self=shift;return unless$self->has_config_data;my$module_name=$self->module_name or die "The config_data feature requires that 'module_name' be set";my$notes_name=$module_name .'::ConfigData';my$notes_pm=File::Spec->catfile($self->blib,'lib',split /::/,"$notes_name.pm");return if$self->up_to_date(['Build.PL',$self->config_file('config_data'),$self->config_file('features')],$notes_pm);$self->log_verbose("Writing config notes to $notes_pm\n");File::Path::mkpath(File::Basename::dirname($notes_pm));Module::Build::Notes->write_config_data (file=>$notes_pm,module=>$module_name,config_module=>$notes_name,config_data=>scalar$self->config_data,feature=>scalar$self->{phash}{features}->access(),auto_features=>scalar$self->auto_features,)}{my%valid_properties=(__PACKAGE__,{});my%additive_properties;sub _mb_classes {my$class=ref($_[0])|| $_[0];return ($class,$class->mb_parents)}sub valid_property {my ($class,$prop)=@_;return grep exists($valid_properties{$_}{$prop}),$class->_mb_classes}sub valid_properties {return keys %{shift->valid_properties_defaults()}}sub valid_properties_defaults {my%out;for my$class (reverse shift->_mb_classes){@out{keys %{$valid_properties{$class}}}=map {$_->()}values %{$valid_properties{$class}}}return \%out}sub array_properties {map {exists$additive_properties{$_}->{ARRAY}? @{$additive_properties{$_}->{ARRAY}}: ()}shift->_mb_classes}sub hash_properties {map {exists$additive_properties{$_}->{HASH}? @{$additive_properties{$_}->{HASH}}: ()}shift->_mb_classes}sub add_property {my ($class,$property)=(shift,shift);die "Property '$property' already exists" if$class->valid_property($property);my%p=@_==1 ? (default=>shift): @_;my$type=ref$p{default};$valid_properties{$class}{$property}=$type eq 'CODE' ? $p{default}: $type eq 'HASH' ? sub {return {%{$p{default}}}}: $type eq 'ARRAY'? sub {return [@{$p{default}}]}: sub {return$p{default}};push @{$additive_properties{$class}->{$type}},$property if$type;unless ($class->can($property)){my$sub=$type eq 'HASH' ? _make_hash_accessor($property,\%p): _make_accessor($property,\%p);no strict 'refs';*{"$class\::$property"}=$sub}return$class}sub property_error {my$self=shift;die 'ERROR: ',@_}sub _set_defaults {my$self=shift;$self->{properties}{build_class}||= ref$self;$self->{properties}{orig_dir}||= $self->{properties}{base_dir};my$defaults=$self->valid_properties_defaults;for my$prop (keys %$defaults){$self->{properties}{$prop}=$defaults->{$prop}unless exists$self->{properties}{$prop}}for my$prop ($self->array_properties){$self->{properties}{$prop}=[@{$defaults->{$prop}}]unless exists$self->{properties}{$prop}}for my$prop ($self->hash_properties){$self->{properties}{$prop}={%{$defaults->{$prop}}}unless exists$self->{properties}{$prop}}}}sub _make_hash_accessor {my ($property,$p)=@_;my$check=$p->{check}|| sub {1};return sub {my$self=shift;unless(ref($self)){carp("\n$property not a class method (@_)");return}my$x=$self->{properties};return$x->{$property}unless @_;my$prop=$x->{$property};if (defined $_[0]&&!ref $_[0]){if (@_==1){return exists$prop->{$_[0]}? $prop->{$_[0]}: undef}elsif (@_ % 2==0){my%new=(%{$prop},@_);local $_=\%new;$x->{$property}=\%new if$check->($self);return$x->{$property}}else {die "Unexpected arguments for property '$property'\n"}}else {die "Unexpected arguments for property '$property'\n" if defined $_[0]&& ref $_[0]ne 'HASH';local $_=$_[0];$x->{$property}=shift if$check->($self)}}}sub _make_accessor {my ($property,$p)=@_;my$check=$p->{check}|| sub {1};return sub {my$self=shift;unless(ref($self)){carp("\n$property not a class method (@_)");return}my$x=$self->{properties};return$x->{$property}unless @_;local $_=$_[0];$x->{$property}=shift if$check->($self);return$x->{$property}}}__PACKAGE__->add_property(auto_configure_requires=>1);__PACKAGE__->add_property(blib=>'blib');__PACKAGE__->add_property(build_class=>'Module::Build');__PACKAGE__->add_property(build_elements=>[qw(PL support pm xs share_dir pod script)]);__PACKAGE__->add_property(build_script=>'Build');__PACKAGE__->add_property(build_bat=>0);__PACKAGE__->add_property(bundle_inc=>[]);__PACKAGE__->add_property(bundle_inc_preload=>[]);__PACKAGE__->add_property(config_dir=>'_build');__PACKAGE__->add_property(dynamic_config=>1);__PACKAGE__->add_property(include_dirs=>[]);__PACKAGE__->add_property(license=>'unknown');__PACKAGE__->add_property(metafile=>'META.yml');__PACKAGE__->add_property(mymetafile=>'MYMETA.yml');__PACKAGE__->add_property(metafile2=>'META.json');__PACKAGE__->add_property(mymetafile2=>'MYMETA.json');__PACKAGE__->add_property(recurse_into=>[]);__PACKAGE__->add_property(use_rcfile=>1);__PACKAGE__->add_property(create_packlist=>1);__PACKAGE__->add_property(allow_mb_mismatch=>0);__PACKAGE__->add_property(config=>undef);__PACKAGE__->add_property(test_file_exts=>['.t']);__PACKAGE__->add_property(use_tap_harness=>0);__PACKAGE__->add_property(cpan_client=>'cpan');__PACKAGE__->add_property(tap_harness_args=>{});__PACKAGE__->add_property(pureperl_only=>0);__PACKAGE__->add_property(allow_pureperl=>0);__PACKAGE__->add_property('installdirs',default=>'site',check=>sub {return 1 if /^(core|site|vendor)$/;return shift->property_error($_ eq 'perl' ? 'Perhaps you meant installdirs to be "core" rather than "perl"?' : 'installdirs must be one of "core", "site", or "vendor"');return shift->property_error("Perhaps you meant 'core'?")if $_ eq 'perl';return 0},);{__PACKAGE__->add_property(html_css=>'')}{my@prereq_action_types=qw(requires build_requires test_requires conflicts recommends);for my$type (@prereq_action_types){__PACKAGE__->add_property($type=>{})}__PACKAGE__->add_property(prereq_action_types=>\@prereq_action_types)}__PACKAGE__->add_property($_=>{})for qw(get_options install_base_relpaths install_path install_sets meta_add meta_merge original_prefix prefix_relpaths configure_requires);__PACKAGE__->add_property($_)for qw(PL_files autosplit base_dir bindoc_dirs c_source cover create_license create_makefile_pl create_readme debugger destdir dist_abstract dist_author dist_name dist_suffix dist_version dist_version_from extra_compiler_flags extra_linker_flags has_config_data install_base libdoc_dirs magic_number mb_version module_name needs_compiler orig_dir perl pm_files pod_files pollute prefix program_name quiet recursive_test_files release_status script_files scripts share_dir sign test_files verbose debug xs_files extra_manify_args);sub config {my$self=shift;my$c=ref($self)? $self->{config}: 'Module::Build::Config';return$c->all_config unless @_;my$key=shift;return$c->get($key)unless @_;my$val=shift;return$c->set($key=>$val)}sub mb_parents {my@in_stack=(shift);my%seen=($in_stack[0]=>1);my ($current,@out);while (@in_stack){next unless defined($current=shift@in_stack)&& $current->isa('Module::Build::Base');push@out,$current;next if$current eq 'Module::Build::Base';no strict 'refs';unshift@in_stack,map {my$c=$_;substr($c,0,2)="main::" if substr($c,0,2)eq '::';$seen{$c}++ ? (): $c}@{"$current\::ISA"}}shift@out;return@out}sub extra_linker_flags {shift->_list_accessor('extra_linker_flags',@_)}sub extra_compiler_flags {shift->_list_accessor('extra_compiler_flags',@_)}sub _list_accessor {(my$self,local $_)=(shift,shift);my$p=$self->{properties};$p->{$_}=[@_]if @_;$p->{$_}=[]unless exists$p->{$_};return ref($p->{$_})? $p->{$_}: [$p->{$_}]}sub subclass {my ($pack,%opts)=@_;my$build_dir='_build';$pack->delete_filetree($build_dir)if -e $build_dir;die "Must provide 'code' or 'class' option to subclass()\n" unless$opts{code}or $opts{class};$opts{code}||= '';$opts{class}||= 'MyModuleBuilder';my$filename=File::Spec->catfile($build_dir,'lib',split '::',$opts{class}).'.pm';my$filedir=File::Basename::dirname($filename);$pack->log_verbose("Creating custom builder $filename in $filedir\n");File::Path::mkpath($filedir);die "Can't create directory $filedir: $!" unless -d $filedir;open(my$fh,'>',$filename)or die "Can't create $filename: $!";print$fh <<EOF;close$fh;unshift@INC,File::Spec->catdir(File::Spec->rel2abs($build_dir),'lib');eval "use $opts{class}";die $@ if $@;return$opts{class}}sub _guess_module_name {my$self=shift;my$p=$self->{properties};return if$p->{module_name};if ($p->{dist_version_from}&& -e $p->{dist_version_from}){my$mi=Module::Metadata->new_from_file($self->dist_version_from);$p->{module_name}=$mi->name}else {my$mod_path=my$mod_name=$p->{dist_name};$mod_name =~ s{-}{::}g;$mod_path =~ s{-}{/}g;$mod_path .= ".pm";if (-e $mod_path || -e "lib/$mod_path"){$p->{module_name}=$mod_name}else {$self->log_warn(<< 'END_WARN')}}}sub dist_name {my$self=shift;my$p=$self->{properties};my$me='dist_name';return$p->{$me}if defined$p->{$me};die "Can't determine distribution name, must supply either 'dist_name' or 'module_name' parameter" unless$self->module_name;($p->{$me}=$self->module_name)=~ s/::/-/g;return$p->{$me}}sub release_status {my ($self)=@_;my$me='release_status';my$p=$self->{properties};if (!defined$p->{$me}){$p->{$me}=$self->_is_dev_version ? 'testing' : 'stable'}unless ($p->{$me}=~ qr/\A(?:stable|testing|unstable)\z/){die "Illegal value '$p->{$me}' for $me\n"}if ($p->{$me}eq 'stable' && $self->_is_dev_version){my$version=$self->dist_version;die "Illegal value '$p->{$me}' with version '$version'\n"}return$p->{$me}}sub dist_suffix {my ($self)=@_;my$p=$self->{properties};my$me='dist_suffix';return$p->{$me}if defined$p->{$me};if ($self->release_status eq 'stable'){$p->{$me}=""}else {$p->{$me}=$self->_is_dev_version ? "" : "TRIAL" }return$p->{$me}}sub dist_version_from {my ($self)=@_;my$p=$self->{properties};my$me='dist_version_from';if ($self->module_name){$p->{$me}||= join('/','lib',split(/::/,$self->module_name)).'.pm'}return$p->{$me}|| undef}sub dist_version {my ($self)=@_;my$p=$self->{properties};my$me='dist_version';return$p->{$me}if defined$p->{$me};if (my$dist_version_from=$self->dist_version_from){my$version_from=File::Spec->catfile(split(qr{/},$dist_version_from));my$pm_info=Module::Metadata->new_from_file($version_from)or die "Can't find file $version_from to determine version";$p->{$me}=$self->normalize_version($pm_info->version());unless (defined$p->{$me}){die "Can't determine distribution version from $version_from"}}die ("Can't determine distribution version, must supply either 'dist_version',\n"."'dist_version_from', or 'module_name' parameter")unless defined$p->{$me};return$p->{$me}}sub _is_dev_version {my ($self)=@_;my$dist_version=$self->dist_version;my$version_obj=eval {version->new($dist_version)};return $@ ? 0 : $version_obj->is_alpha}sub dist_author {shift->_pod_parse('author')}sub dist_abstract {shift->_pod_parse('abstract')}sub _pod_parse {my ($self,$part)=@_;my$p=$self->{properties};my$member="dist_$part";return$p->{$member}if defined$p->{$member};my$docfile=$self->_main_docfile or return;open(my$fh,'<',$docfile)or return;require Module::Build::PodParser;my$parser=Module::Build::PodParser->new(fh=>$fh);my$method="get_$part";return$p->{$member}=$parser->$method()}sub version_from_file {return Module::Metadata->new_from_file($_[1])->version()}sub find_module_by_name {return Module::Metadata->find_module_by_name(@_[1,2])}{my%unlink_list_for_pid;sub _unlink_on_exit {my$self=shift;for my$f (@_){push @{$unlink_list_for_pid{$$}},$f if -f $f}return 1}END {for my$f (map glob($_),@{$unlink_list_for_pid{$$}|| []}){next unless -e $f;File::Path::rmtree($f,0,0)}}}sub add_to_cleanup {my$self=shift;my%files=map {$self->localize_file_path($_),1}@_;$self->{phash}{cleanup}->write(\%files)}sub cleanup {my$self=shift;my$all=$self->{phash}{cleanup}->read;return wantarray ? sort keys %$all : keys %$all}sub config_file {my$self=shift;return unless -d $self->config_dir;return File::Spec->catfile($self->config_dir,@_)}sub read_config {my ($self)=@_;my$file=$self->config_file('build_params')or die "Can't find 'build_params' in " .$self->config_dir;open(my$fh,'<',$file)or die "Can't read '$file': $!";my$ref=eval do {local $/;<$fh>};die if $@;close$fh;my$c;($self->{args},$c,$self->{properties})=@$ref;$self->{config}=Module::Build::Config->new(values=>$c)}sub has_config_data {my$self=shift;return scalar grep$self->{phash}{$_}->has_data(),qw(config_data features auto_features)}sub _write_data {my ($self,$filename,$data)=@_;my$file=$self->config_file($filename);open(my$fh,'>',$file)or die "Can't create '$file': $!";unless (ref($data)){print$fh $data;return}print {$fh}Module::Build::Dumper->_data_dump($data);close$fh}sub write_config {my ($self)=@_;File::Path::mkpath($self->{properties}{config_dir});-d $self->{properties}{config_dir}or die "Can't mkdir $self->{properties}{config_dir}: $!";my@items=@{$self->prereq_action_types};$self->_write_data('prereqs',{map {$_,$self->$_()}@items });$self->_write_data('build_params',[$self->{args},$self->{config}->values_set,$self->{properties}]);$self->_write_data('magicnum',$self->magic_number(int rand 1_000_000));$self->{phash}{$_}->write()foreach qw(notes cleanup features auto_features config_data runtime_params)}{my%packlist_map=('^File::Spec'=>'Cwd','^Devel::AssertOS'=>'Devel::CheckOS',);sub _find_packlist {my ($self,$inst,$mod)=@_;my$lookup=$mod;my$packlist=eval {$inst->packlist($lookup)};if (!$packlist){while (my ($re,$new_mod)=each%packlist_map){if ($mod =~ qr/$re/){$lookup=$new_mod;$packlist=eval {$inst->packlist($lookup)};last}}}return$packlist ? $lookup : undef}sub set_bundle_inc {my$self=shift;my$bundle_inc=$self->{properties}{bundle_inc};my$bundle_inc_preload=$self->{properties}{bundle_inc_preload};return unless inc::latest->can('loaded_modules');require ExtUtils::Installed;my$inst=eval {ExtUtils::Installed->new(extra_libs=>[@INC])};if ($@){$self->log_warn(<< "EUI_ERROR");return}my@bundle_list=map {[$_,0 ]}inc::latest->loaded_modules;while(@bundle_list){my ($mod,$prereq)=@{shift@bundle_list};my$lookup=$self->_find_packlist($inst,$mod);if (!$lookup){die << "NO_PACKLIST"}else {push @{$prereq ? $bundle_inc_preload : $bundle_inc},$lookup}}}}sub check_autofeatures {my ($self)=@_;my$features=$self->auto_features;return 1 unless %$features;my$longest=sub {my@str=@_ or croak("no strings given");my@len=map({length($_)}@str);my$max=0;my$longest;for my$i (0..$#len){($max,$longest)=($len[$i],$str[$i])if($len[$i]> $max)}return($longest)};my$max_name_len=length($longest->(keys %$features));my ($num_disabled,$log_text)=(0,"\nChecking optional features...\n");for my$name (sort keys %$features){$log_text .= $self->_feature_deps_msg($name,$max_name_len)}$num_disabled=()=$log_text =~ /disabled/g;if ($num_disabled){$self->log_warn($log_text);return 0}else {$self->log_verbose($log_text);return 1}}sub _feature_deps_msg {my ($self,$name,$max_name_len)=@_;$max_name_len ||= length$name;my$features=$self->auto_features;my$info=$features->{$name};my$feature_text="$name" .'.' x ($max_name_len - length($name)+ 4);my ($log_text,$disabled)=('','');if (my$failures=$self->prereq_failures($info)){$disabled=grep(/^(?:\w+_)?(?:requires|conflicts)$/,keys %$failures)? 1 : 0;$feature_text .= $disabled ? "disabled\n" : "enabled\n";for my$type (@{$self->prereq_action_types}){next unless exists$failures->{$type};$feature_text .= "  $type:\n";my$prereqs=$failures->{$type};for my$module (sort keys %$prereqs){my$status=$prereqs->{$module};my$required=($type =~ /^(?:\w+_)?(?:requires|conflicts)$/)? 1 : 0;my$prefix=($required)? '!' : '*';$feature_text .= "    $prefix $status->{message}\n"}}}else {$feature_text .= "enabled\n"}$log_text .= $feature_text if$disabled || $self->verbose;return$log_text}sub auto_config_requires {my ($self)=@_;my$p=$self->{properties};if ($self->dist_name ne 'Module-Build' && $self->auto_configure_requires &&!exists$p->{configure_requires}{'Module::Build'}){(my$ver=$VERSION)=~ s/^(\d+\.\d\d).*$/$1/;$self->log_warn(<<EOM);$self->_add_prereq('configure_requires','Module::Build',$ver)}if (inc::latest->can('loaded_module')){for my$mod (inc::latest->loaded_modules){next if exists$p->{configure_requires}{$mod};$self->_add_prereq('configure_requires',$mod,$mod->VERSION)}}return}sub auto_require {my ($self)=@_;my$p=$self->{properties};my$xs_files=$self->find_xs_files;if (!defined$p->{needs_compiler}){$self->needs_compiler(keys %$xs_files || defined$self->c_source)}if ($self->needs_compiler){$self->_add_prereq('build_requires','ExtUtils::CBuilder',0);if (!$self->have_c_compiler){$self->log_warn(<<'EOM')}}if ($self->share_dir){$self->_add_prereq('requires','File::ShareDir','1.00')}return}sub _add_prereq {my ($self,$type,$module,$version)=@_;my$p=$self->{properties};$version=0 unless defined$version;if (exists$p->{$type}{$module}){return if$self->compare_versions($version,'<=',$p->{$type}{$module})}$self->log_verbose("Adding to $type\: $module => $version\n");$p->{$type}{$module}=$version;return 1}sub prereq_failures {my ($self,$info)=@_;my@types=@{$self->prereq_action_types};$info ||= {map {$_,$self->$_()}@types};my$out;for my$type (@types){my$prereqs=$info->{$type};for my$modname (keys %$prereqs){my$spec=$prereqs->{$modname};my$status=$self->check_installed_status($modname,$spec);if ($type =~ /^(?:\w+_)?conflicts$/){next if!$status->{ok};$status->{conflicts}=delete$status->{need};$status->{message}="$modname ($status->{have}) conflicts with this distribution"}elsif ($type =~ /^(?:\w+_)?recommends$/){next if$status->{ok};$status->{message}=(!ref($status->{have})&& $status->{have}eq '<none>' ? "$modname is not installed" : "$modname ($status->{have}) is installed, but we prefer to have $spec")}else {next if$status->{ok}}$out->{$type}{$modname}=$status}}return$out}sub _enum_prereqs {my$self=shift;my%prereqs;for my$type (@{$self->prereq_action_types}){if ($self->can($type)){my$prereq=$self->$type()|| {};$prereqs{$type}=$prereq if %$prereq}}return \%prereqs}sub check_prereq {my$self=shift;my$info=$self->_enum_prereqs;return 1 unless$info;my$log_text="Checking prerequisites...\n";my$failures=$self->prereq_failures($info);if ($failures){$self->log_warn($log_text);for my$type (@{$self->prereq_action_types}){my$prereqs=$failures->{$type};$self->log_warn("  ${type}:\n")if keys %$prereqs;for my$module (sort keys %$prereqs){my$status=$prereqs->{$module};my$prefix=($type =~ /^(?:\w+_)?recommends$/)? "* " : "! ";$self->log_warn("    $prefix $status->{message}\n")}}return 0}else {$self->log_verbose($log_text ."Looks good\n\n");return 1}}sub perl_version {my ($self)=@_;return $^V ? $self->perl_version_to_float(sprintf "%vd",$^V): $]}sub perl_version_to_float {my ($self,$version)=@_;return$version if grep(/\./,$version)< 2;$version =~ s/\./../;$version =~ s/\.(\d+)/sprintf '%03d', $1/eg;return$version}sub _parse_conditions {my ($self,$spec)=@_;return ">= 0" if not defined$spec;if ($spec =~ /^\s*([\w.]+)\s*$/){return (">= $spec")}else {return split /\s*,\s*/,$spec}}sub try_require {my ($self,$modname,$spec)=@_;my$status=$self->check_installed_status($modname,defined($spec)? $spec : 0);return unless$status->{ok};my$path=$modname;$path =~ s{::}{/}g;$path .= ".pm";if (defined$INC{$path}){return 1}elsif (exists$INC{$path}){return}else {return eval "require $modname"}}sub check_installed_status {my ($self,$modname,$spec)=@_;my%status=(need=>$spec);if ($modname eq 'perl'){$status{have}=$self->perl_version}elsif (eval {no strict;$status{have}=${"${modname}::VERSION"}}){}else {my$pm_info=Module::Metadata->new_from_module($modname);unless (defined($pm_info)){@status{qw(have message) }=('<none>',"$modname is not installed");return \%status}$status{have}=eval {$pm_info->version()};if ($spec and!defined($status{have})){@status{qw(have message) }=(undef,"Couldn't find a \$VERSION in prerequisite $modname");return \%status}}my@conditions=$self->_parse_conditions($spec);for (@conditions){my ($op,$version)=/^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x or die "Invalid prerequisite condition '$_' for $modname";$version=$self->perl_version_to_float($version)if$modname eq 'perl';next if$op eq '>=' and!$version;unless ($self->compare_versions($status{have},$op,$version)){$status{message}="$modname ($status{have}) is installed, but we need version $op $version";return \%status}}$status{ok}=1;return \%status}sub compare_versions {my$self=shift;my ($v1,$op,$v2)=@_;$v1=version->new($v1)unless eval {$v1->isa('version')};my$eval_str="\$v1 $op \$v2";my$result=eval$eval_str;$self->log_warn("error comparing versions: '$eval_str' $@")if $@;return$result}sub check_installed_version {my ($self,$modname,$spec)=@_;my$status=$self->check_installed_status($modname,$spec);if ($status->{ok}){return$status->{have}if$status->{have}and "$status->{have}" ne '<none>';return '0 but true'}$@=$status->{message};return 0}sub make_executable {my$self=shift;for (@_){my$current_mode=(stat $_)[2];chmod$current_mode | oct(111),$_}}sub is_executable {my ($self,$file)=@_;return -x $file}sub _startperl {shift()->config('startperl')}sub _added_to_INC {my$self=shift;my%seen;$seen{$_}++ foreach$self->_default_INC;return grep!$seen{$_}++,@INC}{my@default_inc;sub _default_INC {my$self=shift;return@default_inc if@default_inc;local$ENV{PERL5LIB};my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;my@inc=$self->_backticks($perl,'-le','print for @INC');chomp@inc;return@default_inc=@inc}}sub print_build_script {my ($self,$fh)=@_;my$build_package=$self->build_class;my$closedata="";my$config_requires;if (-f $self->metafile){my$meta=eval {$self->read_metafile($self->metafile)};$config_requires=$meta && $meta->{prereqs}{configure}{requires}{'Module::Build'}}$config_requires ||= 0;my%q=map {$_,$self->$_()}qw(config_dir base_dir);$q{base_dir}=Win32::GetShortPathName($q{base_dir})if$self->is_windowsish;$q{magic_numfile}=$self->config_file('magicnum');my@myINC=$self->_added_to_INC;for (@myINC,values%q){$_=File::Spec->canonpath($_)unless$self->is_vmsish;s/([\\\'])/\\$1/g}my$quoted_INC=join ",\n",map "     '$_'",@myINC;my$shebang=$self->_startperl;my$magic_number=$self->magic_number;my$dot_in_inc_code=$INC[-1]eq '.' ? <<'END' : '';print$fh <<EOF}sub create_mymeta {my ($self)=@_;my ($meta_obj,$mymeta);my@metafiles=($self->metafile2,$self->metafile,);my@mymetafiles=($self->mymetafile2,$self->mymetafile,);for my$f (@mymetafiles){if ($self->delete_filetree($f)){$self->log_verbose("Removed previous '$f'\n")}}if ($self->try_require("CPAN::Meta","2.142060")){for my$file (@metafiles){next unless -f $file;$meta_obj=eval {CPAN::Meta->load_file($file,{lazy_validation=>0 })};last if$meta_obj}}my$mymeta_obj;if ($meta_obj){my%updated=(%{$meta_obj->as_struct({version=>2.0 })},prereqs=>$self->_normalize_prereqs,dynamic_config=>0,generated_by=>"Module::Build version $Module::Build::VERSION",);$mymeta_obj=CPAN::Meta->new(\%updated,{lazy_validation=>0 })}else {$mymeta_obj=$self->_get_meta_object(quiet=>0,dynamic=>0,fatal=>1,auto=>0)}my@created=$self->_write_meta_files($mymeta_obj,'MYMETA');$self->log_warn("Could not create MYMETA files\n")unless@created;return 1}sub create_build_script {my ($self)=@_;$self->write_config;$self->create_mymeta;my ($build_script,$dist_name,$dist_version)=map$self->$_(),qw(build_script dist_name dist_version);if ($self->delete_filetree($build_script)){$self->log_verbose("Removed previous script '$build_script'\n")}$self->log_info("Creating new '$build_script' script for ","'$dist_name' version '$dist_version'\n");open(my$fh,'>',$build_script)or die "Can't create '$build_script': $!";$self->print_build_script($fh);close$fh;$self->make_executable($build_script);return 1}sub check_manifest {my$self=shift;return unless -e 'MANIFEST';require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);$self->log_verbose("Checking whether your kit is complete...\n");if (my@missed=ExtUtils::Manifest::manicheck()){$self->log_warn("WARNING: the following files are missing in your kit:\n","\t",join("\n\t",@missed),"\n","Please inform the author.\n\n")}else {$self->log_verbose("Looks good\n\n")}}sub dispatch {my$self=shift;local$self->{_completed_actions}={};if (@_){my ($action,%p)=@_;my$args=$p{args}? delete($p{args}): {};local$self->{invoked_action}=$action;local$self->{args}={%{$self->{args}},%$args};local$self->{properties}={%{$self->{properties}},%p};return$self->_call_action($action)}die "No build action specified" unless$self->{action};local$self->{invoked_action}=$self->{action};$self->_call_action($self->{action})}sub _call_action {my ($self,$action)=@_;return if$self->{_completed_actions}{$action}++;local$self->{action}=$action;my$method=$self->can_action($action);die "No action '$action' defined, try running the 'help' action.\n" unless$method;$self->log_debug("Starting ACTION_$action\n");my$rc=$self->$method();$self->log_debug("Finished ACTION_$action\n");return$rc}sub can_action {my ($self,$action)=@_;return$self->can("ACTION_$action")}sub cull_options {my$self=shift;my (@argv)=@_;return({},@argv)unless(ref($self));my$specs=$self->get_options;return({},@argv)unless($specs and %$specs);require Getopt::Long;my@specs;my$args={};for my$k (sort keys %$specs){my$v=$specs->{$k};die "Option specification '$k' conflicts with a " .ref$self ." option of the same name" if$self->valid_property($k);push@specs,$k .(defined$v->{type}? $v->{type}: '');push@specs,$v->{store}if exists$v->{store};$args->{$k}=$v->{default}if exists$v->{default}}local@ARGV=@argv;if (@specs){Getopt::Long::Configure('pass_through');Getopt::Long::GetOptions($args,@specs)}return$args,@ARGV}sub unparse_args {my ($self,$args)=@_;my@out;for my$k (sort keys %$args){my$v=$args->{$k};push@out,(ref$v eq 'HASH' ? map {+"--$k","$_=$v->{$_}"}sort keys %$v : ref$v eq 'ARRAY' ? map {+"--$k",$_}@$v : ("--$k",$v))}return@out}sub args {my$self=shift;return wantarray ? %{$self->{args}}: $self->{args}unless @_;my$key=shift;$self->{args}{$key}=shift if @_;return$self->{args}{$key}}sub _translate_option {my$self=shift;my$opt=shift;(my$tr_opt=$opt)=~ tr/-/_/;return$tr_opt if grep$tr_opt =~ /^(?:no_?)?$_$/,qw(create_license create_makefile_pl create_readme extra_compiler_flags extra_linker_flags install_base install_path meta_add meta_merge test_files use_rcfile use_tap_harness tap_harness_args cpan_client pureperl_only allow_pureperl);return$opt}my%singular_argument=map {($_=>1)}qw/install_base prefix destdir installdirs verbose quiet uninst debug sign/;sub _read_arg {my ($self,$args,$key,$val)=@_;$key=$self->_translate_option($key);if (exists$args->{$key}and not $singular_argument{$key}){$args->{$key}=[$args->{$key}]unless ref$args->{$key};push @{$args->{$key}},$val}else {$args->{$key}=$val}}sub _optional_arg {my$self=shift;my$opt=shift;my$argv=shift;$opt=$self->_translate_option($opt);my@bool_opts=qw(build_bat create_license create_readme pollute quiet uninst use_rcfile verbose debug sign use_tap_harness pureperl_only allow_pureperl);if (grep$opt =~ /^no[-_]?$_$/,@bool_opts){$opt =~ s/^no-?//;return ($opt,0)}return ($opt,shift(@$argv))unless grep $_ eq $opt,@bool_opts;my$arg=1;$arg=shift(@$argv)if @$argv && $argv->[0]=~ /^\d+$/;return ($opt,$arg)}sub read_args {my$self=shift;(my$args,@_)=$self->cull_options(@_);my%args=%$args;my$opt_re=qr/[\w\-]+/;my ($action,@argv);while (@_){local $_=shift;if (/^(?:--)?($opt_re)=(.*)$/){$self->_read_arg(\%args,$1,$2)}elsif (/^--($opt_re)$/){my($opt,$arg)=$self->_optional_arg($1,\@_);$self->_read_arg(\%args,$opt,$arg)}elsif (/^($opt_re)$/ and!defined($action)){$action=$1}else {push@argv,$_}}$args{ARGV}=\@argv;for ('extra_compiler_flags','extra_linker_flags'){$args{$_}=[$self->split_like_shell($args{$_})]if exists$args{$_}}for ('include_dirs'){$args{$_}=[$args{$_}]if exists$args{$_}&&!ref$args{$_}}for ($self->hash_properties,'config'){next unless exists$args{$_};my%hash;$args{$_}||= [];$args{$_}=[$args{$_}]unless ref$args{$_};for my$arg (@{$args{$_}}){$arg =~ /($opt_re)=(.*)/ or die "Malformed '$_' argument: '$arg' should be something like 'foo=bar'";$hash{$1}=$2}$args{$_}=\%hash}for my$key (qw(prefix install_base destdir)){next if!defined$args{$key};$args{$key}=$self->_detildefy($args{$key})}for my$key (qw(install_path)){next if!defined$args{$key};for my$subkey (keys %{$args{$key}}){next if!defined$args{$key}{$subkey};my$subkey_ext=$self->_detildefy($args{$key}{$subkey});if ($subkey eq 'html'){$args{$key}{binhtml}=$subkey_ext;$args{$key}{libhtml}=$subkey_ext}else {$args{$key}{$subkey}=$subkey_ext}}}if ($args{makefile_env_macros}){require Module::Build::Compat;%args=(%args,Module::Build::Compat->makefile_to_build_macros)}return \%args,$action}sub _detildefy {}sub _merge_arglist {my($self,$opts1,$opts2)=@_;$opts1 ||= {};$opts2 ||= {};my%new_opts=%$opts1;while (my ($key,$val)=each %$opts2){if (exists($opts1->{$key})){if (ref($val)eq 'HASH'){while (my ($k,$v)=each %$val){$new_opts{$key}{$k}=$v unless exists($opts1->{$key}{$k})}}}else {$new_opts{$key}=$val}}return%new_opts}sub _home_dir {my@home_dirs;push(@home_dirs,$ENV{HOME})if$ENV{HOME};push(@home_dirs,File::Spec->catpath($ENV{HOMEDRIVE},$ENV{HOMEPATH},''))if$ENV{HOMEDRIVE}&& $ENV{HOMEPATH};my@other_home_envs=qw(USERPROFILE APPDATA WINDIR SYS$LOGIN);push(@home_dirs,map$ENV{$_},grep$ENV{$_},@other_home_envs);my@real_home_dirs=grep -d,@home_dirs;return wantarray ? @real_home_dirs : shift(@real_home_dirs)}sub _find_user_config {my$self=shift;my$file=shift;for my$dir ($self->_home_dir){my$path=File::Spec->catfile($dir,$file);return$path if -e $path}return undef}sub read_modulebuildrc {my($self,$action)=@_;return ()unless$self->use_rcfile;my$modulebuildrc;if (exists($ENV{MODULEBUILDRC})&& $ENV{MODULEBUILDRC}eq 'NONE'){return ()}elsif (exists($ENV{MODULEBUILDRC})&& -e $ENV{MODULEBUILDRC}){$modulebuildrc=$ENV{MODULEBUILDRC}}elsif (exists($ENV{MODULEBUILDRC})){$self->log_warn("WARNING: Can't find resource file " ."'$ENV{MODULEBUILDRC}' defined in environment.\n" ."No options loaded\n");return ()}else {$modulebuildrc=$self->_find_user_config('.modulebuildrc');return ()unless$modulebuildrc}open(my$fh,'<',$modulebuildrc)or die "Can't open $modulebuildrc: $!";my%options;my$buffer='';while (defined(my$line=<$fh>)){chomp($line);$line =~ s/#.*$//;next unless length($line);if ($line =~ /^\S/){if ($buffer){my($action,$options)=split(/\s+/,$buffer,2);$options{$action}.= $options .' ';$buffer=''}$buffer=$line}else {$buffer .= $line}}if ($buffer){my($action,$options)=split(/\s+/,$buffer,2);$options{$action}.= $options .' '}my ($global_opts)=$self->read_args($self->split_like_shell($options{'*'}|| ''));if ($action eq 'fakeinstall' &&!exists$options{fakeinstall}){$action='install'}my ($action_opts)=$self->read_args($self->split_like_shell($options{$action}|| ''));return$self->_merge_arglist($action_opts,$global_opts)}sub merge_modulebuildrc {my($self,$action,%cmdline_opts)=@_;my%rc_opts=$self->read_modulebuildrc($action || $self->{action}|| 'build');my%new_opts=$self->_merge_arglist(\%cmdline_opts,\%rc_opts);$self->merge_args($action,%new_opts)}sub merge_args {my ($self,$action,%args)=@_;$self->{action}=$action if defined$action;my%additive=map {$_=>1}$self->hash_properties;while (my ($key,$val)=each%args){$self->{phash}{runtime_params}->access($key=>$val)if$self->valid_property($key);if ($key eq 'config'){$self->config($_=>$val->{$_})foreach keys %$val}else {my$add_to=$additive{$key}? $self->{properties}{$key}: $self->valid_property($key)? $self->{properties}: $self->{args};if ($additive{$key}){$add_to->{$_}=$val->{$_}foreach keys %$val}else {$add_to->{$key}=$val}}}}sub cull_args {my$self=shift;my@arg_list=@_;unshift@arg_list,$self->split_like_shell($ENV{PERL_MB_OPT})if$ENV{PERL_MB_OPT};my ($args,$action)=$self->read_args(@arg_list);$self->merge_args($action,%$args);$self->merge_modulebuildrc($action,%$args)}sub super_classes {my ($self,$class,$seen)=@_;$class ||= ref($self)|| $self;$seen ||= {};no strict 'refs';my@super=grep {not $seen->{$_}++}$class,@{$class .'::ISA'};return@super,map {$self->super_classes($_,$seen)}@super}sub known_actions {my ($self)=@_;my%actions;no strict 'refs';for my$class ($self->super_classes){for (keys %{$class .'::'}){$actions{$1}++ if /^ACTION_(\w+)/}}return wantarray ? sort keys%actions : \%actions}sub get_action_docs {my ($self,$action)=@_;my$actions=$self->known_actions;die "No known action '$action'" unless$actions->{$action};my ($files_found,@docs)=(0);for my$class ($self->super_classes){(my$file=$class)=~ s{::}{/}g;$file=$INC{$file .'.pm'}or next;open(my$fh,'<',$file)or next;$files_found++;local $_;while (<$fh>){last if /^=head1 ACTIONS\s/}my$style;while (<$fh>){last if /^=head1 /;if(/^=(item|head2)\s+\Q$action\E\b/){$style=$1;push@docs,$_;last}}$style or next;if($style eq 'item'){my ($found,$inlist)=(0,0);while (<$fh>){if (/^=(item|back)/){last unless$inlist}push@docs,$_;++$inlist if /^=over/;--$inlist if /^=back/}}else {while (<$fh>){last if(/^=(?:head[12]|cut)/);push@docs,$_}}}unless ($files_found){$@="Couldn't find any documentation to search";return}unless (@docs){$@="Couldn't find any docs for action '$action'";return}return join '',@docs}sub ACTION_prereq_report {my$self=shift;$self->log_info($self->prereq_report)}sub ACTION_prereq_data {my$self=shift;$self->log_info(Module::Build::Dumper->_data_dump($self->prereq_data))}sub prereq_data {my$self=shift;my@types=('configure_requires',@{$self->prereq_action_types});my$info={map {$_=>$self->$_()}grep {%{$self->$_()}}@types };return$info}sub prereq_report {my$self=shift;my$info=$self->prereq_data;my$output='';for my$type (sort keys %$info){my$prereqs=$info->{$type};$output .= "\n$type:\n";my$mod_len=2;my$ver_len=4;my%mods;for my$modname (sort keys %$prereqs){my$spec=$prereqs->{$modname};my$len=length$modname;$mod_len=$len if$len > $mod_len;$spec ||= '0';$len=length$spec;$ver_len=$len if$len > $ver_len;my$mod=$self->check_installed_status($modname,$spec);$mod->{name}=$modname;$mod->{ok}||= 0;$mod->{ok}=!$mod->{ok}if$type =~ /^(\w+_)?conflicts$/;$mods{lc$modname}=$mod}my$space=q{ } x ($mod_len - 3);my$vspace=q{ } x ($ver_len - 3);my$sline=q{-} x ($mod_len - 3);my$vline=q{-} x ($ver_len - 3);my$disposition=($type =~ /^(\w+_)?conflicts$/)? 'Clash' : 'Need';$output .= "    Module $space  $disposition $vspace  Have\n"."    ------$sline+------$vline-+----------\n";for my$k (sort keys%mods){my$mod=$mods{$k};my$space=q{ } x ($mod_len - length$k);my$vspace=q{ } x ($ver_len - length$mod->{need});my$f=$mod->{ok}? ' ' : '!';$output .= "  $f $mod->{name} $space     $mod->{need}  $vspace   ".(defined($mod->{have})? $mod->{have}: "")."\n"}}return$output}sub ACTION_help {my ($self)=@_;my$actions=$self->known_actions;if (@{$self->{args}{ARGV}}){my$msg=eval {$self->get_action_docs($self->{args}{ARGV}[0],$actions)};print $@ ? "$@\n" : $msg;return}print <<EOF;print$self->_action_listing($actions);print "\nRun `Build help <action>` for details on an individual action.\n";print "See `perldoc Module::Build` for complete documentation.\n"}sub _action_listing {my ($self,$actions)=@_;my@actions=sort keys %$actions;@actions=map$actions[($_ + ($_ % 2)* @actions)/ 2],0..$#actions;my$out='';while (my ($one,$two)=splice@actions,0,2){$out .= sprintf("  %-12s                   %-12s\n",$one,$two||'')}$out =~ s{\s*$}{}mg;return$out}sub ACTION_retest {my ($self)=@_;local@INC=@INC;@INC=grep {ref()|| -d}@INC if@INC > 100;$self->do_tests}sub ACTION_testall {my ($self)=@_;my@types;for my$action (grep {$_ ne 'all'}$self->get_test_types){push(@types,$action)}$self->generic_test(types=>['default',@types])}sub get_test_types {my ($self)=@_;my$t=$self->{properties}->{test_types};return (defined$t ? (wantarray ? sort keys %$t : keys %$t): ())}sub ACTION_test {my ($self)=@_;$self->generic_test(type=>'default')}sub generic_test {my$self=shift;(@_ % 2)and croak('Odd number of elements in argument hash');my%args=@_;my$p=$self->{properties};my@types=((exists($args{type})? $args{type}: ()),(exists($args{types})? @{$args{types}}: ()),);@types or croak "need some types of tests to check";my%test_types=(default=>$p->{test_file_exts},(defined($p->{test_types})? %{$p->{test_types}}: ()),);for my$type (@types){croak "$type not defined in test_types!" unless defined$test_types{$type }}local$p->{test_file_exts}=[map {ref $_ ? @$_ : $_}@test_types{@types}];$self->depends_on('code');local@INC=@INC;unshift@INC,(File::Spec->catdir($p->{base_dir},$self->blib,'lib'),File::Spec->catdir($p->{base_dir},$self->blib,'arch'));@INC=grep {ref()|| -d}@INC if@INC > 100;$self->do_tests}sub do_tests {my$self=shift;my$tests=$self->find_test_files;local$ENV{PERL_DL_NONLAZY}=1;if(@$tests){my$args=$self->tap_harness_args;if($self->use_tap_harness or ($args and %$args)){my$aggregate=$self->run_tap_harness($tests);if ($aggregate->has_errors){die "Errors in testing.  Cannot continue.\n"}}else {$self->run_test_harness($tests)}}else {$self->log_info("No tests defined.\n")}$self->run_visual_script}sub run_tap_harness {my ($self,$tests)=@_;require TAP::Harness::Env;my$aggregate=TAP::Harness::Env->create({lib=>[@INC],verbosity=>$self->{properties}{verbose},switches=>[$self->harness_switches ],%{$self->tap_harness_args},})->runtests(@$tests);return$aggregate}sub run_test_harness {my ($self,$tests)=@_;require Test::Harness;local$Test::Harness::verbose=$self->verbose || 0;local$Test::Harness::switches=join ' ',$self->harness_switches;Test::Harness::runtests(@$tests)}sub run_visual_script {my$self=shift;$self->run_perl_script('visual.pl','-Mblib='.$self->blib)if -e 'visual.pl'}sub harness_switches {my$self=shift;my@res;push@res,qw(-w -d) if$self->{properties}{debugger};push@res,'-MDevel::Cover' if$self->{properties}{cover};return@res}sub test_files {my$self=shift;my$p=$self->{properties};if (@_){return$p->{test_files}=(@_==1 ? shift : [@_])}return$self->find_test_files}sub expand_test_dir {my ($self,$dir)=@_;my$exts=$self->{properties}{test_file_exts};return sort map {@{$self->rscan_dir($dir,qr{^[^.].*\Q$_\E$})}}@$exts if$self->recursive_test_files;return sort map {glob File::Spec->catfile($dir,"*$_")}@$exts}sub ACTION_testdb {my ($self)=@_;local$self->{properties}{debugger}=1;$self->depends_on('test')}sub ACTION_testcover {my ($self)=@_;unless (Module::Metadata->find_module_by_name('Devel::Cover')){warn("Cannot run testcover action unless Devel::Cover is installed.\n");return}$self->add_to_cleanup('coverage','cover_db');$self->depends_on('code');if (-e 'cover_db'){my$pm_files=$self->rscan_dir (File::Spec->catdir($self->blib,'lib'),$self->file_qr('\.pm$'));my$cover_files=$self->rscan_dir('cover_db',sub {-f $_ and not /\.html$/});$self->do_system(qw(cover -delete))unless$self->up_to_date($pm_files,$cover_files)&& $self->up_to_date($self->test_files,$cover_files)}local$self->{properties}{cover}=1;$self->depends_on('test');$self->do_system('cover')}sub ACTION_code {my ($self)=@_;my$blib=$self->blib;$self->add_to_cleanup($blib);File::Path::mkpath(File::Spec->catdir($blib,'arch'));if (my$split=$self->autosplit){$self->autosplit_file($_,$blib)for ref($split)? @$split : ($split)}for my$element (@{$self->build_elements}){my$method="process_${element}_files";$method="process_files_by_extension" unless$self->can($method);$self->$method($element)}$self->depends_on('config_data')}sub ACTION_build {my$self=shift;$self->log_info("Building " .$self->dist_name ."\n");$self->depends_on('code');$self->depends_on('docs')}sub process_files_by_extension {my ($self,$ext)=@_;my$method="find_${ext}_files";my$files=$self->can($method)? $self->$method(): $self->_find_file_by_type($ext,'lib');for my$file (sort keys %$files){$self->copy_if_modified(from=>$file,to=>File::Spec->catfile($self->blib,$files->{$file}))}}sub process_support_files {my$self=shift;my$p=$self->{properties};return unless$p->{c_source};my$files;if (ref($p->{c_source})eq "ARRAY"){push @{$p->{include_dirs}},@{$p->{c_source}};for my$path (@{$p->{c_source}}){push @$files,@{$self->rscan_dir($path,$self->file_qr('\.c(c|p|pp|xx|\+\+)?$'))}}}else {push @{$p->{include_dirs}},$p->{c_source};$files=$self->rscan_dir($p->{c_source},$self->file_qr('\.c(c|p|pp|xx|\+\+)?$'))}for my$file (@$files){push @{$p->{objects}},$self->compile_c($file)}}sub process_share_dir_files {my$self=shift;my$files=$self->_find_share_dir_files;return unless$files;my$share_prefix=File::Spec->catdir($self->blib,qw/lib auto share/);for my$file (sort keys %$files){$self->copy_if_modified(from=>$file,to=>File::Spec->catfile($share_prefix,$files->{$file}))}}sub _find_share_dir_files {my$self=shift;my$share_dir=$self->share_dir;return unless$share_dir;my@file_map;if ($share_dir->{dist}){my$prefix="dist/".$self->dist_name;push@file_map,$self->_share_dir_map($prefix,$share_dir->{dist})}if ($share_dir->{module}){for my$mod (sort keys %{$share_dir->{module}}){(my$altmod=$mod)=~ s{::}{-}g;my$prefix="module/$altmod";push@file_map,$self->_share_dir_map($prefix,$share_dir->{module}{$mod})}}return {@file_map }}sub _share_dir_map {my ($self,$prefix,$list)=@_;my%files;for my$dir (@$list){for my$f (@{$self->rscan_dir($dir,sub {-f})}){$f =~ s{\A.*?\Q$dir\E/}{};$files{"$dir/$f"}="$prefix/$f"}}return%files}sub process_PL_files {my ($self)=@_;my$files=$self->find_PL_files;for my$file (sort keys %$files){my$to=$files->{$file};unless ($self->up_to_date($file,$to)){$self->run_perl_script($file,[],[@$to])or die "$file failed";$self->add_to_cleanup(@$to)}}}sub process_xs_files {my$self=shift;return if$self->pureperl_only && $self->allow_pureperl;my$files=$self->find_xs_files;croak 'Can\'t build xs files under --pureperl-only' if %$files && $self->pureperl_only;for my$from (sort keys %$files){my$to=$files->{$from};unless ($from eq $to){$self->add_to_cleanup($to);$self->copy_if_modified(from=>$from,to=>$to)}$self->process_xs($to)}}sub process_pod_files {shift()->process_files_by_extension(shift())}sub process_pm_files {shift()->process_files_by_extension(shift())}sub process_script_files {my$self=shift;my$files=$self->find_script_files;return unless keys %$files;my$script_dir=File::Spec->catdir($self->blib,'script');File::Path::mkpath($script_dir);for my$file (sort keys %$files){my$result=$self->copy_if_modified($file,$script_dir,'flatten')or next;$self->fix_shebang_line($result)unless$self->is_vmsish;$self->make_executable($result)}}sub find_PL_files {my$self=shift;if (my$files=$self->{properties}{PL_files}){if (ref$files eq 'ARRAY'){return {map {$_,[/^(.*)\.PL$/]}map$self->localize_file_path($_),@$files }}elsif (ref$files eq 'HASH'){my%out;while (my ($file,$to)=each %$files){$out{$self->localize_file_path($file)}=[map$self->localize_file_path($_),ref$to ? @$to : ($to)]}return \%out}else {die "'PL_files' must be a hash reference or array reference"}}return unless -d 'lib';return {map {$_,[/^(.*)\.PL$/i ]}@{$self->rscan_dir('lib',$self->file_qr('\.PL$'))}}}sub find_pm_files {shift->_find_file_by_type('pm','lib')}sub find_pod_files {shift->_find_file_by_type('pod','lib')}sub find_xs_files {shift->_find_file_by_type('xs','lib')}sub find_script_files {my$self=shift;if (my$files=$self->script_files){return {map {$self->localize_file_path($_),$files->{$_}}keys %$files }}return {}}sub find_test_files {my$self=shift;my$p=$self->{properties};if (my$files=$p->{test_files}){$files=[sort keys %$files]if ref$files eq 'HASH';$files=[map {-d $_ ? $self->expand_test_dir($_): $_}map glob,$self->split_like_shell($files)];return [map$self->localize_file_path($_),@$files ]}else {my@tests;push@tests,'test.pl' if -e 'test.pl';push@tests,$self->expand_test_dir('t')if -e 't' and -d _;return \@tests}}sub _find_file_by_type {my ($self,$type,$dir)=@_;if (my$files=$self->{properties}{"${type}_files"}){return {map$self->localize_file_path($_),%$files }}return {}unless -d $dir;return {map {$_,$_}map$self->localize_file_path($_),grep!/\.\#/,@{$self->rscan_dir($dir,$self->file_qr("\\.$type\$"))}}}sub localize_file_path {my ($self,$path)=@_;return File::Spec->catfile(split m{/},$path)}sub localize_dir_path {my ($self,$path)=@_;return File::Spec->catdir(split m{/},$path)}sub fix_shebang_line {my ($self,@files)=@_;my$c=ref($self)? $self->{config}: 'Module::Build::Config';my ($does_shbang)=$c->get('sharpbang')=~ /^\s*\#\!/;for my$file (@files){open(my$FIXIN,'<',$file)or die "Can't process '$file': $!";local $/="\n";chomp(my$line=<$FIXIN>);next unless$line =~ s/^\s*\#!\s*//;my ($cmd,$arg)=(split(' ',$line,2),'');next unless$cmd =~ /perl/i;my$interpreter=$self->{properties}{perl};$self->log_verbose("Changing sharpbang in $file to $interpreter\n");my$shb='';$shb .= $c->get('sharpbang')."$interpreter $arg\n" if$does_shbang;open(my$FIXOUT,'>',"$file.new")or die "Can't create new $file: $!\n";local $\;undef $/;print$FIXOUT $shb,<$FIXIN>;close$FIXIN;close$FIXOUT;rename($file,"$file.bak")or die "Can't rename $file to $file.bak: $!";rename("$file.new",$file)or die "Can't rename $file.new to $file: $!";$self->delete_filetree("$file.bak")or $self->log_warn("Couldn't clean up $file.bak, leaving it there");$self->do_system($c->get('eunicefix'),$file)if$c->get('eunicefix')ne ':'}}sub ACTION_testpod {my$self=shift;$self->depends_on('docs');eval q{use Test::Pod 0.95; 1} or die "The 'testpod' action requires Test::Pod version 0.95";my@files=sort keys %{$self->_find_pods($self->libdoc_dirs)},keys %{$self->_find_pods ($self->bindoc_dirs,exclude=>[$self->file_qr('\.bat$')])}or die "Couldn't find any POD files to test\n";{package Module::Build::PodTester;Test::Pod->import(tests=>scalar@files);pod_file_ok($_)foreach@files}}sub ACTION_testpodcoverage {my$self=shift;$self->depends_on('docs');eval q{use Test::Pod::Coverage 1.00; 1} or die "The 'testpodcoverage' action requires ","Test::Pod::Coverage version 1.00";local@INC=@INC;my$p=$self->{properties};unshift(@INC,File::Spec->catdir($p->{base_dir},$self->blib,'lib'),);all_pod_coverage_ok()}sub ACTION_docs {my$self=shift;$self->depends_on('code');$self->depends_on('manpages','html')}sub _is_default_installable {my$self=shift;my$type=shift;return ($self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs)->{$type}))? 1 : 0}sub _is_ActivePerl {my$self=shift;unless (exists($self->{_is_ActivePerl})){$self->{_is_ActivePerl}=(eval {require ActivePerl::DocTools}|| 0)}return$self->{_is_ActivePerl}}sub _is_ActivePPM {my$self=shift;unless (exists($self->{_is_ActivePPM})){$self->{_is_ActivePPM}=(eval {require ActivePerl::PPM}|| 0)}return$self->{_is_ActivePPM}}sub ACTION_manpages {my$self=shift;return unless$self->_mb_feature('manpage_support');$self->depends_on('code');my%extra_manify_args=$self->{properties}{'extra_manify_args'}? %{$self->{properties}{'extra_manify_args'}}: ();for my$type (qw(bin lib)){next unless ($self->invoked_action eq 'manpages' || $self->_is_default_installable("${type}doc"));my$files=$self->_find_pods($self->{properties}{"${type}doc_dirs"},exclude=>[$self->file_qr('\.bat$')]);next unless %$files;my$sub=$self->can("manify_${type}_pods");$self->$sub(%extra_manify_args)if defined($sub)}}sub manify_bin_pods {my$self=shift;my%podman_args=(section=>1,@_);my$files=$self->_find_pods($self->{properties}{bindoc_dirs},exclude=>[$self->file_qr('\.bat$')]);return unless keys %$files;my$mandir=File::Spec->catdir($self->blib,'bindoc');File::Path::mkpath($mandir,0,oct(777));require Pod::Man;for my$file (sort keys %$files){my$parser=Pod::Man->new(%podman_args);my$manpage=$self->man1page_name($file).'.' .$self->config('man1ext');my$outfile=File::Spec->catfile($mandir,$manpage);next if$self->up_to_date($file,$outfile);$self->log_verbose("Manifying $file -> $outfile\n");eval {$parser->parse_from_file($file,$outfile);1}or $self->log_warn("Error creating '$outfile': $@\n");$files->{$file}=$outfile}}sub manify_lib_pods {my$self=shift;my%podman_args=(section=>3,@_);my$files=$self->_find_pods($self->{properties}{libdoc_dirs});return unless keys %$files;my$mandir=File::Spec->catdir($self->blib,'libdoc');File::Path::mkpath($mandir,0,oct(777));require Pod::Man;for my$file (sort keys %$files){my$parser=Pod::Man->new(%podman_args);my$manpage=$self->man3page_name($files->{$file}).'.' .$self->config('man3ext');my$outfile=File::Spec->catfile($mandir,$manpage);next if$self->up_to_date($file,$outfile);$self->log_verbose("Manifying $file -> $outfile\n");eval {$parser->parse_from_file($file,$outfile);1}or $self->log_warn("Error creating '$outfile': $@\n");$files->{$file}=$outfile}}sub _find_pods {my ($self,$dirs,%args)=@_;my%files;for my$spec (@$dirs){my$dir=$self->localize_dir_path($spec);next unless -e $dir;FILE: foreach my$file (@{$self->rscan_dir($dir)}){for my$regexp (@{$args{exclude}}){next FILE if$file =~ $regexp}$file=$self->localize_file_path($file);$files{$file}=File::Spec->abs2rel($file,$dir)if$self->contains_pod($file)}}return \%files}sub contains_pod {my ($self,$file)=@_;return '' unless -T $file;open(my$fh,'<',$file)or die "Can't open $file: $!";while (my$line=<$fh>){return 1 if$line =~ /^\=(?:head|pod|item)/}return ''}sub ACTION_html {my$self=shift;return unless$self->_mb_feature('HTML_support');$self->depends_on('code');for my$type (qw(bin lib)){next unless ($self->invoked_action eq 'html' || $self->_is_default_installable("${type}html"));$self->htmlify_pods($type)}}sub htmlify_pods {my$self=shift;my$type=shift;my$htmldir=shift || File::Spec->catdir($self->blib,"${type}html");$self->add_to_cleanup('pod2htm*');my$pods=$self->_find_pods($self->{properties}{"${type}doc_dirs"},exclude=>[$self->file_qr('\.(?:bat|com|html)$')]);return unless %$pods;unless (-d $htmldir){File::Path::mkpath($htmldir,0,oct(755))or die "Couldn't mkdir $htmldir: $!"}my@rootdirs=($type eq 'bin')? qw(bin) : $self->installdirs eq 'core' ? qw(lib) : qw(site lib);my$podroot=$ENV{PERL_CORE}? File::Basename::dirname($ENV{PERL_CORE}): $self->original_prefix('core');my$htmlroot=$self->install_sets('core')->{libhtml};my$podpath;unless (defined$self->args('html_links')and!$self->args('html_links')){my@podpath=((map {File::Spec->abs2rel($_,$podroot)}grep {-d}($self->install_sets('core','lib'),$self->install_sets('core','bin'),$self->install_sets('site','lib'),)),File::Spec->rel2abs($self->blib));$podpath=$ENV{PERL_CORE}? File::Spec->catdir($podroot,'lib'): join(":",map {tr,:\\,|/,;$_}@podpath)}my$blibdir=join('/',File::Spec->splitdir((File::Spec->splitpath(File::Spec->rel2abs($htmldir),1))[1]),'');my ($with_ActiveState,$htmltool);if ($with_ActiveState=$self->_is_ActivePerl && eval {require ActivePerl::DocTools::Pod;1}){my$tool_v=ActiveState::DocTools::Pod->VERSION;$htmltool="ActiveState::DocTools::Pod";$htmltool .= " $tool_v" if$tool_v && length$tool_v}else {require Module::Build::PodParser;require Pod::Html;$htmltool="Pod::Html " .Pod::Html->VERSION}$self->log_verbose("Converting Pod to HTML with $htmltool\n");my$errors=0;POD: foreach my$pod (sort keys %$pods){my ($name,$path)=File::Basename::fileparse($pods->{$pod},$self->file_qr('\.(?:pm|plx?|pod)$'));my@dirs=File::Spec->splitdir(File::Spec->canonpath($path));pop(@dirs)if scalar(@dirs)&& $dirs[-1]eq File::Spec->curdir;my$fulldir=File::Spec->catdir($htmldir,@rootdirs,@dirs);my$tmpfile=File::Spec->catfile($fulldir,"${name}.tmp");my$outfile=File::Spec->catfile($fulldir,"${name}.html");my$infile=File::Spec->abs2rel($pod);next if$self->up_to_date($infile,$outfile);unless (-d $fulldir){File::Path::mkpath($fulldir,0,oct(755))or die "Couldn't mkdir $fulldir: $!"}$self->log_verbose("HTMLifying $infile -> $outfile\n");if ($with_ActiveState){my$depth=@rootdirs + @dirs;my%opts=(infile=>$infile,outfile=>$tmpfile,(defined($podpath)? (podpath=>$podpath): ()),podroot=>$podroot,index=>1,depth=>$depth,);eval {ActivePerl::DocTools::Pod::pod2html(map {($_,$opts{$_})}sort keys%opts);1}or $self->log_warn("[$htmltool] pod2html (" .join(", ",map {"q{$_} => q{$opts{$_}}"}(sort keys%opts)).") failed: $@")}else {my$path2root=File::Spec->catdir((File::Spec->updir)x @dirs);open(my$fh,'<',$infile)or die "Can't read $infile: $!";my$abstract=Module::Build::PodParser->new(fh=>$fh)->get_abstract();my$title=join('::',(@dirs,$name));$title .= " - $abstract" if$abstract;my@opts=("--title=$title",(defined($podpath)? "--podpath=$podpath" : ()),"--infile=$infile","--outfile=$tmpfile","--podroot=$podroot",($path2root ? "--htmlroot=$path2root" : ()),);unless (eval{Pod::Html->VERSION(1.12)}){push(@opts,('--flush'))}if (eval{Pod::Html->VERSION(1.12)}){push(@opts,('--header','--backlink'))}elsif (eval{Pod::Html->VERSION(1.03)}){push(@opts,('--header','--backlink=Back to Top'))}$self->log_verbose("P::H::pod2html @opts\n");{my$orig=Cwd::getcwd();eval {Pod::Html::pod2html(@opts);1}or $self->log_warn("[$htmltool] pod2html( " .join(", ",map {"q{$_}"}@opts).") failed: $@");chdir($orig)}}if (!-r $tmpfile){$errors++;next POD}open(my$fh,'<',$tmpfile)or die "Can't read $tmpfile: $!";my$html=join('',<$fh>);close$fh;if (!$self->_is_ActivePerl){$html =~ s#^<!DOCTYPE .*?>#<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">#im;$html =~ s#<html xmlns="http://www.w3.org/1999/xhtml">#<html>#i;$html =~ s#<head>#<head>\n<!-- saved from url=(0017)http://localhost/ -->#i}$html =~ s/\Q$blibdir\E//g;open($fh,'>',$outfile)or die "Can't write $outfile: $!";print$fh $html;close$fh;unlink($tmpfile)}return!$errors}sub man1page_name {my$self=shift;return File::Basename::basename(shift)}sub man3page_name {my$self=shift;my ($vol,$dirs,$file)=File::Spec->splitpath(shift);my@dirs=File::Spec->splitdir(File::Spec->canonpath($dirs));$file =~ s/\.p(?:od|m|l)\z//i;return join($self->manpage_separator,@dirs,$file)}sub manpage_separator {return '::'}sub ACTION_diff {my$self=shift;$self->depends_on('build');my$local_lib=File::Spec->rel2abs('lib');my@myINC=grep {$_ ne $local_lib}@INC;push@myINC,map$self->install_destination($_),qw(lib arch);my@flags=@{$self->{args}{ARGV}};@flags=$self->split_like_shell($self->{args}{flags}|| '')unless@flags;my$installmap=$self->install_map;delete$installmap->{read};delete$installmap->{write};my$text_suffix=$self->file_qr('\.(pm|pod)$');for my$localdir (sort keys %$installmap){my@localparts=File::Spec->splitdir($localdir);my$files=$self->rscan_dir($localdir,sub {-f});for my$file (@$files){my@parts=File::Spec->splitdir($file);@parts=@parts[@localparts .. $#parts];my$installed=Module::Metadata->find_module_by_name(join('::',@parts),\@myINC);if (not $installed){print "Only in lib: $file\n";next}my$status=File::Compare::compare($installed,$file);next if$status==0;die "Can't compare $installed and $file: $!" if$status==-1;if ($file =~ $text_suffix){$self->do_system('diff',@flags,$installed,$file)}else {print "Binary files $file and $installed differ\n"}}}}sub ACTION_pure_install {shift()->depends_on('install')}sub ACTION_install {my ($self)=@_;require ExtUtils::Install;$self->depends_on('build');$self->_do_in_dir(".",sub {ExtUtils::Install::install($self->install_map,$self->verbose,0,$self->{args}{uninst}||0)});if ($self->_is_ActivePerl && $self->{_completed_actions}{html}){$self->log_info("Building ActivePerl Table of Contents\n");eval {ActivePerl::DocTools::WriteTOC(verbose=>$self->verbose ? 1 : 0);1}or $self->log_warn("AP::DT:: WriteTOC() failed: $@")}if ($self->_is_ActivePPM){my$F_perllocal=File::Spec->catfile($self->install_sets('core','lib'),'perllocal.pod');my$dt_stamp=time;$self->log_info("For ActivePerl's PPM: touch '$F_perllocal'\n");open my$perllocal,">>",$F_perllocal;close$perllocal;utime($dt_stamp,$dt_stamp,$F_perllocal)}}sub ACTION_fakeinstall {my ($self)=@_;require ExtUtils::Install;my$eui_version=ExtUtils::Install->VERSION;if ($eui_version < 1.32){$self->log_warn("The 'fakeinstall' action requires Extutils::Install 1.32 or later.\n" ."(You only have version $eui_version).");return}$self->depends_on('build');ExtUtils::Install::install($self->install_map,!$self->quiet,1,$self->{args}{uninst}||0)}sub ACTION_versioninstall {my ($self)=@_;die "You must have only.pm 0.25 or greater installed for this operation: $@\n" unless eval {require only;'only'->VERSION(0.25);1};$self->depends_on('build');my%onlyargs=map {exists($self->{args}{$_})? ($_=>$self->{args}{$_}): ()}qw(version versionlib);only::install::install(%onlyargs)}sub ACTION_installdeps {my ($self)=@_;my$info=$self->_enum_prereqs;if (!$info){$self->log_info("No prerequisites detected\n");return}my$failures=$self->prereq_failures($info);if (!$failures){$self->log_info("All prerequisites satisfied\n");return}my@install;for my$type (sort keys %$failures){my$prereqs=$failures->{$type};if($type =~ m/^(?:\w+_)?requires$/){push(@install,sort keys %$prereqs);next}$self->log_info("Checking optional dependencies:\n");for my$module (sort keys %$prereqs){push(@install,$module)if($self->y_n("Install $module?",'y'))}}return unless@install;my ($command,@opts)=$self->split_like_shell($self->cpan_client);if (!File::Spec->file_name_is_absolute($command)){my@loc=('site','vendor','');my@bindirs=File::Basename::dirname($self->perl);push@bindirs,map {($self->config->{"install${_}bin"},$self->config->{"install${_}script"})}@loc;for my$d (@bindirs){my$abs_cmd=$self->find_command(File::Spec->catfile($d,$command));if (defined$abs_cmd){$command=$abs_cmd;last}}}$self->do_system($command,@opts,@install)}sub ACTION_clean {my ($self)=@_;$self->log_info("Cleaning up build files\n");for my$item (map glob($_),$self->cleanup){$self->delete_filetree($item)}}sub ACTION_realclean {my ($self)=@_;$self->depends_on('clean');$self->log_info("Cleaning up configuration files\n");$self->delete_filetree($self->config_dir,$self->mymetafile,$self->mymetafile2,$self->build_script)}sub ACTION_ppd {my ($self)=@_;require Module::Build::PPMMaker;my$ppd=Module::Build::PPMMaker->new();my$file=$ppd->make_ppd(%{$self->{args}},build=>$self);$self->add_to_cleanup($file)}sub ACTION_ppmdist {my ($self)=@_;$self->depends_on('build');my$ppm=$self->ppm_name;$self->delete_filetree($ppm);$self->log_info("Creating $ppm\n");$self->add_to_cleanup($ppm,"$ppm.tar.gz");my%types=(lib=>'lib',arch=>'arch',bin=>'bin',script=>'script',bindoc=>'man1',libdoc=>'man3',binhtml=>undef,libhtml=>undef,);for my$type ($self->install_types){next if exists($types{$type})&&!defined($types{$type});my$dir=File::Spec->catdir($self->blib,$type);next unless -e $dir;my$files=$self->rscan_dir($dir);for my$file (@$files){next unless -f $file;my$rel_file=File::Spec->abs2rel(File::Spec->rel2abs($file),File::Spec->rel2abs($dir));my$to_file=File::Spec->catfile($ppm,'blib',exists($types{$type})? $types{$type}: $type,$rel_file);$self->copy_if_modified(from=>$file,to=>$to_file)}}for my$type (qw(bin lib)){$self->htmlify_pods($type,File::Spec->catdir($ppm,'blib','html'))}my$target=File::Spec->catfile(File::Spec->updir,$ppm);$self->_do_in_dir($ppm,sub {$self->make_tarball('blib',$target)});$self->depends_on('ppd');$self->delete_filetree($ppm)}sub ACTION_pardist {my ($self)=@_;if (not eval {require PAR::Dist;PAR::Dist->VERSION(0.17)}){$self->log_warn("In order to create .par distributions, you need to\n" ."install PAR::Dist first.");return()}$self->depends_on('build');return PAR::Dist::blib_to_par(name=>$self->dist_name,version=>$self->dist_version,)}sub ACTION_dist {my ($self)=@_;$self->dispatch('distdir');my$dist_dir=$self->dist_dir;$self->make_tarball($dist_dir);$self->delete_filetree($dist_dir)}sub ACTION_distcheck {my ($self)=@_;$self->_check_manifest_skip unless$self->invoked_action eq 'distclean';require ExtUtils::Manifest;local $^W;my ($missing,$extra)=ExtUtils::Manifest::fullcheck();return unless @$missing || @$extra;my$msg="MANIFEST appears to be out of sync with the distribution\n";if ($self->invoked_action eq 'distcheck'){die$msg}else {warn$msg}}sub _check_mymeta_skip {my$self=shift;my$maniskip=shift || 'MANIFEST.SKIP';require ExtUtils::Manifest;local $^W;my$skip_factory=ExtUtils::Manifest->can('maniskip')|| ExtUtils::Manifest->can('_maniskip');my$mymetafile=$self->mymetafile;for my$file ($self->mymetafile,$self->mymetafile2){unless ($skip_factory && $skip_factory->($maniskip)->($file)){$self->log_warn("File '$maniskip' does not include '$file'. Adding it now.\n");my$safe=quotemeta($file);$self->_append_maniskip("^$safe\$",$maniskip)}}}sub _add_to_manifest {my ($self,$manifest,$lines)=@_;$lines=[$lines]unless ref$lines;my$existing_files=$self->_read_manifest($manifest);return unless defined($existing_files);@$lines=grep {!exists$existing_files->{$_}}@$lines or return;my$mode=(stat$manifest)[2];chmod($mode | oct(222),$manifest)or die "Can't make $manifest writable: $!";open(my$fh,'<',$manifest)or die "Can't read $manifest: $!";my$last_line=(<$fh>)[-1]|| "\n";my$has_newline=$last_line =~ /\n$/;close$fh;open($fh,'>>',$manifest)or die "Can't write to $manifest: $!";print$fh "\n" unless$has_newline;print$fh map "$_\n",@$lines;close$fh;chmod($mode,$manifest);$self->log_verbose(map "Added to $manifest: $_\n",@$lines)}sub _sign_dir {my ($self,$dir)=@_;unless (eval {require Module::Signature;1}){$self->log_warn("Couldn't load Module::Signature for 'distsign' action:\n $@\n");return}{my$manifest=File::Spec->catfile($dir,'MANIFEST');die "Signing a distribution requires a MANIFEST file" unless -e $manifest;$self->_add_to_manifest($manifest,"SIGNATURE    Added here by Module::Build")}$self->_do_in_dir($dir,sub {local$Module::Signature::Quiet=1;Module::Signature::sign()})}sub _do_in_dir {my ($self,$dir,$do)=@_;my$start_dir=File::Spec->rel2abs($self->cwd);chdir$dir or die "Can't chdir() to $dir: $!";eval {$do->()};my@err=$@ ? ($@): ();chdir$start_dir or push@err,"Can't chdir() back to $start_dir: $!";die join "\n",@err if@err}sub ACTION_distsign {my ($self)=@_;{local$self->{properties}{sign}=0;$self->depends_on('distdir')unless -d $self->dist_dir}$self->_sign_dir($self->dist_dir)}sub ACTION_skipcheck {my ($self)=@_;require ExtUtils::Manifest;local $^W;ExtUtils::Manifest::skipcheck()}sub ACTION_distclean {my ($self)=@_;$self->depends_on('realclean');$self->depends_on('distcheck')}sub do_create_makefile_pl {my$self=shift;require Module::Build::Compat;$self->log_info("Creating Makefile.PL\n");eval {Module::Build::Compat->create_makefile_pl($self->create_makefile_pl,$self,@_)};if ($@){1 while unlink 'Makefile.PL';die "$@\n"}$self->_add_to_manifest('MANIFEST','Makefile.PL')}sub do_create_license {my$self=shift;$self->log_info("Creating LICENSE file\n");if (!$self->_mb_feature('license_creation')){$self->_warn_mb_feature_deps('license_creation');die "Aborting.\n"}my$l=$self->license or die "Can't create LICENSE file: No license specified\n";my$license=$self->_software_license_object or die << "HERE";$self->delete_filetree('LICENSE');open(my$fh,'>','LICENSE')or die "Can't write LICENSE file: $!";print$fh $license->fulltext;close$fh;$self->_add_to_manifest('MANIFEST','LICENSE')}sub do_create_readme {my$self=shift;$self->delete_filetree('README');my$docfile=$self->_main_docfile;unless ($docfile){$self->log_warn(<<EOF);return}if (eval {require Pod::Readme;Pod::Readme->can('new')}){$self->log_info("Creating README using Pod::Readme\n");my$parser=Pod::Readme->new;$parser->parse_from_file($docfile,'README',@_)}elsif (eval {require Pod::Text;1}){$self->log_info("Creating README using Pod::Text\n");if (open(my$fh,'>','README')){local $^W=0;no strict "refs";my$old_parse_file;$old_parse_file=\&{"Pod::Simple::parse_file"}and local *{"Pod::Simple::parse_file"}=sub {my$self=shift;$self->output_fh($_[1])if $_[1];$self->$old_parse_file($_[0])}if$Pod::Text::VERSION ==3.01;Pod::Text::pod2text($docfile,$fh);close$fh}else {$self->log_warn("Cannot create 'README' file: Can't open file for writing\n");return}}else {$self->log_warn("Can't load Pod::Readme or Pod::Text to create README\n");return}$self->_add_to_manifest('MANIFEST','README')}sub _main_docfile {my$self=shift;if (my$pm_file=$self->dist_version_from){(my$pod_file=$pm_file)=~ s/.pm$/.pod/;return (-e $pod_file ? $pod_file : $pm_file)}else {return undef}}sub do_create_bundle_inc {my$self=shift;my$dist_inc=File::Spec->catdir($self->dist_dir,'inc');require inc::latest;inc::latest->write($dist_inc,@{$self->bundle_inc_preload});inc::latest->bundle_module($_,$dist_inc)for @{$self->bundle_inc};return 1}sub ACTION_distdir {my ($self)=@_;if (@{$self->bundle_inc}&&!$self->_mb_feature('inc_bundling_support')){$self->_warn_mb_feature_deps('inc_bundling_support');die "Aborting.\n"}$self->depends_on('distmeta');my$dist_files=$self->_read_manifest('MANIFEST')or die "Can't create distdir without a MANIFEST file - run 'manifest' action first.\n";delete$dist_files->{SIGNATURE};die "No files found in MANIFEST - try running 'manifest' action?\n" unless ($dist_files and keys %$dist_files);my$metafile=$self->metafile;$self->log_warn("*** Did you forget to add $metafile to the MANIFEST?\n")unless exists$dist_files->{$metafile};my$dist_dir=$self->dist_dir;$self->delete_filetree($dist_dir);$self->log_info("Creating $dist_dir\n");$self->add_to_cleanup($dist_dir);for my$file (sort keys %$dist_files){next if$file =~ m{^MYMETA\.};my$new=$self->copy_if_modified(from=>$file,to_dir=>$dist_dir,verbose=>0)}$self->do_create_bundle_inc if @{$self->bundle_inc};$self->_sign_dir($dist_dir)if$self->{properties}{sign}}sub ACTION_disttest {my ($self)=@_;$self->depends_on('distdir');$self->_do_in_dir ($self->dist_dir,sub {local$ENV{AUTHOR_TESTING}=1;local$ENV{RELEASE_TESTING}=1;$self->run_perl_script('Build.PL')or die "Error executing 'Build.PL' in dist directory: $!";$self->run_perl_script($self->build_script)or die "Error executing $self->build_script in dist directory: $!";$self->run_perl_script($self->build_script,[],['test'])or die "Error executing 'Build test' in dist directory"})}sub ACTION_distinstall {my ($self,@args)=@_;$self->depends_on('distdir');$self->_do_in_dir ($self->dist_dir,sub {$self->run_perl_script('Build.PL')or die "Error executing 'Build.PL' in dist directory: $!";$self->run_perl_script($self->build_script)or die "Error executing $self->build_script in dist directory: $!";$self->run_perl_script($self->build_script,[],['install'])or die "Error executing 'Build install' in dist directory"})}sub _eumanifest_has_include {my$self=shift;require ExtUtils::Manifest;return eval {ExtUtils::Manifest->VERSION(1.50);1}}sub _default_maniskip {my$self=shift;my$default_maniskip;for my$dir (@INC){$default_maniskip=File::Spec->catfile($dir,"ExtUtils","MANIFEST.SKIP");last if -r $default_maniskip}return$default_maniskip}sub _slurp {my$self=shift;my$file=shift;my$mode=shift || "";open my$fh,"<$mode",$file or croak "Can't open $file for reading: $!";local $/;return <$fh>}sub _spew {my$self=shift;my$file=shift;my$content=shift || "";my$mode=shift || "";open my$fh,">$mode",$file or croak "Can't open $file for writing: $!";print {$fh}$content;close$fh}sub _case_tolerant {my$self=shift;if (ref$self){$self->{_case_tolerant}=File::Spec->case_tolerant unless defined($self->{_case_tolerant});return$self->{_case_tolerant}}else {return File::Spec->case_tolerant}}sub _append_maniskip {my$self=shift;my$skip=shift;my$file=shift || 'MANIFEST.SKIP';return unless defined$skip && length$skip;open(my$fh,'>>',$file)or die "Can't open $file: $!";print$fh "$skip\n";close$fh}sub _write_default_maniskip {my$self=shift;my$file=shift || 'MANIFEST.SKIP';open(my$fh,'>',$file)or die "Can't open $file: $!";my$content=$self->_eumanifest_has_include ? "#!include_default\n" : $self->_slurp($self->_default_maniskip);$content .= <<'EOF';$content .= '\b'.$self->dist_name.'-[\d\.\_]+'."\n";print$fh $content;close$fh;return}sub _check_manifest_skip {my ($self)=@_;my$maniskip='MANIFEST.SKIP';if (!-e $maniskip){$self->log_warn("File '$maniskip' does not exist: Creating a temporary '$maniskip'\n");$self->_write_default_maniskip($maniskip);$self->_unlink_on_exit($maniskip)}else {$self->_check_mymeta_skip($maniskip)}return}sub ACTION_manifest {my ($self)=@_;$self->_check_manifest_skip;require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);ExtUtils::Manifest::mkmanifest()}sub ACTION_manifest_skip {my ($self)=@_;if (-e 'MANIFEST.SKIP'){$self->log_warn("MANIFEST.SKIP already exists.\n");return 0}$self->log_info("Creating a new MANIFEST.SKIP file\n");return$self->_write_default_maniskip;return -e 'MANIFEST.SKIP'}sub file_qr {return shift->{_case_tolerant}? qr($_[0])i : qr($_[0])}sub dist_dir {my ($self)=@_;my$dir=join "-",$self->dist_name,$self->dist_version;$dir .= "-" .$self->dist_suffix if$self->dist_suffix;return$dir}sub ppm_name {my$self=shift;return 'PPM-' .$self->dist_dir}sub _files_in {my ($self,$dir)=@_;return unless -d $dir;local*DH;opendir DH,$dir or die "Can't read directory $dir: $!";my@files;while (defined (my$file=readdir DH)){my$full_path=File::Spec->catfile($dir,$file);next if -d $full_path;push@files,$full_path}return@files}sub share_dir {my$self=shift;my$p=$self->{properties};$p->{share_dir}=shift if @_;if (!defined$p->{share_dir}){return}elsif (!ref$p->{share_dir}){$p->{share_dir}={dist=>[$p->{share_dir}]}}elsif (ref$p->{share_dir}eq 'ARRAY'){$p->{share_dir}={dist=>$p->{share_dir}}}elsif (ref$p->{share_dir}eq 'HASH'){my$share_dir=$p->{share_dir};if (defined$share_dir->{dist}){if (!ref$share_dir->{dist}){$share_dir->{dist}=[$share_dir->{dist}]}elsif (ref$share_dir->{dist}ne 'ARRAY'){die "'dist' key in 'share_dir' must be scalar or arrayref"}}if (defined$share_dir->{module}){my$mod_hash=$share_dir->{module};if (ref$mod_hash eq 'HASH'){for my$k (sort keys %$mod_hash){if (!ref$mod_hash->{$k}){$mod_hash->{$k}=[$mod_hash->{$k}]}elsif(ref$mod_hash->{$k}ne 'ARRAY'){die "modules in 'module' key of 'share_dir' must be scalar or arrayref"}}}else {die "'module' key in 'share_dir' must be hashref"}}}else {die "'share_dir' must be hashref, arrayref or string"}return$p->{share_dir}}sub script_files {my$self=shift;for ($self->{properties}{script_files}){$_=shift if @_;next unless $_;return $_ if ref $_ eq 'HASH';return $_={map {$_,1}@$_ }if ref $_ eq 'ARRAY';die "'script_files' must be a hashref, arrayref, or string" if ref();return $_={map {$_,1}$self->_files_in($_)}if -d $_;return $_={$_=>1}}my%pl_files=map {File::Spec->canonpath($_)=>1}keys %{$self->PL_files || {}};my@bin_files=$self->_files_in('bin');my%bin_map=map {$_=>File::Spec->canonpath($_)}@bin_files;return $_={map {$_=>1}grep!$pl_files{$bin_map{$_}},@bin_files }}BEGIN {*scripts=\&script_files}{my%licenses=(perl=>'Perl_5',apache=>'Apache_2_0',apache_1_1=>'Apache_1_1',artistic=>'Artistic_1',artistic_2=>'Artistic_2',lgpl=>'LGPL_2_1',lgpl2=>'LGPL_2_1',lgpl3=>'LGPL_3_0',bsd=>'BSD',gpl=>'GPL_1',gpl2=>'GPL_2',gpl3=>'GPL_3',mit=>'MIT',mozilla=>'Mozilla_1_1',restrictive=>'Restricted',open_source=>undef,unrestricted=>undef,unknown=>undef,);my%license_urls=(perl=>'http://dev.perl.org/licenses/',apache=>'http://apache.org/licenses/LICENSE-2.0',apache_1_1=>'http://apache.org/licenses/LICENSE-1.1',artistic=>'http://opensource.org/licenses/artistic-license.php',artistic_2=>'http://opensource.org/licenses/artistic-license-2.0.php',lgpl=>'http://opensource.org/licenses/lgpl-license.php',lgpl2=>'http://opensource.org/licenses/lgpl-2.1.php',lgpl3=>'http://opensource.org/licenses/lgpl-3.0.html',bsd=>'http://opensource.org/licenses/bsd-license.php',gpl=>'http://opensource.org/licenses/gpl-license.php',gpl2=>'http://opensource.org/licenses/gpl-2.0.php',gpl3=>'http://opensource.org/licenses/gpl-3.0.html',mit=>'http://opensource.org/licenses/mit-license.php',mozilla=>'http://opensource.org/licenses/mozilla1.1.php',restrictive=>undef,open_source=>undef,unrestricted=>undef,unknown=>undef,);sub valid_licenses {return \%licenses}sub _license_url {return$license_urls{$_[1]}}}sub _software_license_class {my ($self,$license)=@_;if ($self->valid_licenses->{$license}&& eval {require Software::LicenseUtils;Software::LicenseUtils->VERSION(0.103009)}){my@classes=Software::LicenseUtils->guess_license_from_meta_key($license,1);if (@classes==1){eval "require $classes[0]";return$classes[0]}}LICENSE: for my$l ($self->valid_licenses->{$license },$license){next unless defined$l;my$trial="Software::License::" .$l;if (eval "require Software::License; Software::License->VERSION(0.014); require $trial; 1"){return$trial}}return}sub _software_license_object {my ($self)=@_;return unless defined(my$license=$self->license);my$class=$self->_software_license_class($license)or return;my$author=join(" & ",@{$self->dist_author})|| 'unknown';my$sl=eval {$class->new({holder=>$author})};if ($@){$self->log_warn("Error getting '$class' object: $@")}return$sl}sub _hash_merge {my ($self,$h,$k,$v)=@_;if (ref$h->{$k}eq 'ARRAY'){push @{$h->{$k}},ref$v ? @$v : $v}elsif (ref$h->{$k}eq 'HASH'){$h->{$k}{$_}=$v->{$_}foreach keys %$v}else {$h->{$k}=$v}}sub ACTION_distmeta {my ($self)=@_;$self->do_create_makefile_pl if$self->create_makefile_pl;$self->do_create_readme if$self->create_readme;$self->do_create_license if$self->create_license;$self->do_create_metafile}sub do_create_metafile {my$self=shift;return if$self->{wrote_metadata};my$p=$self->{properties};unless ($p->{license}){$self->log_warn("No license specified, setting license = 'unknown'\n");$p->{license}='unknown'}my@metafiles=($self->metafile,$self->metafile2);$self->delete_filetree($_)for@metafiles;local@INC=@INC;if (($self->module_name || '')eq 'Module::Build'){$self->depends_on('config_data');push@INC,File::Spec->catdir($self->blib,'lib')}my$meta_obj=$self->_get_meta_object(quiet=>1,fatal=>1,auto=>1);my@created=$self->_write_meta_files($meta_obj,'META');if (@created){$self->{wrote_metadata}=1;$self->_add_to_manifest('MANIFEST',$_)for@created}return 1}sub _write_meta_files {my$self=shift;my ($meta,$file)=@_;$file =~ s{\.(?:yml|json)$}{};my@created;push@created,"$file\.yml" if$meta && $meta->save("$file\.yml",{version=>"1.4"});push@created,"$file\.json" if$meta && $meta->save("$file\.json");if (@created){$self->log_info("Created " .join(" and ",@created)."\n")}return@created}sub _get_meta_object {my$self=shift;my%args=@_;return unless$self->try_require("CPAN::Meta","2.142060");my$meta;eval {my$data=$self->get_metadata(fatal=>$args{fatal},auto=>$args{auto},);$data->{dynamic_config}=$args{dynamic}if defined$args{dynamic};$meta=CPAN::Meta->create($data)};if ($@ &&!$args{quiet}){$self->log_warn("Could not get valid metadata. Error is: $@\n")}return$meta}sub read_metafile {my$self=shift;my ($metafile)=@_;return unless$self->try_require("CPAN::Meta","2.110420");my$meta=CPAN::Meta->load_file($metafile);return$meta->as_struct({version=>"2.0"})}sub normalize_version {my ($self,$version)=@_;$version=0 unless defined$version and length$version;if ($version =~ /[=<>!,]/){}elsif (ref$version eq 'version'){$version=$version->is_qv ? $version->normal : $version->stringify}elsif ($version =~ /^[^v][^.]*\.[^.]+\./){$version="v$version"}else {}return$version}my%prereq_map=(requires=>[qw/runtime requires/],configure_requires=>[qw/configure requires/],build_requires=>[qw/build requires/ ],test_requires=>[qw/test requires/ ],test_recommends=>[qw/test recommends/ ],recommends=>[qw/runtime recommends/ ],conflicts=>[qw/runtime conflicts/ ],);sub _normalize_prereqs {my ($self)=@_;my$p=$self->{properties};my%prereq_types;for my$type ('configure_requires',@{$self->prereq_action_types}){if (exists$p->{$type}and keys %{$p->{$type}}){my ($phase,$relation)=@{$prereq_map{$type}};for my$mod (keys %{$p->{$type}}){$prereq_types{$phase}{$relation}{$mod}=$self->normalize_version($p->{$type}{$mod})}}}return \%prereq_types}sub _get_license {my$self=shift;my$license=$self->license;my ($meta_license,$meta_license_url);my$valid_licenses=$self->valid_licenses();if (my$sl=$self->_software_license_object){$meta_license=$sl->meta2_name;$meta_license_url=$sl->url}elsif (exists$valid_licenses->{$license}){$meta_license=$valid_licenses->{$license}? lc$valid_licenses->{$license}: $license;$meta_license_url=$self->_license_url($license)}else {$self->log_warn("Can not determine license type for '" .$self->license ."'\nSetting META license field to 'unknown'.\n");$meta_license='unknown'}return ($meta_license,$meta_license_url)}sub get_metadata {my ($self,%args)=@_;my$fatal=$args{fatal}|| 0;my$p=$self->{properties};$self->auto_config_requires if$args{auto};for my$f (qw(dist_name dist_version dist_author dist_abstract license)){my$field=$self->$f();unless (defined$field and length$field){my$err="ERROR: Missing required field '$f' for metafile\n";if ($fatal){die$err}else {$self->log_warn($err)}}}my%metadata=(name=>$self->dist_name,version=>$self->normalize_version($self->dist_version),author=>$self->dist_author,abstract=>$self->dist_abstract,generated_by=>"Module::Build version $Module::Build::VERSION",'meta-spec'=>{version=>'2',url=>'http://search.cpan.org/perldoc?CPAN::Meta::Spec',},dynamic_config=>exists$p->{dynamic_config}? $p->{dynamic_config}: 1,release_status=>$self->release_status,);my ($meta_license,$meta_license_url)=$self->_get_license;$metadata{license}=[$meta_license ];$metadata{resources}{license}=[$meta_license_url ]if defined$meta_license_url;$metadata{prereqs}=$self->_normalize_prereqs;if (exists$p->{no_index}){$metadata{no_index}=$p->{no_index}}elsif (my$pkgs=eval {$self->find_dist_packages}){$metadata{provides}=$pkgs if %$pkgs}else {$self->log_warn("$@\nWARNING: Possible missing or corrupt 'MANIFEST' file.\n" ."Nothing to enter for 'provides' field in metafile.\n")}if (my$add=$self->meta_add){if (not exists$add->{'meta-spec'}or $add->{'meta-spec'}{version}!=2){require CPAN::Meta::Converter;if (CPAN::Meta::Converter->VERSION('2.141170')){$add=CPAN::Meta::Converter->new($add)->upgrade_fragment;delete$add->{prereqs}}else {$self->log_warn("Can't meta_add without CPAN::Meta 2.141170")}}while (my($k,$v)=each %{$add}){$metadata{$k}=$v}}if (my$merge=$self->meta_merge){if (eval {require CPAN::Meta::Merge}){%metadata=%{CPAN::Meta::Merge->new(default_version=>'1.4')->merge(\%metadata,$merge)}}else {$self->log_warn("Can't merge without CPAN::Meta::Merge")}}return \%metadata}sub prepare_metadata {my ($self,$node,$keys,$args)=@_;unless (ref$node eq 'HASH'){croak "prepare_metadata() requires a hashref argument to hold output\n"}croak 'Keys argument to prepare_metadata is no longer supported' if$keys;%{$node}=%{$self->get_meta(%{$args})};return$node}sub _read_manifest {my ($self,$file)=@_;return undef unless -e $file;require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);return scalar ExtUtils::Manifest::maniread($file)}sub find_dist_packages {my$self=shift;my$manifest=$self->_read_manifest('MANIFEST')or die "Can't find dist packages without a MANIFEST file\nRun 'Build manifest' to generate one\n";my%dist_files=map {$self->localize_file_path($_)=>$_}keys %$manifest;my@pm_files=sort grep {$_ !~ m{^t}}grep {exists$dist_files{$_}}keys %{$self->find_pm_files};return$self->find_packages_in_files(\@pm_files,\%dist_files)}sub find_packages_in_files {my ($self,$file_list,$filename_map)=@_;my(%prime,%alt);for my$file (@{$file_list}){my$mapped_filename=$filename_map->{$file};my@path=split(/\//,$mapped_filename);(my$prime_package=join('::',@path[1..$#path]))=~ s/\.pm$//;my$pm_info=Module::Metadata->new_from_file($file);for my$package ($pm_info->packages_inside){next if$package eq 'main';next if$package eq 'DB';next if grep /^_/,split(/::/,$package);my$version=$pm_info->version($package);if ($package eq $prime_package){if (exists($prime{$package})){die "Unexpected conflict in '$package'; multiple versions found.\n"}else {$prime{$package}{file}=$mapped_filename;$prime{$package}{version}=$version if defined($version)}}else {push(@{$alt{$package}},{file=>$mapped_filename,version=>$version,})}}}for my$package (sort keys(%alt)){my$result=$self->_resolve_module_versions($alt{$package});if (exists($prime{$package})){if ($result->{err}){$self->log_warn("Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" .$result->{err})}elsif (defined($result->{version})){if (exists($prime{$package}{version})&& defined($prime{$package}{version})){if ($self->compare_versions($prime{$package}{version},'!=',$result->{version})){$self->log_warn("Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" ."  $result->{file} ($result->{version})\n")}}else {$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}}}else {}}else {if ($result->{err}){$self->log_warn("Found conflicting versions for package '$package'\n" .$result->{err})}$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}if defined($result->{version})}}for my$provides (values%prime){if ($provides->{version}){$provides->{version}=$self->normalize_version($provides->{version})}else {delete$provides->{version}}}return \%prime}sub _resolve_module_versions {my$self=shift;my$packages=shift;my($file,$version);my$err='';for my$p (@$packages){if (defined($p->{version})){if (defined($version)){if ($self->compare_versions($version,'!=',$p->{version})){$err .= "  $p->{file} ($p->{version})\n"}else {}}else {$file=$p->{file};$version=$p->{version}}}$file ||= $p->{file}if defined($p->{file})}if ($err){$err="  $file ($version)\n" .$err}my%result=(file=>$file,version=>$version,err=>$err);return \%result}sub make_tarball {my ($self,$dir,$file)=@_;$file ||= $dir;$self->log_info("Creating $file.tar.gz\n");if ($self->{args}{tar}){my$tar_flags=$self->verbose ? 'cvf' : 'cf';$self->do_system($self->split_like_shell($self->{args}{tar}),$tar_flags,"$file.tar",$dir);$self->do_system($self->split_like_shell($self->{args}{gzip}),"$file.tar")if$self->{args}{gzip}}else {eval {require Archive::Tar && Archive::Tar->VERSION(1.09);1}or die "You must install Archive::Tar 1.09+ to make a distribution tarball\n"."or specify a binary tar program with the '--tar' option.\n"."See the documentation for the 'dist' action.\n";my$files=$self->rscan_dir($dir);$Archive::Tar::DO_NOT_USE_PREFIX=(grep {length($_)>= 100}@$files)? 0 : 1;my$tar=Archive::Tar->new;$tar->add_files(@$files);for my$f ($tar->get_files){$f->mode($f->mode & ~022)}$tar->write("$file.tar.gz",1)}}sub install_path {my$self=shift;my($type,$value)=(@_,'<empty>');Carp::croak('Type argument missing')unless defined($type);my$map=$self->{properties}{install_path};return$map unless @_;unless (defined($value)){delete($map->{$type});return undef}if ($value eq '<empty>'){return undef unless exists$map->{$type};return$map->{$type}}return$map->{$type}=$value}sub install_sets {my ($self,$dirs,$key,$value)=@_;$dirs=$self->installdirs unless defined$dirs;if (@_==4 && defined$dirs && defined$key){$self->{properties}{install_sets}{$dirs}{$key}=$value}my$map={$self->_merge_arglist($self->{properties}{install_sets},$self->_default_install_paths->{install_sets})};if (defined$dirs && defined$key){return$map->{$dirs}{$key}}elsif (defined$dirs){return$map->{$dirs}}else {croak "Can't determine installdirs for install_sets()"}}sub original_prefix {my ($self,$key,$value)=@_;if (@_==3 && defined$key){$self->{properties}{original_prefix}{$key}=$value}my$map={$self->_merge_arglist($self->{properties}{original_prefix},$self->_default_install_paths->{original_prefix})};return$map unless defined$key;return$map->{$key}}sub install_base_relpaths {my$self=shift;if (@_ > 1){$self->_set_relpaths($self->{properties}{install_base_relpaths},@_)}my$map={$self->_merge_arglist($self->{properties}{install_base_relpaths},$self->_default_install_paths->{install_base_relpaths})};return$map unless @_;my$relpath=$map->{$_[0]};return defined$relpath ? File::Spec->catdir(@$relpath): undef}sub prefix_relpaths {my$self=shift;my$installdirs=shift || $self->installdirs or croak "Can't determine installdirs for prefix_relpaths()";if (@_ > 1){$self->{properties}{prefix_relpaths}{$installdirs}||= {};$self->_set_relpaths($self->{properties}{prefix_relpaths}{$installdirs},@_)}my$map={$self->_merge_arglist($self->{properties}{prefix_relpaths}{$installdirs},$self->_default_install_paths->{prefix_relpaths}{$installdirs})};return$map unless @_;my$relpath=$map->{$_[0]};return defined$relpath ? File::Spec->catdir(@$relpath): undef}sub _set_relpaths {my$self=shift;my($map,$type,$value)=@_;Carp::croak('Type argument missing')unless defined($type);if (!defined($value)){$map->{$type}=undef;return}else {Carp::croak("Value must be a relative path")if File::Spec::Unix->file_name_is_absolute($value);my@value=split(/\//,$value);$map->{$type}=\@value}}sub prefix_relative {my ($self,$type)=@_;my$installdirs=$self->installdirs;my$relpath=$self->install_sets($installdirs)->{$type};return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type,)}sub _prefixify {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m|/$|;$self->log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined($path)&& length($path);if(!defined($path)|| (length($path)==0)){$self->log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->log_verbose("    now $path in $rprefix\n");return$path}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return$default}}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,$relpath): undef}if ($self->prefix){my$relpath=$self->prefix_relative($type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs)->{$type}}sub install_types {my$self=shift;my%types;if ($self->install_base){%types=%{$self->install_base_relpaths}}elsif ($self->prefix){%types=%{$self->prefix_relpaths}}else {%types=%{$self->install_sets($self->installdirs)}}%types=(%types,%{$self->install_path});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my(%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push(@skipping,$type)}}$self->log_warn("WARNING: Can't figure out install path for types: @skipping\n" ."Files will not be installed.\n")if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}sub depends_on {my$self=shift;for my$action (@_){$self->_call_action($action)}}sub rscan_dir {my ($self,$dir,$pattern)=@_;my@result;local $_;my$subr=!$pattern ? sub {push@result,$File::Find::name}: !ref($pattern)|| (ref$pattern eq 'Regexp')? sub {push@result,$File::Find::name if /$pattern/}: ref($pattern)eq 'CODE' ? sub {push@result,$File::Find::name if$pattern->()}: die "Unknown pattern type";File::Find::find({wanted=>$subr,no_chdir=>1,preprocess=>sub {sort @_}},$dir);return \@result}sub delete_filetree {my$self=shift;my$deleted=0;for (@_){next unless -e $_;$self->log_verbose("Deleting $_\n");File::Path::rmtree($_,0,0);die "Couldn't remove '$_': $!\n" if -e $_;$deleted++}return$deleted}sub autosplit_file {my ($self,$file,$to)=@_;require AutoSplit;my$dir=File::Spec->catdir($to,'lib','auto');AutoSplit::autosplit($file,$dir)}sub cbuilder {my$self=shift;my$s=$self->{stash};return$s->{_cbuilder}if$s->{_cbuilder};require ExtUtils::CBuilder;return$s->{_cbuilder}=ExtUtils::CBuilder->new(config=>$self->config,($self->quiet ? (quiet=>1): ()),)}sub have_c_compiler {my ($self)=@_;my$p=$self->{properties};return$p->{_have_c_compiler}if defined$p->{_have_c_compiler};$self->log_verbose("Checking if compiler tools configured... ");my$b=$self->cbuilder;my$have=$b && eval {$b->have_compiler};$self->log_verbose($have ? "ok.\n" : "failed.\n");return$p->{_have_c_compiler}=$have}sub compile_c {my ($self,$file,%args)=@_;if (!$self->have_c_compiler){die "Error: no compiler detected to compile '$file'.  Aborting\n"}my$b=$self->cbuilder;my$obj_file=$b->object_file($file);$self->add_to_cleanup($obj_file);return$obj_file if$self->up_to_date($file,$obj_file);$b->compile(source=>$file,defines=>$args{defines},object_file=>$obj_file,include_dirs=>$self->include_dirs,extra_compiler_flags=>$self->extra_compiler_flags,);return$obj_file}sub link_c {my ($self,$spec)=@_;my$p=$self->{properties};$self->add_to_cleanup($spec->{lib_file});my$objects=$p->{objects}|| [];return$spec->{lib_file}if$self->up_to_date([$spec->{obj_file},@$objects],$spec->{lib_file});my$module_name=$spec->{module_name}|| $self->module_name;$self->cbuilder->link(module_name=>$module_name,objects=>[$spec->{obj_file},@$objects],lib_file=>$spec->{lib_file},extra_linker_flags=>$self->extra_linker_flags);return$spec->{lib_file}}sub compile_xs {my ($self,$file,%args)=@_;$self->log_verbose("$file -> $args{outfile}\n");if (eval {require ExtUtils::ParseXS;1}){ExtUtils::ParseXS::process_file(filename=>$file,prototypes=>0,output=>$args{outfile},)}else {my$xsubpp=Module::Metadata->find_module_by_name('ExtUtils::xsubpp')or die "Can't find ExtUtils::xsubpp in INC (@INC)";my@typemaps;push@typemaps,Module::Metadata->find_module_by_name('ExtUtils::typemap',\@INC);my$lib_typemap=Module::Metadata->find_module_by_name('typemap',[File::Basename::dirname($file),File::Spec->rel2abs('.')]);push@typemaps,$lib_typemap if$lib_typemap;@typemaps=map {+'-typemap',$_}@typemaps;my$cf=$self->{config};my$perl=$self->{properties}{perl};my@command=($perl,"-I".$cf->get('installarchlib'),"-I".$cf->get('installprivlib'),$xsubpp,'-noprototypes',@typemaps,$file);$self->log_info("@command\n");open(my$fh,'>',$args{outfile})or die "Couldn't write $args{outfile}: $!";print {$fh}$self->_backticks(@command);close$fh}}sub split_like_shell {my ($self,$string)=@_;return ()unless defined($string);return @$string if ref$string eq 'ARRAY';$string =~ s/^\s+|\s+$//g;return ()unless length($string);return Text::ParseWords::shellwords($string)}sub oneliner {my($self,$cmd,$switches,$args)=@_;$switches=[]unless defined$switches;$args=[]unless defined$args;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;return$self->_quote_args($perl,@$switches,'-e',$cmd,@$args)}sub run_perl_script {my ($self,$script,$preargs,$postargs)=@_;for ($preargs,$postargs){$_=[$self->split_like_shell($_)]unless ref()}return$self->run_perl_command([@$preargs,$script,@$postargs])}sub run_perl_command {my ($self,$args)=@_;$args=[$self->split_like_shell($args)]unless ref($args);my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;local$ENV{PERL5LIB}=join$self->config('path_sep'),$self->_added_to_INC;return$self->do_system($perl,@$args)}sub _infer_xs_spec {my$self=shift;my$file=shift;my$cf=$self->{config};my%spec;my($v,$d,$f)=File::Spec->splitpath($file);my@d=File::Spec->splitdir($d);(my$file_base=$f)=~ s/\.[^.]+$//i;$spec{base_name}=$file_base;$spec{src_dir}=File::Spec->catpath($v,$d,'');shift(@d)while@d && ($d[0]eq 'lib' || $d[0]eq '');pop(@d)while@d && $d[-1]eq '';$spec{module_name}=join('::',(@d,$file_base));$spec{archdir}=File::Spec->catdir($self->blib,'arch','auto',@d,$file_base);$spec{c_file}=File::Spec->catfile($spec{src_dir},"${file_base}.c");$spec{obj_file}=File::Spec->catfile($spec{src_dir},"${file_base}".$cf->get('obj_ext'));require DynaLoader;my$modfname=defined&DynaLoader::mod2fname ? DynaLoader::mod2fname([@d,$file_base]): $file_base;$spec{bs_file}=File::Spec->catfile($spec{archdir},"$modfname.bs");$spec{lib_file}=File::Spec->catfile($spec{archdir},"$modfname.".$cf->get('dlext'));return \%spec}sub process_xs {my ($self,$file)=@_;my$spec=$self->_infer_xs_spec($file);(my$file_base=$file)=~ s/\.[^.]+$//;$self->add_to_cleanup($spec->{c_file});unless ($self->up_to_date($file,$spec->{c_file})){$self->compile_xs($file,outfile=>$spec->{c_file})}my$v=$self->dist_version;$self->compile_c($spec->{c_file},defines=>{VERSION=>qq{"$v"},XS_VERSION=>qq{"$v"}});File::Path::mkpath($spec->{archdir},0,oct(777))unless -d $spec->{archdir};$self->add_to_cleanup($spec->{bs_file});unless ($self->up_to_date($file,$spec->{bs_file})){require ExtUtils::Mkbootstrap;$self->log_info("ExtUtils::Mkbootstrap::Mkbootstrap('$spec->{bs_file}')\n");ExtUtils::Mkbootstrap::Mkbootstrap($spec->{bs_file});open(my$fh,'>>',$spec->{bs_file});utime((time)x2,$spec->{bs_file})}$self->link_c($spec)}sub do_system {my ($self,@cmd)=@_;$self->log_verbose("@cmd\n");my%seen;my$sep=$self->config('path_sep');local$ENV{PERL5LIB}=(!exists($ENV{PERL5LIB})? '' : length($ENV{PERL5LIB})< 500 ? $ENV{PERL5LIB}: join$sep,grep {!$seen{$_}++ and -d $_}split($sep,$ENV{PERL5LIB}));my$status=system(@cmd);if ($status and $! =~ /Argument list too long/i){my$env_entries='';for (sort keys%ENV){$env_entries .= "$_=>".length($ENV{$_})."; "}warn "'Argument list' was 'too long', env lengths are $env_entries"}return!$status}sub copy_if_modified {my$self=shift;my%args=(@_ > 3 ? (@_): (from=>shift,to_dir=>shift,flatten=>shift));$args{verbose}=!$self->quiet unless exists$args{verbose};my$file=$args{from};unless (defined$file and length$file){die "No 'from' parameter given to copy_if_modified"}$args{flatten}=1 if File::Spec->file_name_is_absolute($file);my$to_path;if (defined$args{to}and length$args{to}){$to_path=$args{to}}elsif (defined$args{to_dir}and length$args{to_dir}){$to_path=File::Spec->catfile($args{to_dir},$args{flatten}? File::Basename::basename($file): $file)}else {die "No 'to' or 'to_dir' parameter given to copy_if_modified"}return if$self->up_to_date($file,$to_path);{local$self->{properties}{quiet}=1;$self->delete_filetree($to_path)}File::Path::mkpath(File::Basename::dirname($to_path),0,oct(777));$self->log_verbose("Copying $file -> $to_path\n");if ($^O eq 'os2'){chmod 0666,$to_path;File::Copy::syscopy($file,$to_path,0x1)or die "Can't copy('$file', '$to_path'): $!"}else {File::Copy::copy($file,$to_path)or die "Can't copy('$file', '$to_path'): $!"}my$mode=oct(444)| ($self->is_executable($file)? oct(111): 0);chmod($mode,$to_path);return$to_path}sub up_to_date {my ($self,$source,$derived)=@_;$source=[$source]unless ref$source;$derived=[$derived]unless ref$derived;return 0 if @$source &&!@$derived || grep {not -e}@$derived;my$most_recent_source=time / (24*60*60);for my$file (@$source){unless (-e $file){$self->log_warn("Can't find source file $file for up-to-date check");next}$most_recent_source=-M _ if -M _ < $most_recent_source}for my$derived (@$derived){return 0 if -M $derived > $most_recent_source}return 1}sub dir_contains {my ($self,$first,$second)=@_;($first,$second)=map File::Spec->canonpath($_),($first,$second);my@first_dirs=File::Spec->splitdir($first);my@second_dirs=File::Spec->splitdir($second);return 0 if@second_dirs < @first_dirs;my$is_same=($self->_case_tolerant ? sub {lc(shift())eq lc(shift())}: sub {shift()eq shift()});while (@first_dirs){return 0 unless$is_same->(shift@first_dirs,shift@second_dirs)}return 1}1;
  
  ERRORS/WARNINGS FOUND IN PREREQUISITES.  You may wish to install the versions
  of the modules indicated above before proceeding with this installation
  
  EOF
  * FATAL ERROR: Perl interpreter mismatch. Configuration was initially
    created with '$self->{properties}{perl}'
    but we are now using '$perl'.  You must
    run 'Build realclean' or 'make realclean' and re-configure.
  DIEFATAL
  * WARNING: Configuration was initially created with Module::Build
    version '$self->{properties}{mb_version}' but we are now using version '$mb_version'.
    If errors occur, you must re-run the Build.PL or Makefile.PL script.
  MISMATCH
  ERROR: This build seems to be unattended, but there is no default value
  for this question.  Aborting.
  EOF
  package $opts{class};
  use $pack;
  \@ISA = qw($pack);
  $opts{code}
  1;
  EOF
  No 'module_name' was provided and it could not be inferred
  from other properties.  This will prevent a packlist from
  being written for this file.  Please set either 'module_name'
  or 'dist_version_from' in Build.PL.
  END_WARN
  Bundling in inc/ is disabled because ExtUtils::Installed could not
  create a list of your installed modules.  Here is the error:
  $@
  EUI_ERROR
  Could not find a packlist for '$mod'.  If it's a core module, try
  force installing it from CPAN.
  NO_PACKLIST
  Module::Build was not found in configure_requires! Adding it now
  automatically as: configure_requires => { 'Module::Build' => $ver }
  EOM
  Warning: ExtUtils::CBuilder not installed or no compiler detected
  Proceeding with configuration, but compilation may fail during Build
  
  EOM
      if ($INC[-1] ne '.') {
          push @INC, '.';
      }
  END
  $shebang
  
  use strict;
  use Cwd;
  use File::Basename;
  use File::Spec;
  
  sub magic_number_matches {
    return 0 unless -e '$q{magic_numfile}';
    my \$FH;
    open \$FH, '<','$q{magic_numfile}' or return 0;
    my \$filenum = <\$FH>;
    close \$FH;
    return \$filenum == $magic_number;
  }
  
  my \$progname;
  my \$orig_dir;
  BEGIN {
    \$^W = 1;  # Use warnings
    \$progname = basename(\$0);
    \$orig_dir = Cwd::cwd();
    my \$base_dir = '$q{base_dir}';
    if (!magic_number_matches()) {
      unless (chdir(\$base_dir)) {
        die ("Couldn't chdir(\$base_dir), aborting\\n");
      }
      unless (magic_number_matches()) {
        die ("Configuration seems to be out of date, please re-run 'perl Build.PL' again.\\n");
      }
    }
    unshift \@INC,
      (
  $quoted_INC
      );
  $dot_in_inc_code
  }
  
  close(*DATA) unless eof(*DATA); # ensure no open handles to this script
  
  use $build_package;
  Module::Build->VERSION(q{$config_requires});
  
  # Some platforms have problems setting \$^X in shebang contexts, fix it up here
  \$^X = Module::Build->find_perl_interpreter;
  
  if (-e 'Build.PL' and not $build_package->up_to_date('Build.PL', \$progname)) {
     warn "Warning: Build.PL has been altered.  You may need to run 'perl Build.PL' again.\\n";
  }
  
  # This should have just enough arguments to be able to bootstrap the rest.
  my \$build = $build_package->resume (
    properties => {
      config_dir => '$q{config_dir}',
      orig_dir => \$orig_dir,
    },
  );
  
  \$build->dispatch;
  EOF
  
   Usage: $0 <action> --arg1=value --arg2=value ...
   Example: $0 test --verbose=1
  
   Actions defined:
  EOF
  Can't create LICENSE file: '$l' is not a valid license key
  or Software::License subclass;
  HERE
  Cannot create README: can't determine which file contains documentation;
  Must supply either 'dist_version_from', or 'module_name' parameter.
  EOF
  # Avoid configuration metadata file
  ^MYMETA\.
  
  # Avoid Module::Build generated and utility files.
  \bBuild$
  \bBuild.bat$
  \b_build
  \bBuild.COM$
  \bBUILD.COM$
  \bbuild.com$
  ^MANIFEST\.SKIP
  
  # Avoid archives of this distribution
  EOF
MODULE_BUILD_BASE

$fatpacked{"Module/Build/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COMPAT';
  package Module::Build::Compat;use strict;use warnings;our$VERSION='0.4224';use File::Basename ();use File::Spec;use Config;use Module::Build;use Module::Metadata;use version;use Data::Dumper;my%convert_installdirs=(PERL=>'core',SITE=>'site',VENDOR=>'vendor',);my%makefile_to_build=(TEST_VERBOSE=>'verbose',VERBINST=>'verbose',INC=>sub {map {(extra_compiler_flags=>$_)}Module::Build->split_like_shell(shift)},POLLUTE=>sub {(extra_compiler_flags=>'-DPERL_POLLUTE')},INSTALLDIRS=>sub {(installdirs=>$convert_installdirs{uc shift()})},LIB=>sub {my$lib=shift;my%config=(installprivlib=>$lib,installsitelib=>$lib,installarchlib=>"$lib/$Config{archname}",installsitearch=>"$lib/$Config{archname}");return map {(config=>"$_=$config{$_}")}sort keys%config},(map {my$name=$_;$name=>sub {my@ret=(config=>lc($name)."=" .shift);print STDERR "# Converted to @ret\n";return@ret}}qw(INSTALLARCHLIB INSTALLSITEARCH INSTALLVENDORARCH INSTALLPRIVLIB INSTALLSITELIB INSTALLVENDORLIB INSTALLBIN INSTALLSITEBIN INSTALLVENDORBIN INSTALLSCRIPT INSTALLSITESCRIPT INSTALLVENDORSCRIPT INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR)),map {$_,lc($_)}qw(DESTDIR PREFIX INSTALL_BASE UNINST),);my%macro_to_build=%makefile_to_build;delete$macro_to_build{LIB};sub _merge_prereq {my ($req,$breq)=@_;$req ||= {};$breq ||= {};for my$p ($req,$breq){for my$k (sort keys %$p){next if$k eq 'perl';my$v_obj=eval {version->new($p->{$k})};if (!defined$v_obj){die "A prereq of the form '$p->{$k}' for '$k' is not supported by Module::Build::Compat ( use a simpler version like '0.05' or 'v1.4.25' )\n"}if ($v_obj->is_qv){my$proper_ver=$v_obj->numify;warn "Dotted-decimal prereq '$p->{$k}' for '$k' is not portable - converting it to '$proper_ver'\n";$p->{$k}=$proper_ver}}}my$merge={%$req };for my$k (keys %$breq){my$v1=$merge->{$k}|| 0;my$v2=$breq->{$k};$merge->{$k}=$v1 > $v2 ? $v1 : $v2}return %$merge}sub create_makefile_pl {my ($package,$type,$build,%args)=@_;die "Don't know how to build Makefile.PL of type '$type'" unless$type =~ /^(small|passthrough|traditional)$/;if ($type eq 'passthrough'){$build->log_warn(<<"HERE")}my$fh;if ($args{fh}){$fh=$args{fh}}else {$args{file}||= 'Makefile.PL';local$build->{properties}{quiet}=1;$build->delete_filetree($args{file});open($fh,'>',"$args{file}")or die "Can't write $args{file}: $!"}print {$fh}"# Note: this file was auto-generated by ",__PACKAGE__," version $VERSION\n";my$requires=$build->requires;if (my$minimum_perl=$requires->{perl}){my$min_ver=version->new($minimum_perl)->numify;print {$fh}"require $min_ver;\n"}my$subclass_load='';if (ref($build)ne "Module::Build"){my$subclass_dir=$package->subclass_dir($build);if (File::Spec->file_name_is_absolute($subclass_dir)){my$base_dir=$build->base_dir;if ($build->dir_contains($base_dir,$subclass_dir)){$subclass_dir=File::Spec->abs2rel($subclass_dir,$base_dir);$subclass_dir=$package->unixify_dir($subclass_dir);$subclass_load="use lib '$subclass_dir';"}}else {$subclass_dir=$package->unixify_dir($subclass_dir);$subclass_load="use lib '$subclass_dir';"}}if ($type eq 'small'){printf {$fh}<<'EOF',$subclass_load,ref($build),ref($build)}elsif ($type eq 'passthrough'){printf {$fh}<<'EOF',$subclass_load,ref($build),ref($build)}elsif ($type eq 'traditional'){my (%MM_Args,%prereq);if (eval "use Tie::IxHash 1.2; 1"){tie%MM_Args,'Tie::IxHash';tie%prereq,'Tie::IxHash'}my%name=($build->module_name ? (NAME=>$build->module_name): (DISTNAME=>$build->dist_name));my%version=($build->dist_version_from ? (VERSION_FROM=>$build->dist_version_from): (VERSION=>$build->dist_version));%MM_Args=(%name,%version);%prereq=_merge_prereq($build->requires,$build->build_requires);%prereq=map {$_,$prereq{$_}}sort keys%prereq;delete$prereq{perl};$MM_Args{PREREQ_PM}=\%prereq;$MM_Args{INSTALLDIRS}=$build->installdirs eq 'core' ? 'perl' : $build->installdirs;$MM_Args{EXE_FILES}=[sort keys %{$build->script_files}]if$build->script_files;$MM_Args{PL_FILES}=$build->PL_files || {};if ($build->recursive_test_files){$MM_Args{test}={TESTS=>join q{ },$package->_test_globs($build)}}local$Data::Dumper::Terse=1;my$args=Data::Dumper::Dumper(\%MM_Args);$args =~ s/\{(.*)\}/($1)/s;print$fh <<"EOF"}}sub _test_globs {my ($self,$build)=@_;return map {File::Spec->catfile($_,'*.t')}@{$build->rscan_dir('t',sub {-d $File::Find::name})}}sub subclass_dir {my ($self,$build)=@_;return (Module::Metadata->find_module_dir_by_name(ref$build)|| File::Spec->catdir($build->config_dir,'lib'))}sub unixify_dir {my ($self,$path)=@_;return join '/',File::Spec->splitdir($path)}sub makefile_to_build_args {my$class=shift;my@out;for my$arg (@_){next if$arg eq '';my ($key,$val)=($arg =~ /^(\w+)=(.+)/ ? ($1,$2): die "Malformed argument '$arg'");($val)=Module::Build->_detildefy($val)if$val =~ /^~/;if (exists$makefile_to_build{$key}){my$trans=$makefile_to_build{$key};push@out,$class->_argvify(ref($trans)? $trans->($val): ($trans=>$val))}elsif (exists$Config{lc($key)}){push@out,$class->_argvify(config=>lc($key)."=$val")}else {push@out,$class->_argvify("\L$key"=>$val)}}return@out}sub _argvify {my ($self,@pairs)=@_;my@out;while (@pairs){my ($k,$v)=splice@pairs,0,2;push@out,("--$k",$v)}return@out}sub makefile_to_build_macros {my@out;my%config;for my$macro (sort keys%macro_to_build){my$trans=$macro_to_build{$macro};next unless exists$ENV{$macro}&& length$ENV{$macro};my$val=$ENV{$macro};my@args=ref($trans)? $trans->($val): ($trans=>$val);while (@args){my ($k,$v)=splice(@args,0,2);if ($k eq 'config'){if ($v =~ /^([^=]+)=(.*)$/){$config{$1}=$2}else {warn "Couldn't parse config '$v'\n"}}else {push@out,($k=>$v)}}}push@out,(config=>\%config)if%config;return@out}sub run_build_pl {my ($pack,%in)=@_;$in{script}||= 'Build.PL';my@args=$in{args}? $pack->makefile_to_build_args(@{$in{args}}): ();print "# running $in{script} @args\n";Module::Build->run_perl_script($in{script},[],\@args)or die "Couldn't run $in{script}: $!"}sub fake_makefile {my ($self,%args)=@_;unless (exists$args{build_class}){warn "Unknown 'build_class', defaulting to 'Module::Build'\n";$args{build_class}='Module::Build'}my$class=$args{build_class};my$perl=$class->find_perl_interpreter;$perl='MCR ' .$perl if$self->_is_vms_mms;my$noop=($class->is_windowsish ? 'rem>nul' : $self->_is_vms_mms ? 'Continue' : 'true');my$filetype=$class->is_vmsish ? '.COM' : '';my$Build='Build' .$filetype .' --makefile_env_macros 1';my$unlink=$class->oneliner('1 while unlink $ARGV[0]',[],[$args{makefile}]);$unlink =~ s/\$/\$\$/g unless$class->is_vmsish;my$maketext=join '',map {"$_=\n"}sort keys%macro_to_build;$maketext .= ($^O eq 'os2' ? "SHELL = sh\n\n" : $^O eq 'MSWin32' && $Config{make}=~ /gmake/ ? "SHELL = $ENV{COMSPEC}\n\n" : "\n\n");$maketext .= <<"EOF";for my$action ($class->known_actions){next if$action =~ /^(all|distclean|realclean|force_do_it)$/;$maketext .= <<"EOF"}if ($self->_is_vms_mms){$maketext .= "\n.FIRST\n\t\@ $noop\n";for my$macro (sort keys%macro_to_build){$maketext .= ".IFDEF $macro\n\tDEFINE $macro \"\$($macro)\"\n.ENDIF\n"}$maketext .= "\n"}else {$maketext .= "\n.EXPORT : " .join(' ',sort keys%macro_to_build)."\n\n"}return$maketext}sub fake_prereqs {my$file=File::Spec->catfile('_build','prereqs');open(my$fh,'<',"$file")or die "Can't read $file: $!";my$prereqs=eval do {local $/;<$fh>};close$fh;my%merged=_merge_prereq($prereqs->{requires},$prereqs->{build_requires});my@prereq;for (sort keys%merged){next if $_ eq 'perl';push@prereq,"$_=>q[$merged{$_}]"}return unless@prereq;return "#     PREREQ_PM => { " .join(", ",@prereq)." }\n\n"}sub write_makefile {my ($pack,%in)=@_;unless (exists$in{build_class}){warn "Unknown 'build_class', defaulting to 'Module::Build'\n";$in{build_class}='Module::Build'}my$class=$in{build_class};$in{makefile}||= $pack->_is_vms_mms ? 'Descrip.MMS' : 'Makefile';open MAKE,"> $in{makefile}" or die "Cannot write $in{makefile}: $!";print MAKE$pack->fake_prereqs;print MAKE$pack->fake_makefile(%in);close MAKE}sub _is_vms_mms {return Module::Build->is_vmsish && ($Config{make}=~ m/MM[SK]/i)}1;
  
  IMPORTANT NOTE: The '$type' style of Makefile.PL is deprecated and
  may be removed in a future version of Module::Build in favor of the
  'configure_requires' property.  See Module::Build::Compat
  documentation for details.
  
  HERE
      use Module::Build::Compat 0.02;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  
      unless (eval "use Module::Build::Compat 0.02; 1" ) {
        print "This module requires Module::Build to install itself.\n";
  
        require ExtUtils::MakeMaker;
        my $yn = ExtUtils::MakeMaker::prompt
  	('  Install Module::Build now from CPAN?', 'y');
  
        unless ($yn =~ /^y/i) {
  	die " *** Cannot install without Module::Build.  Exiting ...\n";
        }
  
        require Cwd;
        require File::Spec;
        require CPAN;
  
        # Save this 'cause CPAN will chdir all over the place.
        my $cwd = Cwd::cwd();
  
        CPAN::Shell->install('Module::Build::Compat');
        CPAN::Shell->expand("Module", "Module::Build::Compat")->uptodate
  	or die "Couldn't install Module::Build, giving up.\n";
  
        chdir $cwd or die "Cannot chdir() back to $cwd: $!";
      }
      eval "use Module::Build::Compat 0.02; 1" or die $@;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      my $build_script = 'Build';
      $build_script .= '.com' if $^O eq 'VMS';
      exit(0) unless(-e $build_script); # cpantesters convention
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  use ExtUtils::MakeMaker;
  WriteMakefile
  $args;
  EOF
  all : force_do_it
  	$perl $Build
  realclean : force_do_it
  	$perl $Build realclean
  	$unlink
  distclean : force_do_it
  	$perl $Build distclean
  	$unlink
  
  
  force_do_it :
  	@ $noop
  EOF
  $action : force_do_it
  	$perl $Build $action
  EOF
MODULE_BUILD_COMPAT

$fatpacked{"Module/Build/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIG';
  package Module::Build::Config;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Config;sub new {my ($pack,%args)=@_;return bless {stack=>{},values=>$args{values}|| {},},$pack}sub get {my ($self,$key)=@_;return$self->{values}{$key}if ref($self)&& exists$self->{values}{$key};return$Config{$key}}sub set {my ($self,$key,$val)=@_;$self->{values}{$key}=$val}sub push {my ($self,$key,$val)=@_;push @{$self->{stack}{$key}},$self->{values}{$key}if exists$self->{values}{$key};$self->{values}{$key}=$val}sub pop {my ($self,$key)=@_;my$val=delete$self->{values}{$key};if (exists$self->{stack}{$key}){$self->{values}{$key}=pop @{$self->{stack}{$key}};delete$self->{stack}{$key}unless @{$self->{stack}{$key}}}return$val}sub values_set {my$self=shift;return undef unless ref($self);return$self->{values}}sub all_config {my$self=shift;my$v=ref($self)? $self->{values}: {};return {%Config,%$v}}1;
MODULE_BUILD_CONFIG

$fatpacked{"Module/Build/ConfigData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIGDATA';
  package Module::Build::ConfigData;use strict;my$arrayref=eval do {local $/;<DATA>}or die "Couldn't load ConfigData data: $@";close DATA;my ($config,$features,$auto_features)=@$arrayref;sub config {$config->{$_[1]}}sub set_config {$config->{$_[1]}=$_[2]}sub set_feature {$features->{$_[1]}=0+!!$_[2]}sub auto_feature_names {sort grep!exists$features->{$_},keys %$auto_features}sub feature_names {my@features=(sort keys %$features,auto_feature_names());@features}sub config_names {sort keys %$config}sub write {my$me=__FILE__;require Data::Dumper;my$mode_orig=(stat$me)[2]& 07777;chmod($mode_orig | 0222,$me);open(my$fh,'+<',$me)or die "Can't rewrite $me: $!";seek($fh,0,0);while (<$fh>){last if /^__DATA__$/}die "Couldn't find __DATA__ token in $me" if eof($fh);seek($fh,tell($fh),0);my$data=[$config,$features,$auto_features];print($fh 'do{ my ' .Data::Dumper->new([$data],['x'])->Purity(1)->Dump().'$x; }');truncate($fh,tell($fh));close$fh;chmod($mode_orig,$me)or warn "Couldn't restore permissions on $me: $!"}sub feature {my ($package,$key)=@_;return$features->{$key}if exists$features->{$key};my$info=$auto_features->{$key}or return 0;require Module::Build;for my$type (sort keys %$info){my$prereqs=$info->{$type};next if$type eq 'description' || $type eq 'recommends';for my$modname (sort keys %$prereqs){my$status=Module::Build->check_installed_status($modname,$prereqs->{$modname});if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}__DATA__ do{ my $x = [
         {},
         {},
         {
           'HTML_support' => {
                               'description' => 'Create HTML documentation',
                               'requires' => {
                                               'Pod::Html' => 0
                                             }
                             },
           'PPM_support' => {
                              'description' => 'Generate PPM files for distributions'
                            },
           'dist_authoring' => {
                                 'description' => 'Create new distributions',
                                 'recommends' => {
                                                   'Module::Signature' => '0.21',
                                                   'Pod::Readme' => '0.04'
                                                 },
                                 'requires' => {
                                                 'Archive::Tar' => '1.09'
                                               }
                               },
           'inc_bundling_support' => {
                                       'description' => 'Bundle Module::Build in inc/',
                                       'requires' => {
                                                       'ExtUtils::Install' => '1.54',
                                                       'ExtUtils::Installed' => '1.999',
                                                       'inc::latest' => '0.5'
                                                     }
                                     },
           'license_creation' => {
                                   'description' => 'Create licenses automatically in distributions',
                                   'requires' => {
                                                   'Software::License' => '0.103009'
                                                 }
                                 },
           'manpage_support' => {
                                  'description' => 'Create Unix man pages',
                                  'requires' => {
                                                  'Pod::Man' => 0
                                                }
                                }
         }
       ];
  $x; }
MODULE_BUILD_CONFIGDATA

$fatpacked{"Module/Build/Cookbook.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COOKBOOK';
  package Module::Build::Cookbook;use strict;use warnings;our$VERSION='0.4224';
MODULE_BUILD_COOKBOOK

$fatpacked{"Module/Build/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_DUMPER';
  package Module::Build::Dumper;use strict;use warnings;our$VERSION='0.4224';use Data::Dumper;sub _data_dump {my ($self,$data)=@_;return ("do{ my " .Data::Dumper->new([$data],['x'])->Purity(1)->Terse(0)->Sortkeys(1)->Dump().'$x; }')}1;
MODULE_BUILD_DUMPER

$fatpacked{"Module/Build/Notes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_NOTES';
  package Module::Build::Notes;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Data::Dumper;use Module::Build::Dumper;sub new {my ($class,%args)=@_;my$file=delete$args{file}or die "Missing required parameter 'file' to new()";my$self=bless {disk=>{},new=>{},file=>$file,%args,},$class}sub restore {my$self=shift;open(my$fh,'<',$self->{file})or die "Can't read $self->{file}: $!";$self->{disk}=eval do {local $/;<$fh>};die $@ if $@;close$fh;$self->{new}={}}sub access {my$self=shift;return$self->read()unless @_;my$key=shift;return$self->read($key)unless @_;my$value=shift;$self->write({$key=>$value });return$self->read($key)}sub has_data {my$self=shift;return keys %{$self->read()}> 0}sub exists {my ($self,$key)=@_;return exists($self->{new}{$key})|| exists($self->{disk}{$key})}sub read {my$self=shift;if (@_){my$key=shift;return$self->{new}{$key}if exists$self->{new}{$key};return$self->{disk}{$key}}my$out=(keys %{$self->{new}}? {%{$self->{disk}},%{$self->{new}}}: $self->{disk});return wantarray ? %$out : $out}sub _same {my ($self,$x,$y)=@_;return 1 if!defined($x)and!defined($y);return 0 if!defined($x)or!defined($y);return$x eq $y}sub write {my ($self,$href)=@_;$href ||= {};@{$self->{new}}{keys %$href }=values %$href;for my$key (keys %{$self->{new}}){next if ref$self->{new}{$key};next if ref$self->{disk}{$key}or!exists$self->{disk}{$key};delete$self->{new}{$key}if$self->_same($self->{new}{$key},$self->{disk}{$key})}if (my$file=$self->{file}){my ($vol,$dir,$base)=File::Spec->splitpath($file);$dir=File::Spec->catpath($vol,$dir,'');return unless -e $dir && -d $dir;return if -e $file and!keys %{$self->{new}};@{$self->{disk}}{keys %{$self->{new}}}=values %{$self->{new}};$self->_dump($file,$self->{disk});$self->{new}={}}return$self->read}sub _dump {my ($self,$file,$data)=@_;open(my$fh,'>',$file)or die "Can't create '$file': $!";print {$fh}Module::Build::Dumper->_data_dump($data);close$fh}my$orig_template=do {local $/;<DATA>};close DATA;sub write_config_data {my ($self,%args)=@_;my$template=$orig_template;$template =~ s/NOTES_NAME/$args{config_module}/g;$template =~ s/MODULE_NAME/$args{module}/g;$template =~ s/=begin private\n//;$template =~ s/=end private/=cut/;$template =~ s{$_\n}{} for '=begin private','=end private';open(my$fh,'>',$args{file})or die "Can't create '$args{file}': $!";print {$fh}$template;print {$fh}"\n__DATA__\n";print {$fh}Module::Build::Dumper->_data_dump([$args{config_data},$args{feature},$args{auto_features}]);close$fh}1;__DATA__ package NOTES_NAME;
  use strict;
  my $arrayref = eval do {local $/; <DATA>}
    or die "Couldn't load ConfigData data: $@";
  close DATA;
  my ($config, $features, $auto_features) = @$arrayref;
  
  sub config { $config->{$_[1]} }
  
  sub set_config { $config->{$_[1]} = $_[2] }
  sub set_feature { $features->{$_[1]} = 0+!!$_[2] }  # Constrain to 1 or 0
  
  sub auto_feature_names { sort grep !exists $features->{$_}, keys %$auto_features }
  
  sub feature_names {
    my @features = (sort keys %$features, auto_feature_names());
    @features;
  }
  
  sub config_names  { sort keys %$config }
  
  sub write {
    my $me = __FILE__;
  
    # Can't use Module::Build::Dumper here because M::B is only a
    # build-time prereq of this module
    require Data::Dumper;
  
    my $mode_orig = (stat $me)[2] & 07777;
    chmod($mode_orig | 0222, $me); # Make it writeable
    open(my $fh, '+<', $me) or die "Can't rewrite $me: $!";
    seek($fh, 0, 0);
    while (<$fh>) {
      last if /^__DATA__$/;
    }
    die "Couldn't find __DATA__ token in $me" if eof($fh);
  
    seek($fh, tell($fh), 0);
    my $data = [$config, $features, $auto_features];
    print($fh 'do{ my '
  	      . Data::Dumper->new([$data],['x'])->Purity(1)->Dump()
  	      . '$x; }' );
    truncate($fh, tell($fh));
    close $fh;
  
    chmod($mode_orig, $me)
      or warn "Couldn't restore permissions on $me: $!";
  }
  
  sub feature {
    my ($package, $key) = @_;
    return $features->{$key} if exists $features->{$key};
  
    my $info = $auto_features->{$key} or return 0;
  
    require Module::Build;  # XXX should get rid of this
    foreach my $type (sort keys %$info) {
      my $prereqs = $info->{$type};
      next if $type eq 'description' || $type eq 'recommends';
  
      foreach my $modname (sort keys %$prereqs) {
        my $status = Module::Build->check_installed_status($modname, $prereqs->{$modname});
        if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
        if ( ! eval "require $modname; 1" ) { return 0; }
      }
    }
    return 1;
  }
  
  =begin private
  
  =head1 NAME
  
  NOTES_NAME - Configuration for MODULE_NAME
  
  =head1 SYNOPSIS
  
    use NOTES_NAME;
    $value = NOTES_NAME->config('foo');
    $value = NOTES_NAME->feature('bar');
  
    @names = NOTES_NAME->config_names;
    @names = NOTES_NAME->feature_names;
  
    NOTES_NAME->set_config(foo => $new_value);
    NOTES_NAME->set_feature(bar => $new_value);
    NOTES_NAME->write;  # Save changes
  
  
  =head1 DESCRIPTION
  
  This module holds the configuration data for the C<MODULE_NAME>
  module.  It also provides a programmatic interface for getting or
  setting that configuration data.  Note that in order to actually make
  changes, you'll have to have write access to the C<NOTES_NAME>
  module, and you should attempt to understand the repercussions of your
  actions.
  
  
  =head1 METHODS
  
  =over 4
  
  =item config($name)
  
  Given a string argument, returns the value of the configuration item
  by that name, or C<undef> if no such item exists.
  
  =item feature($name)
  
  Given a string argument, returns the value of the feature by that
  name, or C<undef> if no such feature exists.
  
  =item set_config($name, $value)
  
  Sets the configuration item with the given name to the given value.
  The value may be any Perl scalar that will serialize correctly using
  C<Data::Dumper>.  This includes references, objects (usually), and
  complex data structures.  It probably does not include transient
  things like filehandles or sockets.
  
  =item set_feature($name, $value)
  
  Sets the feature with the given name to the given boolean value.  The
  value will be converted to 0 or 1 automatically.
  
  =item config_names()
  
  Returns a list of all the names of config items currently defined in
  C<NOTES_NAME>, or in scalar context the number of items.
  
  =item feature_names()
  
  Returns a list of all the names of features currently defined in
  C<NOTES_NAME>, or in scalar context the number of features.
  
  =item auto_feature_names()
  
  Returns a list of all the names of features whose availability is
  dynamically determined, or in scalar context the number of such
  features.  Does not include such features that have later been set to
  a fixed value.
  
  =item write()
  
  Commits any changes from C<set_config()> and C<set_feature()> to disk.
  Requires write access to the C<NOTES_NAME> module.
  
  =back
  
  
  =head1 AUTHOR
  
  C<NOTES_NAME> was automatically created using C<Module::Build>.
  C<Module::Build> was written by Ken Williams, but he holds no
  authorship claim or copyright claim to the contents of C<NOTES_NAME>.
  
  =end private
  
MODULE_BUILD_NOTES

$fatpacked{"Module/Build/PPMMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PPMMAKER';
  package Module::Build::PPMMaker;use strict;use warnings;use Config;our$VERSION='0.4224';$VERSION=eval$VERSION;sub new {my$package=shift;return bless {@_},$package}sub make_ppd {my ($self,%args)=@_;my$build=delete$args{build};my@codebase;if (exists$args{codebase}){@codebase=ref$args{codebase}? @{$args{codebase}}: ($args{codebase})}else {my$distfile=$build->ppm_name .'.tar.gz';print "Using default codebase '$distfile'\n";@codebase=($distfile)}my%dist;for my$info (qw(name author abstract version)){my$method="dist_$info";$dist{$info}=$build->$method()or die "Can't determine distribution's $info\n"}$self->_simple_xml_escape($_)foreach$dist{abstract},@{$dist{author}};my$ppd=<<"PPD";for my$type (qw(requires)){my$prereq=$build->$type();for my$modname (sort keys %$prereq){next if$modname eq 'perl';my$min_version='0.0';for my$c ($build->_parse_conditions($prereq->{$modname})){my ($op,$version)=$c =~ /^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x;if ($op eq '>='){$min_version=$version;last}}$modname .= '::' unless$modname =~ /::/;$ppd .= qq!        <REQUIRE NAME="$modname" VERSION="$min_version" />\n!}}if (keys %{$build->find_xs_files}){my$perl_version=$self->_ppd_version($build->perl_version);$ppd .= sprintf(<<'EOF',$self->_varchname($build->config))}for my$codebase (@codebase){$self->_simple_xml_escape($codebase);$ppd .= sprintf(<<'EOF',$codebase)}$ppd .= <<'EOF';my$ppd_file="$dist{name}.ppd";open(my$fh,'>',$ppd_file)or die "Cannot write to $ppd_file: $!";binmode($fh,":utf8")if $] >= 5.008 && $Config{useperlio};print$fh $ppd;close$fh;return$ppd_file}sub _ppd_version {my ($self,$version)=@_;return join ',',(split(/\./,$version),(0)x4)[0..3]}sub _varchname {my ($self,$config)=@_;my$varchname=$config->{archname};if ($] >= 5.008){my$vstring=sprintf "%vd",$^V;$vstring =~ s/\.\d+$//;$varchname .= "-$vstring"}return$varchname}{my%escapes=("\n"=>"\\n",'"'=>'&quot;','&'=>'&amp;','>'=>'&gt;','<'=>'&lt;',);my$rx=join '|',keys%escapes;sub _simple_xml_escape {$_[1]=~ s/($rx)/$escapes{$1}/go}}1;
  <SOFTPKG NAME=\"$dist{name}\" VERSION=\"$dist{version}\">
      <ABSTRACT>$dist{abstract}</ABSTRACT>
  @{[ join "\n", map "    <AUTHOR>$_</AUTHOR>", @{$dist{author}} ]}
      <IMPLEMENTATION>
  PPD
          <ARCHITECTURE NAME="%s" />
  EOF
          <CODEBASE HREF="%s" />
  EOF
      </IMPLEMENTATION>
  </SOFTPKG>
  EOF
MODULE_BUILD_PPMMAKER

$fatpacked{"Module/Build/Platform/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DEFAULT';
  package Module::Build::Platform::Default;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);1;
MODULE_BUILD_PLATFORM_DEFAULT

$fatpacked{"Module/Build/Platform/MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_MACOS';
  package Module::Build::Platform::MacOS;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);use ExtUtils::Install;sub have_forkpipe {0}sub new {my$class=shift;my$self=$class->SUPER::new(@_);for ('sitelib','sitearch'){$self->config($_=>$self->config("install$_"))unless$self->config($_)}(my$sp=$self->config('startperl'))=~ s/.*Exit \{Status\}\s//;$self->config(startperl=>$sp);return$self}sub make_executable {my$self=shift;require MacPerl;for (@_){MacPerl::SetFileInfo('McPL','TEXT',$_)}}sub dispatch {my$self=shift;if(!@_ and!@ARGV){require MacPerl;my@action_list=qw(build test install);my%actions=map {+($_,1)}$self->known_actions;delete@actions{@action_list};push@action_list,sort {$a cmp $b}keys%actions;my%toolserver=map {+$_=>1}qw(test disttest diff testdb);for (@action_list){$_ .= ' *' if$toolserver{$_}}my$cmd=MacPerl::Pick("What build command? ('*' requires ToolServer)",@action_list);return unless defined$cmd;$cmd =~ s/ \*$//;$ARGV[0]=($cmd);my$args=MacPerl::Ask('Any extra arguments?  (ie. verbose=1)','');return unless defined$args;push@ARGV,$self->split_like_shell($args)}$self->SUPER::dispatch(@_)}sub ACTION_realclean {my$self=shift;chmod 0666,$self->{properties}{build_script};$self->SUPER::ACTION_realclean}sub ACTION_install {my$self=shift;return$self->SUPER::ACTION_install(@_)if eval {ExtUtils::Install->VERSION('1.30');1};local $^W=0;local*ExtUtils::Install::find=sub {my ($code,@dirs)=@_;@dirs=map {$_ eq '.' ? File::Spec->curdir : $_}@dirs;return File::Find::find($code,@dirs)};return$self->SUPER::ACTION_install(@_)}1;
MODULE_BUILD_PLATFORM_MACOS

$fatpacked{"Module/Build/Platform/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_UNIX';
  package Module::Build::Platform::Unix;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);sub is_executable {my ($self,$file)=@_;return +(stat$file)[2]& 0100}sub _startperl {"#! " .shift()->perl}sub _construct {my$self=shift()->SUPER::_construct(@_);my$c=$self->{config};for (qw(siteman1 siteman3 vendorman1 vendorman3)){$c->{"install${_}dir"}||= $c->{"install${_}"}}return$self}sub _detildefy {my ($self,$value)=@_;$value =~ s[^~([^/]+)?(?=/|$)]   # tilde with optional username [$1 ? (eval{(getpwnam $1)[7]}|| "~$1"): ($ENV{HOME}|| eval{(getpwuid $>)[7]}|| glob("~"))]ex;return$value}1;
MODULE_BUILD_PLATFORM_UNIX

$fatpacked{"Module/Build/Platform/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VMS';
  package Module::Build::Platform::VMS;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Module::Build::Base;use Config;our@ISA=qw(Module::Build::Base);sub _set_defaults {my$self=shift;$self->SUPER::_set_defaults(@_);$self->{properties}{build_script}='Build.com'}sub cull_args {my$self=shift;my($action,$args)=$self->SUPER::cull_args(@_);my@possible_actions=grep {lc $_ eq lc$action}$self->known_actions;die "Ambiguous action '$action'.  Could be one of @possible_actions" if@possible_actions > 1;return ($possible_actions[0],$args)}sub manpage_separator {return '__'}sub _catprefix {my($self,$rprefix,$default)=@_;my($rvol,$rdirs)=File::Spec->splitpath($rprefix);if($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->log_verbose("  prefixify $path from $sprefix to $rprefix\n");$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->log_verbose("  rprefix translated to $rprefix\n"."  sprefix translated to $sprefix\n");if(length($path)==0){$self->log_verbose("  no path to prefixify.\n")}elsif(!File::Spec->file_name_is_absolute($path)){$self->log_verbose("    path is relative, not prefixifying.\n")}elsif($sprefix eq $rprefix){$self->log_verbose("  no new prefix.\n")}else {my($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config('vms_prefix');if($path_vol eq $vms_prefix.':'){$self->log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix($rprefix,$path_dirs)}else {$self->log_verbose("    cannot prefixify.\n");return$self->prefix_relpaths($self->installdirs,$type)}}$self->log_verbose("    now $path\n");return$path}sub _quote_args {my ($self,@args)=@_;my$got_arrayref=(scalar(@args)==1 && ref$args[0]eq 'ARRAY')? 1 : 0;map {if (!/^\//){$_ =~ s/\"/""/g;$_=q(").$_.q(")}}($got_arrayref ? @{$args[0]}: @args);return$got_arrayref ? $args[0]: join(' ',@args)}sub have_forkpipe {0}sub _backticks {my ($self,@cmd)=@_;my$cmd=shift@cmd;my$args=$self->_quote_args(@cmd);return `$cmd $args`}sub find_command {my ($self,$command)=@_;if ($^O eq 'VMS'){require VMS::DCLsym;my$syms=VMS::DCLsym->new;return$command if scalar$syms->getsym(uc$command)}$self->SUPER::find_command($command)}sub _maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d _;my(@dirs)=('');my(@exts)=('',$Config{'exe_ext'},'.exe','.com');if ($file !~ m![/:>\]]!){for (my$i=0;defined$ENV{"DCL\$PATH;$i"};$i++){my$dir=$ENV{"DCL\$PATH;$i"};$dir .= ':' unless$dir =~ m%[\]:]$%;push(@dirs,$dir)}push(@dirs,'Sys$System:');for my$dir (@dirs){my$sysfile="$dir$file";for my$ext (@exts){return$file if -x "$sysfile$ext" &&!-d _}}}return}sub do_system {my ($self,@cmd)=@_;$self->log_verbose("@cmd\n");my$cmd=shift@cmd;my$args=$self->_quote_args(@cmd);return!system("$cmd $args")}sub oneliner {my$self=shift;my$oneliner=$self->SUPER::oneliner(@_);$oneliner =~ s/^\"\S+\"//;return "MCR $^X $oneliner"}sub rscan_dir {my ($self,$dir,$pattern)=@_;my$result=$self->SUPER::rscan_dir($dir,$pattern);for my$file (@$result){if (!_efs()&& ($file =~ m#/#)){$file =~ s/\.$//}}return$result}sub dist_dir {my$self=shift;my$dist_dir=$self->SUPER::dist_dir;$dist_dir =~ s/\./_/g unless _efs();return$dist_dir}sub man3page_name {my$self=shift;my$mpname=$self->SUPER::man3page_name(shift);my$sep=$self->manpage_separator;$mpname =~ s/^$sep//;return$mpname}sub expand_test_dir {my ($self,$dir)=@_;my@reldirs=$self->SUPER::expand_test_dir($dir);for my$eachdir (@reldirs){my ($v,$d,$f)=File::Spec->splitpath($eachdir);my$reldir=File::Spec->abs2rel(File::Spec->catpath($v,$d,''));$eachdir=File::Spec->catfile($reldir,$f)}return@reldirs}sub _detildefy {my ($self,$arg)=@_;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}sub find_perl_interpreter {return VMS::Filespec::vmsify($^X)}sub localize_file_path {my ($self,$path)=@_;$path=VMS::Filespec::vmsify($path);$path =~ s/\.\z//;return$path}sub localize_dir_path {my ($self,$path)=@_;return VMS::Filespec::vmspath($path)}sub ACTION_clean {my ($self)=@_;for my$item (map glob(VMS::Filespec::rmsexpand($_,'.;0')),$self->cleanup){$self->delete_filetree($item)}}my$use_feature;BEGIN {if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_feature=1}}sub _unix_rpt {my$unix_rpt;if ($use_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub _efs {my$efs;if ($use_feature){$efs=VMS::Feature::current("efs_charset")}else {my$env_efs=$ENV{'DECC$EFS_CHARSET'}|| '';$efs=$env_efs =~ /^[ET1]/i}return$efs}1;
MODULE_BUILD_PLATFORM_VMS

$fatpacked{"Module/Build/Platform/VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VOS';
  package Module::Build::Platform::VOS;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);1;
MODULE_BUILD_PLATFORM_VOS

$fatpacked{"Module/Build/Platform/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_WINDOWS';
  package Module::Build::Platform::Windows;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Config;use File::Basename;use File::Spec;use Module::Build::Base;our@ISA=qw(Module::Build::Base);sub manpage_separator {return '.'}sub have_forkpipe {0}sub _detildefy {my ($self,$value)=@_;$value =~ s,^~(?= [/\\] | $ ),$ENV{HOME},x if$ENV{HOME};return$value}sub ACTION_realclean {my ($self)=@_;$self->SUPER::ACTION_realclean();my$basename=basename($0);$basename =~ s/(?:\.bat)?$//i;if (lc$basename eq lc$self->build_script){if ($self->build_bat){$self->log_verbose("Deleting $basename.bat\n");my$full_progname=$0;$full_progname =~ s/(?:\.bat)?$/.bat/i;require Win32;my$null_arg=(Win32::IsWinNT())? '""' : '';my$cmd=qq(start $null_arg /min "\%comspec\%" /c del "$full_progname");open(my$fh,'>>',"$basename.bat")or die "Can't create $basename.bat: $!";print$fh $cmd;close$fh }else {$self->delete_filetree($self->build_script .'.bat')}}}sub make_executable {my$self=shift;$self->SUPER::make_executable(@_);for my$script (@_){if ($script =~ /\.(bat|cmd)$/){$self->SUPER::make_executable($script);next}else {my%opts=();if ($script eq $self->build_script){$opts{ntargs}=q(-x -S %0 --build_bat %*);$opts{otherargs}=q(-x -S "%0" --build_bat %1 %2 %3 %4 %5 %6 %7 %8 %9)}my$out=eval {$self->pl2bat(in=>$script,update=>1,%opts)};if ($@){$self->log_warn("WARNING: Unable to convert file '$script' to an executable script:\n$@")}else {$self->SUPER::make_executable($out)}}}}sub pl2bat {my$self=shift;my%opts=@_;$opts{ntargs}='-x -S %0 %*' unless exists$opts{ntargs};$opts{otherargs}='-x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9' unless exists$opts{otherargs};$opts{stripsuffix}='/\\.plx?/' unless exists$opts{stripsuffix};$opts{stripsuffix}=($opts{stripsuffix}=~ m{^/([^/]*[^/\$]|)\$?/?$} ? $1 : "\Q$opts{stripsuffix}\E");unless (exists$opts{out}){$opts{out}=$opts{in};$opts{out}=~ s/$opts{stripsuffix}$//oi;$opts{out}.= '.bat' unless$opts{in}=~ /\.bat$/i or $opts{in}=~ /^-$/}my$head=<<EOT;$head =~ s/^\s+//gm;my$headlines=2 + ($head =~ tr/\n/\n/);my$tail="\n__END__\n:endofperl\n";my$linedone=0;my$taildone=0;my$linenum=0;my$skiplines=0;my$start=$Config{startperl};$start="#!perl" unless$start =~ /^#!.*perl/;open(my$in,'<',"$opts{in}")or die "Can't open $opts{in}: $!";my@file=<$in>;close($in);for my$line (@file){$linenum++;if ($line =~ /^:endofperl\b/){if (!exists$opts{update}){warn "$opts{in} has already been converted to a batch file!\n";return}$taildone++}if (not $linedone and $line =~ /^#!.*perl/){if (exists$opts{update}){$skiplines=$linenum - 1;$line .= "#line ".(1+$headlines)."\n"}else {$line .= "#line ".($linenum+$headlines)."\n"}$linedone++}if ($line =~ /^#\s*line\b/ and $linenum==2 + $skiplines){$line=""}}open(my$out,'>',"$opts{out}")or die "Can't open $opts{out}: $!";print$out $head;print$out $start,($opts{usewarnings}? " -w" : ""),"\n#line ",($headlines+1),"\n" unless$linedone;print$out @file[$skiplines..$#file];print$out $tail unless$taildone;close($out);return$opts{out}}sub _quote_args {my ($self,@args)=@_;my@quoted;for (@args){if (/^[^\s*?!\$<>;|'"\[\]\{\}]+$/){push@quoted,$_}else {s/"/\\"/g;push@quoted,qq("$_")}}return join " ",@quoted}sub split_like_shell {(my$self,local $_)=@_;return @$_ if defined()&& ref()eq 'ARRAY';my@argv;return@argv unless defined()&& length();my$length=length;m/\G\s*/gc;ARGS: until (pos==$length){my$quote_mode;my$arg='';CHARS: until (pos==$length){if (m/\G((?:\\\\)+)(?=\\?(")?)/gc){if (defined $2){$arg .= '\\' x (length($1)/ 2)}else {$arg .= $1}}elsif (m/\G\\"/gc){$arg .= '"'}elsif (m/\G"/gc){if ($quote_mode && m/\G"/gc){$arg .= '"'}$quote_mode=!$quote_mode}elsif (!$quote_mode && m/\G\s+/gc){last}elsif (m/\G(.)/sgc){$arg .= $1}}push@argv,$arg}return@argv}sub do_system {my ($self,@cmd)=@_;my$cmd=$self->_quote_args(@cmd);my$status=system($cmd);if ($status and $! =~ /Argument list too long/i){my$env_entries='';for (sort keys%ENV){$env_entries .= "$_=>".length($ENV{$_})."; "}warn "'Argument list' was 'too long', env lengths are $env_entries"}return!$status}sub _maybe_command {my($self,$file)=@_;my@e=exists($ENV{'PATHEXT'})? split(/;/,$ENV{PATHEXT}): qw(.com .exe .bat .cmd);my$e='';for (@e){$e .= "\Q$_\E|"}chop$e;if ($file =~ /($e)$/i){return$file if -e $file}else {for (@e){return "$file$_" if -e "$file$_"}}return}1;
      \@rem = '--*-Perl-*--
      \@echo off
      if "%OS%" == "Windows_NT" goto WinNT
      perl $opts{otherargs}
      goto endofperl
      :WinNT
      perl $opts{ntargs}
      if NOT "%COMSPEC%" == "%SystemRoot%\\system32\\cmd.exe" goto endofperl
      if %errorlevel% == 9009 echo You do not have Perl in your PATH.
      if errorlevel 1 goto script_failed_so_exit_with_non_zero_val 2>nul
      goto endofperl
      \@rem ';
  EOT
MODULE_BUILD_PLATFORM_WINDOWS

$fatpacked{"Module/Build/Platform/aix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_AIX';
  package Module::Build::Platform::aix;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);1;
MODULE_BUILD_PLATFORM_AIX

$fatpacked{"Module/Build/Platform/cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_CYGWIN';
  package Module::Build::Platform::cygwin;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);sub manpage_separator {'.'}sub _maybe_command {my ($self,$file)=@_;if ($file =~ m{^/cygdrive/}i){require Module::Build::Platform::Windows;return Module::Build::Platform::Windows->_maybe_command($file)}return$self->SUPER::_maybe_command($file)}1;
MODULE_BUILD_PLATFORM_CYGWIN

$fatpacked{"Module/Build/Platform/darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DARWIN';
  package Module::Build::Platform::darwin;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);1;
MODULE_BUILD_PLATFORM_DARWIN

$fatpacked{"Module/Build/Platform/os2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_OS2';
  package Module::Build::Platform::os2;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);sub manpage_separator {'.'}sub have_forkpipe {0}sub _maybe_command {my($self,$file)=@_;$file =~ s,[/\\]+,/,g;return$file if -x $file &&!-d _;return "$file.exe" if -x "$file.exe" &&!-d _;return "$file.cmd" if -x "$file.cmd" &&!-d _;return}1;
MODULE_BUILD_PLATFORM_OS2

$fatpacked{"Module/Build/PodParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PODPARSER';
  package Module::Build::PodParser;use strict;use warnings;our$VERSION='0.4224';$VERSION=eval$VERSION;sub new {my$package=shift;my$self;$self=bless {have_pod_parser=>0,@_},$package;unless ($self->{fh}){die "No 'file' or 'fh' parameter given" unless$self->{file};open($self->{fh},'<',$self->{file})or die "Couldn't open $self->{file}: $!"}return$self}sub parse_from_filehandle {my ($self,$fh)=@_;local $_;while (<$fh>){next unless /^=(?!cut)/ .. /^=cut/;last if ($self->{abstract})=/^ (?: [a-z_0-9:]+ | [BCIF] < [a-z_0-9:]+ > ) \s+ - \s+ (.*\S) /ix}my@author;while (<$fh>){next unless /^=head1\s+AUTHORS?/i ... /^=/;next if /^=/;push@author,$_ if /\@/}return unless@author;s/^\s+|\s+$//g foreach@author;$self->{author}=\@author;return}sub get_abstract {my$self=shift;return$self->{abstract}if defined$self->{abstract};$self->parse_from_filehandle($self->{fh});return$self->{abstract}}sub get_author {my$self=shift;return$self->{author}if defined$self->{author};$self->parse_from_filehandle($self->{fh});return$self->{author}|| []}
MODULE_BUILD_PODPARSER

$fatpacked{"Module/Build/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_TINY';
  package Module::Build::Tiny;$Module::Build::Tiny::VERSION='0.039';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=qw/Build Build_PL/;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/basename dirname/;use File::Find ();use File::Path qw/mkpath rmtree/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;use JSON::PP 2 qw/encode_json decode_json/;sub write_file {my ($filename,$content)=@_;open my$fh,'>',$filename or die "Could not open $filename: $!\n";print$fh $content}sub read_file {my ($filename,$mode)=@_;open my$fh,'<',$filename or die "Could not open $filename: $!\n";return do {local $/;<$fh>}}sub get_meta {my ($metafile)=grep {-e $_}qw/META.json META.yml/ or die "No META information provided\n";return CPAN::Meta->load_file($metafile)}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub process_xs {my ($source,$options)=@_;die "Can't build xs files under --pureperl-only\n" if$options->{'pureperl-only'};my (undef,@parts)=splitdir(dirname($source));push@parts,my$file_base=basename($source,'.xs');my$archdir=catdir(qw/blib arch auto/,@parts);my$tempdir='temp';my$c_file=catfile($tempdir,"$file_base.c");require ExtUtils::ParseXS;mkpath($tempdir,$options->{verbose},oct '755');ExtUtils::ParseXS::process_file(filename=>$source,prototypes=>0,output=>$c_file);my$version=$options->{meta}->version;require ExtUtils::CBuilder;my$builder=ExtUtils::CBuilder->new(config=>$options->{config}->values_set);my$ob_file=$builder->compile(source=>$c_file,defines=>{VERSION=>qq/"$version"/,XS_VERSION=>qq/"$version"/ },include_dirs=>[curdir,dirname($source)]);require DynaLoader;my$mod2fname=defined&DynaLoader::mod2fname ? \&DynaLoader::mod2fname : sub {return $_[0][-1]};mkpath($archdir,$options->{verbose},oct '755')unless -d $archdir;my$lib_file=catfile($archdir,$mod2fname->(\@parts).'.' .$options->{config}->get('dlext'));return$builder->link(objects=>$ob_file,lib_file=>$lib_file,module_name=>join '::',@parts)}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;for my$pl_file (find(qr/\.PL$/,'lib')){(my$pm=$pl_file)=~ s/\.PL$//;system $^X,$pl_file,$pm and die "$pl_file returned $?\n"}my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared},catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});process_xs($_,\%opt)for find(qr/.xs$/,'lib');if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and exit 1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/})},clean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp/},realclean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp Build _build_params MYMETA.yml MYMETA.json/},);sub Build {my$action=@ARGV && $ARGV[0]=~ /\A\w+\z/ ? shift@ARGV : 'build';die "No such action '$action'\n" if not $actions{$action};my($env,$bargv)=@{decode_json(read_file('_build_params'))};my%opt;GetOptionsFromArray($_,\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($env,$bargv,\@ARGV);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),get_meta());$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub Build_PL {my$meta=get_meta();printf "Creating new 'Build' script for '%s' version '%s'\n",$meta->name,$meta->version;my$dir=$meta->name eq 'Module-Build-Tiny' ? "use lib 'lib';" : '';write_file('Build',"#!perl\n$dir\nuse Module::Build::Tiny;\nBuild();\n");make_executable('Build');my@env=defined$ENV{PERL_MB_OPT}? split_like_shell($ENV{PERL_MB_OPT}): ();write_file('_build_params',encode_json([\@env,\@ARGV ]));$meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MODULE_BUILD_TINY

$fatpacked{"Pod/Escapes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ESCAPES';
  package Pod::Escapes;use strict;use warnings;use 5.006;use vars qw(%Code2USASCII %Name2character %Name2character_number %Latin1Code_to_fallback %Latin1Char_to_fallback $FAR_CHAR $FAR_CHAR_NUMBER $NOT_ASCII @ISA $VERSION @EXPORT_OK %EXPORT_TAGS);require Exporter;@ISA=('Exporter');$VERSION='1.07';@EXPORT_OK=qw(%Code2USASCII %Name2character %Name2character_number %Latin1Code_to_fallback %Latin1Char_to_fallback e2char e2charnum);%EXPORT_TAGS=('ALL'=>\@EXPORT_OK);$FAR_CHAR="?" unless defined$FAR_CHAR;$FAR_CHAR_NUMBER=ord($FAR_CHAR)unless defined$FAR_CHAR_NUMBER;$NOT_ASCII='A' ne chr(65)unless defined$NOT_ASCII;sub e2char {my$in=$_[0];return undef unless defined$in and length$in;if($in =~ m/^(0[0-7]*)$/s){$in=oct$in}elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s){$in=hex $1}if($in =~ m/^\d+$/s){if($] < 5.007 and $in > 255){return$FAR_CHAR}elsif ($] >= 5.007003){return chr(utf8::unicode_to_native($in))}elsif ($NOT_ASCII){return$Code2USASCII{$in}|| $Latin1Code_to_fallback{$in}|| $FAR_CHAR}else {return chr($in)}}else {return$Name2character{$in}}}sub e2charnum {my$in=$_[0];return undef unless defined$in and length$in;if($in =~ m/^(0[0-7]*)$/s){$in=oct$in}elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s){$in=hex $1}if($in =~ m/^[0-9]+$/s){return 0 + $in}else {return$Name2character_number{$in}}}%Code2USASCII=(32,' ',33,'!',34,'"',35,'#',36,'$',37,'%',38,'&',39,"'",40,'(',41,')',42,'*',43,'+',44,',',45,'-',46,'.',47,'/',48,'0',49,'1',50,'2',51,'3',52,'4',53,'5',54,'6',55,'7',56,'8',57,'9',58,':',59,';',60,'<',61,'=',62,'>',63,'?',64,'@',65,'A',66,'B',67,'C',68,'D',69,'E',70,'F',71,'G',72,'H',73,'I',74,'J',75,'K',76,'L',77,'M',78,'N',79,'O',80,'P',81,'Q',82,'R',83,'S',84,'T',85,'U',86,'V',87,'W',88,'X',89,'Y',90,'Z',91,'[',92,"\\",93,']',94,'^',95,'_',96,'`',97,'a',98,'b',99,'c',100,'d',101,'e',102,'f',103,'g',104,'h',105,'i',106,'j',107,'k',108,'l',109,'m',110,'n',111,'o',112,'p',113,'q',114,'r',115,'s',116,'t',117,'u',118,'v',119,'w',120,'x',121,'y',122,'z',123,'{',124,'|',125,'}',126,'~',);%Latin1Code_to_fallback=();@Latin1Code_to_fallback{0xA0 .. 0xFF}=(' ',qq{!},qq{C/},'PS',qq{\$?},qq{Y=},qq{|},'SS',qq{"},qq{(c)},'a',qq{<<},qq{!},"",qq{(r)},qq{-},'deg',qq{+-},'2','3',qq{'},'u','P',qq{*},qq{,},'1','o',qq{>>},qq{1/4},qq{1/2},qq{3/4},qq{?},'A','A','A','A','A','A','AE','C','E','E','E','E','I','I','I','I','D','N','O','O','O','O','O','x','O','U','U','U','U','U','Th','ss','a','a','a','a','a','a','ae','c','e','e','e','e','i','i','i','i','d','n','o','o','o','o','o',qq{/},'o','u','u','u','u','y','th','y',);{%Latin1Char_to_fallback=();my($k,$v);while(($k,$v)=each%Latin1Code_to_fallback){$Latin1Char_to_fallback{chr$k}=$v}}%Name2character_number=('lt'=>60,'gt'=>62,'quot'=>34,'amp'=>38,'apos'=>39,'sol'=>47,'verbar'=>124,'lchevron'=>171,'rchevron'=>187,'nbsp',160,'iexcl',161,'cent',162,'pound',163,'curren',164,'yen',165,'brvbar',166,'sect',167,'uml',168,'copy',169,'ordf',170,'laquo',171,'not',172,'shy',173,'reg',174,'macr',175,'deg',176,'plusmn',177,'sup2',178,'sup3',179,'acute',180,'micro',181,'para',182,'middot',183,'cedil',184,'sup1',185,'ordm',186,'raquo',187,'frac14',188,'frac12',189,'frac34',190,'iquest',191,'Agrave',192,'Aacute',193,'Acirc',194,'Atilde',195,'Auml',196,'Aring',197,'AElig',198,'Ccedil',199,'Egrave',200,'Eacute',201,'Ecirc',202,'Euml',203,'Igrave',204,'Iacute',205,'Icirc',206,'Iuml',207,'ETH',208,'Ntilde',209,'Ograve',210,'Oacute',211,'Ocirc',212,'Otilde',213,'Ouml',214,'times',215,'Oslash',216,'Ugrave',217,'Uacute',218,'Ucirc',219,'Uuml',220,'Yacute',221,'THORN',222,'szlig',223,'agrave',224,'aacute',225,'acirc',226,'atilde',227,'auml',228,'aring',229,'aelig',230,'ccedil',231,'egrave',232,'eacute',233,'ecirc',234,'euml',235,'igrave',236,'iacute',237,'icirc',238,'iuml',239,'eth',240,'ntilde',241,'ograve',242,'oacute',243,'ocirc',244,'otilde',245,'ouml',246,'divide',247,'oslash',248,'ugrave',249,'uacute',250,'ucirc',251,'uuml',252,'yacute',253,'thorn',254,'yuml',255,'fnof',402,'Alpha',913,'Beta',914,'Gamma',915,'Delta',916,'Epsilon',917,'Zeta',918,'Eta',919,'Theta',920,'Iota',921,'Kappa',922,'Lambda',923,'Mu',924,'Nu',925,'Xi',926,'Omicron',927,'Pi',928,'Rho',929,'Sigma',931,'Tau',932,'Upsilon',933,'Phi',934,'Chi',935,'Psi',936,'Omega',937,'alpha',945,'beta',946,'gamma',947,'delta',948,'epsilon',949,'zeta',950,'eta',951,'theta',952,'iota',953,'kappa',954,'lambda',955,'mu',956,'nu',957,'xi',958,'omicron',959,'pi',960,'rho',961,'sigmaf',962,'sigma',963,'tau',964,'upsilon',965,'phi',966,'chi',967,'psi',968,'omega',969,'thetasym',977,'upsih',978,'piv',982,'bull',8226,'hellip',8230,'prime',8242,'Prime',8243,'oline',8254,'frasl',8260,'weierp',8472,'image',8465,'real',8476,'trade',8482,'alefsym',8501,'larr',8592,'uarr',8593,'rarr',8594,'darr',8595,'harr',8596,'crarr',8629,'lArr',8656,'uArr',8657,'rArr',8658,'dArr',8659,'hArr',8660,'forall',8704,'part',8706,'exist',8707,'empty',8709,'nabla',8711,'isin',8712,'notin',8713,'ni',8715,'prod',8719,'sum',8721,'minus',8722,'lowast',8727,'radic',8730,'prop',8733,'infin',8734,'ang',8736,'and',8743,'or',8744,'cap',8745,'cup',8746,'int',8747,'there4',8756,'sim',8764,'cong',8773,'asymp',8776,'ne',8800,'equiv',8801,'le',8804,'ge',8805,'sub',8834,'sup',8835,'nsub',8836,'sube',8838,'supe',8839,'oplus',8853,'otimes',8855,'perp',8869,'sdot',8901,'lceil',8968,'rceil',8969,'lfloor',8970,'rfloor',8971,'lang',9001,'rang',9002,'loz',9674,'spades',9824,'clubs',9827,'hearts',9829,'diams',9830,'OElig',338,'oelig',339,'Scaron',352,'scaron',353,'Yuml',376,'circ',710,'tilde',732,'ensp',8194,'emsp',8195,'thinsp',8201,'zwnj',8204,'zwj',8205,'lrm',8206,'rlm',8207,'ndash',8211,'mdash',8212,'lsquo',8216,'rsquo',8217,'sbquo',8218,'ldquo',8220,'rdquo',8221,'bdquo',8222,'dagger',8224,'Dagger',8225,'permil',8240,'lsaquo',8249,'rsaquo',8250,'euro',8364,);{%Name2character=();my($name,$number);while(($name,$number)=each%Name2character_number){if($] < 5.007 and $number > 255){$Name2character{$name}=$FAR_CHAR}elsif ($] >= 5.007003){$Name2character{$name}=chr utf8::unicode_to_native($number)}elsif (exists$Code2USASCII{$number}){$Name2character{$name}=$Code2USASCII{$number}}elsif ($NOT_ASCII && $number > 127 && $number < 256){if (exists$Latin1Code_to_fallback{$number}){$Name2character{$name}=$Latin1Code_to_fallback{$number}}else {$Name2character{$name}=$FAR_CHAR}}else {$Name2character{$name}=chr$number}}}1;
POD_ESCAPES

$fatpacked{"Pod/Find.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_FIND';
  package Pod::Find;use strict;use vars qw($VERSION);$VERSION='1.63';require 5.005;use Carp;BEGIN {if ($] < 5.006){require Symbol;import Symbol}}use Exporter;use File::Spec;use File::Find;use Cwd qw(abs_path cwd);use vars qw(@ISA @EXPORT_OK $VERSION);@ISA=qw(Exporter);@EXPORT_OK=qw(&pod_find &simplify_name &pod_where &contains_pod);my$SIMPLIFY_RX;sub pod_find {my%opts;if(ref $_[0]){%opts=%{shift()}}$opts{-verbose}||= 0;$opts{-perl}||= 0;my (@search)=@_;if($opts{-script}){require Config;push(@search,$Config::Config{scriptdir})if -d $Config::Config{scriptdir};$opts{-perl}=1}if($opts{-inc}){if ($^O eq 'MacOS'){my@new_INC=@INC;for (@new_INC){if ($_ eq '.'){$_=':'}elsif ($_ =~ s{^((?:\.\./)+)}{':' x (length($1)/3)}e){$_=':'.$_}else {$_ =~ s{^\./}{:}}}push(@search,grep($_ ne File::Spec->curdir,@new_INC))}else {my%seen;my$curdir=File::Spec->curdir;for(@INC){next if $_ eq $curdir;my$path=abs_path($_);push(@search,$path)unless$seen{$path}++}}$opts{-perl}=1}if($opts{-perl}){require Config;if ($^O eq 'MacOS'){$SIMPLIFY_RX=qq!^(?i:\:?site_perl\:|\:?pod\:(?=.*?\\.pod\\z))*!}else {$SIMPLIFY_RX=qq!^(?i:site(_perl)?/|\Q$Config::Config{archname}\E/|\\d+\\.\\d+([_.]?\\d+)?/|pod/(?=.*?\\.pod\\z))*!}}my%dirs_visited;my%pods;my%names;my$pwd=cwd();for my$try (@search){unless(File::Spec->file_name_is_absolute($try)){$try=File::Spec->catfile($pwd,$try)}if ($^O eq 'VMS'){$try=VMS::Filespec::unixify($try)}else {$try=File::Spec->canonpath($try)}my$name;if(-f $try){if($name=_check_and_extract_name($try,$opts{-verbose})){_check_for_duplicates($try,$name,\%names,\%pods)}next}my$root_rx=$^O eq 'MacOS' ? qq!^\Q$try\E! : qq!^\Q$try\E/!;$root_rx=~ s|//$|/|;File::Find::find(sub {my$item=$File::Find::name;if(-d){if($item =~ m{/(?:RCS|CVS|SCCS|\.svn|\.hg|\.git|\.sync)$}){$File::Find::prune=1;return}elsif($dirs_visited{$item}){warn "Directory '$item' already seen, skipping.\n" if($opts{-verbose});$File::Find::prune=1;return}else {$dirs_visited{$item}=1}if($opts{-perl}&& /^(\d+\.[\d_]+)\z/s && eval "$1"!=$]){$File::Find::prune=1;warn "Perl $] version mismatch on $_, skipping.\n" if($opts{-verbose})}return}if($name=_check_and_extract_name($item,$opts{-verbose},$root_rx)){_check_for_duplicates($item,$name,\%names,\%pods)}},$try)}chdir$pwd;return%pods}sub _check_for_duplicates {my ($file,$name,$names_ref,$pods_ref)=@_;if($$names_ref{$name}){warn "Duplicate POD found (shadowing?): $name ($file)\n";warn '    Already seen in ',join(' ',grep($$pods_ref{$_}eq $name,keys %$pods_ref)),"\n"}else {$$names_ref{$name}=1}return $$pods_ref{$file}=$name}sub _check_and_extract_name {my ($file,$verbose,$root_rx)=@_;unless(-f $file && -T $file && ($file =~ /\.(pod|pm|plx?)\z/i || -x $file)){return}return unless contains_pod($file,$verbose);my$name=$file;if(defined$root_rx){$name =~ s/$root_rx//is;$name =~ s/$SIMPLIFY_RX//is if(defined$SIMPLIFY_RX)}else {if ($^O eq 'MacOS'){$name =~ s/^.*://s}else {$name =~ s{^.*/}{}s}}_simplify($name);$name =~ s{/+}{::}g;if ($^O eq 'MacOS'){$name =~ s{:+}{::}g}else {$name =~ s{/+}{::}g}return$name}sub simplify_name {my ($str)=@_;if ($^O eq 'MacOS'){$str =~ s/^.*://s}else {$str =~ s{^.*/}{}s}_simplify($str);return$str}sub _simplify {$_[0]=~ s/\.(pod|pm|plx?)\z//i;$_[0]=~ s/\.(bat|exe|cmd)\z//i if($^O =~ /mswin|os2/i);$_[0]=~ s/\.(com)\z//i if($^O eq 'VMS')}sub pod_where {my%options=('-inc'=>0,'-verbose'=>0,'-dirs'=>[File::Spec->curdir ],);if (defined $_[0]&& ref($_[0])eq 'HASH'){my$opt=shift;%options=(%options,%$opt)}carp 'Usage: pod_where({options}, $pod)' unless (scalar(@_));my$pod=shift;my@parts=split (/::/,$pod);my@search_dirs=@{$options{'-dirs'}};if ($options{'-inc'}){require Config;if ($^O eq 'MacOS' && $options{'-inc'}){my@new_INC=@INC;for (@new_INC){if ($_ eq '.'){$_=':'}elsif ($_ =~ s{^((?:\.\./)+)}{':' x (length($1)/3)}e){$_=':'.$_}else {$_ =~ s{^\./}{:}}}push (@search_dirs,@new_INC)}elsif ($options{'-inc'}){push (@search_dirs,@INC)}push (@search_dirs,$Config::Config{'scriptdir'})if -d $Config::Config{'scriptdir'}}warn 'Search path is: '.join(' ',@search_dirs)."\n" if$options{'-verbose'};Dir: foreach my$dir (@search_dirs){if (-d $dir){warn "Looking in directory $dir\n" if$options{'-verbose'};my$fullname=File::Spec->catfile($dir,@parts);$fullname=VMS::Filespec::unixify($fullname)if $^O eq 'VMS';warn "Filename is now $fullname\n" if$options{'-verbose'};for my$ext ('','.pod','.pm','.pl'){my$fullext=$fullname .$ext;if (-f $fullext && contains_pod($fullext,$options{'-verbose'})){warn "FOUND: $fullext\n" if$options{'-verbose'};return$fullext}}}else {warn "Directory $dir does not exist\n" if$options{'-verbose'};next Dir}if((File::Spec->case_tolerant || $^O =~ /macos|darwin|cygwin/i)&& -d File::Spec->catdir($dir,'pods')){$dir=File::Spec->catdir($dir,'pods');redo Dir}if(-d File::Spec->catdir($dir,'pod')){$dir=File::Spec->catdir($dir,'pod');redo Dir}}return}sub contains_pod {my$file=shift;my$verbose=0;$verbose=shift if @_;my$podfh;if ($] < 5.006){$podfh=gensym()}unless(open($podfh,"<$file")){warn "Error: $file is unreadable: $!\n";return}local $/=undef;my$pod=<$podfh>;close($podfh)|| die "Error closing $file: $!\n";unless($pod =~ /^=(head\d|pod|over|item|cut)\b/m){warn "No POD in $file, skipping.\n" if($verbose);return 0}return 1}1;
POD_FIND

$fatpacked{"Pod/InputObjects.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_INPUTOBJECTS';
  package Pod::InputObjects;use strict;use vars qw($VERSION);$VERSION='1.63';require 5.005;package Pod::InputSource;sub new {my$this=shift;my$class=ref($this)|| $this;my$self={-name=>'(unknown)',-handle=>undef,-was_cutting=>0,@_ };bless$self,$class;return$self}sub name {(@_ > 1)and $_[0]->{'-name'}=$_[1];return $_[0]->{'-name'}}*filename=\&name;sub handle {return $_[0]->{'-handle'}}sub was_cutting {(@_ > 1)and $_[0]->{-was_cutting}=$_[1];return $_[0]->{-was_cutting}}package Pod::Paragraph;sub new {my$this=shift;my$class=ref($this)|| $this;my$self={-name=>undef,-text=>(@_==1)? shift : undef,-file=>'<unknown-file>',-line=>0,-prefix=>'=',-separator=>' ',-ptree=>[],@_ };bless$self,$class;return$self}sub cmd_name {(@_ > 1)and $_[0]->{'-name'}=$_[1];return $_[0]->{'-name'}}*name=\&cmd_name;sub text {(@_ > 1)and $_[0]->{'-text'}=$_[1];return $_[0]->{'-text'}}sub raw_text {return $_[0]->{'-text'}unless (defined $_[0]->{'-name'});return $_[0]->{'-prefix'}.$_[0]->{'-name'}.$_[0]->{'-separator'}.$_[0]->{'-text'}}sub cmd_prefix {return $_[0]->{'-prefix'}}sub cmd_separator {return $_[0]->{'-separator'}}sub parse_tree {(@_ > 1)and $_[0]->{'-ptree'}=$_[1];return $_[0]->{'-ptree'}}*ptree=\&parse_tree;sub file_line {my@loc=($_[0]->{'-file'}|| '<unknown-file>',$_[0]->{'-line'}|| 0);return (wantarray)? @loc : join(':',@loc)}package Pod::InteriorSequence;sub new {my$this=shift;my$class=ref($this)|| $this;if (((@_ <= 2)or (@_ % 2))and $_[0]!~ /^-\w/){unshift @_,'-name'}if ((@_ % 2)!=0){splice @_,$#_,0,'-ptree'}my$self={-name=>(@_==1)? $_[0]: undef,-file=>'<unknown-file>',-line=>0,-ldelim=>'<',-rdelim=>'>',@_ };my$ptree=$self->{'-ptree'}|| new Pod::ParseTree();if (ref$ptree =~ /^(ARRAY)?$/){$ptree=new Pod::ParseTree($1 ? [$ptree]: $ptree)}$self->{'-ptree'}=$ptree;bless$self,$class;return$self}sub cmd_name {(@_ > 1)and $_[0]->{'-name'}=$_[1];return $_[0]->{'-name'}}*name=\&cmd_name;sub _set_child2parent_links {my ($self,@children)=@_;for (@children){next unless (length and ref and ref ne 'SCALAR');if (UNIVERSAL::isa($_,'Pod::InteriorSequence')or UNIVERSAL::can($_,'nested')){$_->nested($self)}}}sub _unset_child2parent_links {my$self=shift;$self->{'-parent_sequence'}=undef;my$ptree=$self->{'-ptree'};for (@$ptree){next unless (length and ref and ref ne 'SCALAR');$_->_unset_child2parent_links()if UNIVERSAL::isa($_,'Pod::InteriorSequence')}}sub prepend {my$self=shift;$self->{'-ptree'}->prepend(@_);_set_child2parent_links($self,@_);return$self}sub append {my$self=shift;$self->{'-ptree'}->append(@_);_set_child2parent_links($self,@_);return$self}sub nested {my$self=shift;(@_==1)and $self->{'-parent_sequence'}=shift;return$self->{'-parent_sequence'}|| undef}sub raw_text {my$self=shift;my$text=$self->{'-name'}.$self->{'-ldelim'};for ($self->{'-ptree'}->children){$text .= (ref $_)? $_->raw_text : $_}$text .= $self->{'-rdelim'};return$text}sub left_delimiter {(@_ > 1)and $_[0]->{'-ldelim'}=$_[1];return $_[0]->{'-ldelim'}}*ldelim=\&left_delimiter;sub right_delimiter {(@_ > 1)and $_[0]->{'-rdelim'}=$_[1];return $_[0]->{'-rdelim'}}*rdelim=\&right_delimiter;sub parse_tree {(@_ > 1)and $_[0]->{'-ptree'}=$_[1];return $_[0]->{'-ptree'}}*ptree=\&parse_tree;sub file_line {my@loc=($_[0]->{'-file'}|| '<unknown-file>',$_[0]->{'-line'}|| 0);return (wantarray)? @loc : join(':',@loc)}sub DESTROY {_unset_child2parent_links(@_)}package Pod::ParseTree;sub new {my$this=shift;my$class=ref($this)|| $this;my$self=(@_==1 and ref $_[0])? $_[0]: [];bless$self,$class;return$self}sub top {my$self=shift;if (@_ > 0){@{$self}=(@_==1 and ref $_[0])? ${@_}: @_}return$self}*parse_tree=*ptree=\&top;sub children {my$self=shift;if (@_ > 0){@{$self}=(@_==1 and ref $_[0])? ${@_}: @_}return @{$self}}use vars qw(@ptree);sub prepend {my$self=shift;local*ptree=$self;for (@_){next unless length;if (@ptree &&!(ref$ptree[0])&&!(ref $_)){$ptree[0]=$_ .$ptree[0]}else {unshift@ptree,$_}}}sub append {my$self=shift;local*ptree=$self;my$can_append=@ptree &&!(ref$ptree[-1]);for (@_){if (ref){push@ptree,$_}elsif(!length){next}elsif ($can_append){$ptree[-1].= $_}else {push@ptree,$_}}}sub raw_text {my$self=shift;my$text='';for (@$self){$text .= (ref $_)? $_->raw_text : $_}return$text}sub _unset_child2parent_links {my$self=shift;local*ptree=$self;for (@ptree){next unless (defined and length and ref and ref ne 'SCALAR');$_->_unset_child2parent_links()if UNIVERSAL::isa($_,'Pod::InteriorSequence')}}sub _set_child2parent_links {}sub DESTROY {_unset_child2parent_links(@_)}1;
POD_INPUTOBJECTS

$fatpacked{"Pod/ParseUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PARSEUTILS';
  package Pod::ParseUtils;use strict;use vars qw($VERSION);$VERSION='1.63';require 5.005;package Pod::List;use Carp;sub new {my$this=shift;my$class=ref($this)|| $this;my%params=@_;my$self={%params};bless$self,$class;$self->initialize();return$self}sub initialize {my$self=shift;$self->{-file}||= 'unknown';$self->{-start}||= 'unknown';$self->{-indent}||= 4;$self->{_items}=[];$self->{-type}||= ''}sub file {return (@_ > 1)? ($_[0]->{-file}=$_[1]): $_[0]->{-file}}sub start {return (@_ > 1)? ($_[0]->{-start}=$_[1]): $_[0]->{-start}}sub indent {return (@_ > 1)? ($_[0]->{-indent}=$_[1]): $_[0]->{-indent}}sub type {return (@_ > 1)? ($_[0]->{-type}=$_[1]): $_[0]->{-type}}sub rx {return (@_ > 1)? ($_[0]->{-rx}=$_[1]): $_[0]->{-rx}}sub item {my ($self,$item)=@_;if(defined$item){push(@{$self->{_items}},$item);return$item}else {return @{$self->{_items}}}}sub parent {return (@_ > 1)? ($_[0]->{-parent}=$_[1]): $_[0]->{-parent}}sub tag {return (@_ > 1)? ($_[0]->{-tag}=$_[1]): $_[0]->{-tag}}package Pod::Hyperlink;use Carp;sub new {my$this=shift;my$class=ref($this)|| $this;my$self=+{};bless$self,$class;$self->initialize();if(defined $_[0]){if(ref($_[0])){%$self=%{$_[0]};$self->_construct_text()}else {return unless($self->parse($_[0]))}}return$self}sub initialize {my$self=shift;$self->{-line}||= 'undef';$self->{-file}||= 'undef';$self->{-page}||= '';$self->{-node}||= '';$self->{-alttext}||= '';$self->{-type}||= 'undef';$self->{_warnings}=[]}sub parse {my$self=shift;local($_)=$_[0];my ($alttext,$page,$node,$type,$quoted)=(undef,'','','',0);$self->{_warnings}=[];s/\s*\n+\s*/ /g;if(s/^[\s\n]+//){$self->warning('ignoring leading whitespace in link')}if(s/[\s\n]+$//){$self->warning('ignoring trailing whitespace in link')}unless(length($_)){_invalid_link('empty link');return}my$page_rx='[\w.-]+(?:::[\w.-]+)*(?:[(](?:\d\w*|)[)]|)';if(/^($page_rx)$/o){$page=$1;$type='page'}elsif(m{^(.*?)\s*[|]\s*($page_rx)\s*/\s*"(.+)"$}o){($alttext,$page,$node)=($1,$2,$3);$type='section';$quoted=1}elsif(/^(.*?)\s*[|]\s*($page_rx)$/o){($alttext,$page)=($1,$2);$type='page'}elsif(m{^(.*?)\s*[|]\s*(?:/\s*|)"(.+)"$}){($alttext,$node)=($1,$2);$type='section';$quoted=1}elsif(m{^($page_rx)\s*/\s*"(.+)"$}o){($page,$node)=($1,$2);$type='section';$quoted=1}elsif(m{^($page_rx)\s*/\s*(.+)$}o){($page,$node)=($1,$2);$type='item'}elsif(m{^/?"(.+)"$}){$node=$1;$type='section';$quoted=1}elsif(m{^\s*/(.+)$}){$node=$1;$type='item'}elsif(/^ \s* (.*?) \s* [|] \s* (\w+:[^:\s] [^\s|]*?) \s* $/ix){($alttext,$node)=($1,$2);$type='hyperlink'}elsif(/^(\w+:[^:\s]\S*)$/i){$node=$1;$type='hyperlink'}elsif(m{^(.*?)\s*[|]\s*($page_rx)\s*/\s*(.+)$}o){($alttext,$page,$node)=($1,$2,$3);$type='item'}elsif(m{^(.*?)\s*[|]\s*/(.+)$}){($alttext,$node)=($1,$2)}else {$node=$_;$type='item'}$node =~ s/\s+/ /gs;if(defined$alttext){if(!length($alttext)){$alttext=$node || $page}}else {$alttext=''}if($page =~ /[(]\w*[)]$/){$self->warning("(section) in '$page' deprecated")}if(!$quoted && $node =~ m{[|/]} && $type ne 'hyperlink'){$self->warning("node '$node' contains non-escaped | or /")}if($alttext =~ m{[|/]}){$self->warning("alternative text '$node' contains non-escaped | or /")}$self->{-page}=$page;$self->{-node}=$node;$self->{-alttext}=$alttext;$self->{-type}=$type;$self->_construct_text();1}sub _construct_text {my$self=shift;my$alttext=$self->alttext();my$type=$self->type();my$section=$self->node();my$page=$self->page();my$page_ext='';$page =~ s/([(]\w*[)])$// && ($page_ext=$1);if($alttext){$self->{_text}=$alttext}elsif($type eq 'hyperlink'){$self->{_text}=$section}else {$self->{_text}=($section || '').(($page && $section)? ' in ' : '')."$page$page_ext"}if($alttext){$self->{_markup}="Q<$alttext>"}elsif($type eq 'hyperlink'){$self->{_markup}="Q<$section>"}else {$self->{_markup}=(!$section ? '' : "Q<$section>").($page ? ($section ? ' in ':'')."P<$page>$page_ext" : '')}}sub markup {return (@_ > 1)? ($_[0]->{_markup}=$_[1]): $_[0]->{_markup}}sub text {return $_[0]->{_text}}sub warning {my$self=shift;if(@_){push(@{$self->{_warnings}},@_);return @_}return @{$self->{_warnings}}}sub line {return (@_ > 1)? ($_[0]->{-line}=$_[1]): $_[0]->{-line}}sub file {return (@_ > 1)? ($_[0]->{-file}=$_[1]): $_[0]->{-file}}sub page {if (@_ > 1){$_[0]->{-page}=$_[1];$_[0]->_construct_text()}return $_[0]->{-page}}sub node {if (@_ > 1){$_[0]->{-node}=$_[1];$_[0]->_construct_text()}return $_[0]->{-node}}sub alttext {if (@_ > 1){$_[0]->{-alttext}=$_[1];$_[0]->_construct_text()}return $_[0]->{-alttext}}sub type {return (@_ > 1)? ($_[0]->{-type}=$_[1]): $_[0]->{-type}}sub link {my$self=shift;my$link=$self->page()|| '';if($self->node()){my$node=$self->node();$node =~ s/\|/E<verbar>/g;$node =~ s{/}{E<sol>}g;if($self->type()eq 'section'){$link .= ($link ? '/' : '').'"' .$node .'"'}elsif($self->type()eq 'hyperlink'){$link=$self->node()}else {$link .= '/' .$node}}if($self->alttext()){my$text=$self->alttext();$text =~ s/\|/E<verbar>/g;$text =~ s{/}{E<sol>}g;$link="$text|$link"}return$link}sub _invalid_link {my ($msg)=@_;$@=$msg;return}package Pod::Cache;sub new {my$this=shift;my$class=ref($this)|| $this;my$self=[];bless$self,$class;return$self}sub item {my ($self,%param)=@_;if(%param){my$item=Pod::Cache::Item->new(%param);push(@$self,$item);return$item}else {return @{$self}}}sub find_page {my ($self,$page)=@_;for(@$self){if($_->page()eq $page){return $_}}return}package Pod::Cache::Item;sub new {my$this=shift;my$class=ref($this)|| $this;my%params=@_;my$self={%params};bless$self,$class;$self->initialize();return$self}sub initialize {my$self=shift;$self->{-nodes}=[]unless(defined$self->{-nodes})}sub page {return (@_ > 1)? ($_[0]->{-page}=$_[1]): $_[0]->{-page}}sub description {return (@_ > 1)? ($_[0]->{-description}=$_[1]): $_[0]->{-description}}sub path {return (@_ > 1)? ($_[0]->{-path}=$_[1]): $_[0]->{-path}}sub file {return (@_ > 1)? ($_[0]->{-file}=$_[1]): $_[0]->{-file}}sub nodes {my ($self,@nodes)=@_;if(@nodes){push(@{$self->{-nodes}},@nodes);return@nodes}else {return @{$self->{-nodes}}}}sub find_node {my ($self,$node)=@_;my@search;push(@search,@{$self->{-nodes}})if($self->{-nodes});push(@search,@{$self->{-idx}})if($self->{-idx});for(@search){if($_->[0]eq $node){return $_->[1]}}return}sub idx {my ($self,@idx)=@_;if(@idx){push(@{$self->{-idx}},@idx);return@idx}else {return @{$self->{-idx}}}}1;
POD_PARSEUTILS

$fatpacked{"Pod/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PARSER';
  package Pod::Parser;use strict;use vars qw($VERSION @ISA %myData %myOpts @input_stack);$VERSION='1.63';require 5.005;use Pod::InputObjects;use Carp;use Exporter;BEGIN {if ($] < 5.006){require Symbol;import Symbol}}@ISA=qw(Exporter);sub command {my ($self,$cmd,$text,$line_num,$pod_para)=@_;$self->textblock($pod_para->raw_text(),$line_num,$pod_para)}sub verbatim {my ($self,$text,$line_num,$pod_para)=@_;my$out_fh=$self->{_OUTPUT};print$out_fh $text}sub textblock {my ($self,$text,$line_num,$pod_para)=@_;my$out_fh=$self->{_OUTPUT};print$out_fh $self->interpolate($text,$line_num)}sub interior_sequence {my ($self,$seq_cmd,$seq_arg,$pod_seq)=@_;return$pod_seq->raw_text()}sub new {my ($this,%params)=@_;my$class=ref($this)|| $this;my$self={%params };bless$self,$class;$self->initialize();return$self}sub initialize {}sub begin_pod {}sub begin_input {}sub end_input {}sub end_pod {}sub preprocess_line {my ($self,$text,$line_num)=@_;return$text}sub preprocess_paragraph {my ($self,$text,$line_num)=@_;return$text}sub parse_text {my$self=shift;local $_='';my%opts=(ref $_[0])? %{shift()}: ();my$expand_seq=$opts{'-expand_seq'}|| undef;my$expand_text=$opts{'-expand_text'}|| undef;my$expand_ptree=$opts{'-expand_ptree'}|| undef;my$text=shift;my$line=shift;my$file=$self->input_file();my$cmd="";my$xseq_sub=$expand_seq;my$xtext_sub=$expand_text;my$xptree_sub=$expand_ptree;if (defined$expand_seq and $expand_seq eq 'interior_sequence'){$xseq_sub=sub {my ($sself,$iseq)=@_;my$args=join('',$iseq->parse_tree->children);return$sself->interior_sequence($iseq->name,$args,$iseq)}}ref$xseq_sub or $xseq_sub=sub {shift()->$expand_seq(@_)};ref$xtext_sub or $xtext_sub=sub {shift()->$expand_text(@_)};ref$xptree_sub or $xptree_sub=sub {shift()->$expand_ptree(@_)};my$seq=Pod::ParseTree->new();my@seq_stack=($seq);my ($ldelim,$rdelim)=('','');$_=$text;my@tokens=split /([A-Z]<(?:<+(?:\r?\n|[ \t]))?)/;while (@tokens){$_=shift@tokens;if (/^([A-Z])(<(?:<+(?:\r?\n|[ \t]))?)$/){my$ldelim_orig;($cmd,$ldelim_orig)=($1,$2);($ldelim=$ldelim_orig)=~ s/\s+$//;($rdelim=$ldelim)=~ tr/</>/;$seq=Pod::InteriorSequence->new(-name=>$cmd,-ldelim=>$ldelim_orig,-rdelim=>$rdelim,-file=>$file,-line=>$line);(@seq_stack > 1)and $seq->nested($seq_stack[-1]);push@seq_stack,$seq}elsif (@seq_stack > 1){my ($seq_end,$post_seq)=('','');if (($ldelim eq '<' and /\A(.*?)(>)/s)or /\A(.*?)(\s+$rdelim)/s){$post_seq=substr($_,length($1)+ length($2));($_,$seq_end)=($1,$2);(length$post_seq)and unshift@tokens,$post_seq}if (length){$seq->append($expand_text ? &$xtext_sub($self,$_,$seq): $_);$_ .= $seq_end}if (length$seq_end){$seq->rdelim($seq_end);pop@seq_stack;$seq_stack[-1]->append($expand_seq ? &$xseq_sub($self,$seq): $seq);if(@seq_stack > 1){$cmd=$seq_stack[-1]->name;$ldelim=$seq_stack[-1]->ldelim;$rdelim=$seq_stack[-1]->rdelim}else {$cmd=$ldelim=$rdelim=''}}}elsif (length){$seq->append($expand_text ? &$xtext_sub($self,$_,$seq): $_)}$line += /\n/;$seq=$seq_stack[-1]}my$errorsub=(@seq_stack > 1)? $self->errorsub(): undef;while (@seq_stack > 1){($cmd,$file,$line)=($seq->name,$seq->file_line);$ldelim=$seq->ldelim;($rdelim=$ldelim)=~ tr/</>/;$rdelim =~ s/^(\S+)(\s*)$/$2$1/;pop@seq_stack;my$errmsg="*** ERROR: unterminated ${cmd}${ldelim}...${rdelim}"." at line $line in file $file\n";(ref$errorsub)and &{$errorsub}($errmsg)or (defined$errorsub)and $self->$errorsub($errmsg)or carp($errmsg);$seq_stack[-1]->append($expand_seq ? &$xseq_sub($self,$seq): $seq);$seq=$seq_stack[-1]}my$ptree=(pop@seq_stack)->parse_tree;return$expand_ptree ? &$xptree_sub($self,$ptree): $ptree}sub interpolate {my($self,$text,$line_num)=@_;my%parse_opts=(-expand_seq=>'interior_sequence');my$ptree=$self->parse_text(\%parse_opts,$text,$line_num);return join '',$ptree->children()}sub parse_paragraph {my ($self,$text,$line_num)=@_;local*myData=$self;local*myOpts=($myData{_PARSEOPTS}||= {});local $_;my$wantNonPods=$myOpts{'-want_nonPODs'};$myData{_CUTTING}=0 if$text =~ /^={1,2}\S/;$wantNonPods and $text=$self->preprocess_paragraph($text,$line_num);return if$myData{_CUTTING};if (exists$myData{_SELECTED_SECTIONS}){$self->is_selected($text)or return ($myData{_CUTTING}=1)}unless ($wantNonPods){$text=$self->preprocess_paragraph($text,$line_num);return 1 unless ((defined$text)and (length$text));return 1 if ($myData{_CUTTING})}my ($pfx,$cmd,$arg,$sep)=('','','','');my$pod_para=undef;if ($text =~ /^(={1,2})(?=\S)/){$pfx=$1;$_=substr($text,length$pfx);($cmd,$sep,$text)=split /(\s+)/,$_,2;$sep='' unless defined$sep;$text='' unless defined$text;if ($cmd eq 'cut'){$myData{_CUTTING}=1;return unless$myOpts{'-process_cut_cmd'}}}$pod_para=new Pod::Paragraph(-name=>$cmd,-text=>$text,-prefix=>$pfx,-separator=>$sep,-file=>$myData{_INFILE},-line=>$line_num);if ($myData{_WHITESPACE}and $myOpts{'-warnings'}and not ($text =~ /^\s+/ and ($myData{_PREVIOUS}||"")eq "verbatim")){my$errorsub=$self->errorsub();my$line=$line_num - 1;my$errmsg="*** WARNING: line containing nothing but whitespace"." in paragraph at line $line in file $myData{_INFILE}\n";(ref$errorsub)and &{$errorsub}($errmsg)or (defined$errorsub)and $self->$errorsub($errmsg)or carp($errmsg)}if (length$cmd){$self->command($cmd,$text,$line_num,$pod_para);$myData{_PREVIOUS}=$cmd}elsif ($text =~ /^\s+/){$self->verbatim($text,$line_num,$pod_para);$myData{_PREVIOUS}="verbatim"}else {$self->textblock($text,$line_num,$pod_para);$myData{_PREVIOUS}="textblock"}$myData{_WHITESPACE}=$text =~ /^[^\S\r\n]+\r*\Z/m ? 1 : 0;return 1}sub parse_from_filehandle {my$self=shift;my%opts=(ref $_[0]eq 'HASH')? %{shift()}: ();my ($in_fh,$out_fh)=@_;$in_fh=\*STDIN unless ($in_fh);local*myData=$self;local*myOpts=($myData{_PARSEOPTS}||= {});local $_;my$topstream=$self->_push_input_stream($in_fh,$out_fh);(exists$opts{-cutting})and $self->cutting($opts{-cutting});my ($textline,$paragraph)=('','');my ($nlines,$plines)=(0,0);$_=ref$in_fh;my$tied_fh=(/^(?:GLOB|FileHandle|IO::\w+)$/ or tied$in_fh);while (defined ($textline=$tied_fh ? <$in_fh> : $in_fh->getline)){$textline=$self->preprocess_line($textline,++$nlines);next unless ((defined$textline)&& (length$textline));if ((!length$paragraph)&& ($textline =~ /^==/)){$paragraph=$textline;$plines=1;$textline=''}else {$paragraph .= $textline;++$plines}next unless (($textline =~ /^[^\S\r\n]*[\r\n]*$/)&& (length$paragraph));parse_paragraph($self,$paragraph,($nlines - $plines)+ 1);$paragraph='';$plines=0}if (length$paragraph){parse_paragraph($self,$paragraph,($nlines - $plines)+ 1)}$self->_pop_input_stream()}sub parse_from_file {my$self=shift;my%opts=(ref $_[0]eq 'HASH')? %{shift()}: ();my ($infile,$outfile)=@_;my ($in_fh,$out_fh);if ($] < 5.006){($in_fh,$out_fh)=(gensym(),gensym())}my ($close_input,$close_output)=(0,0);local*myData=$self;local*_;if (defined$infile && ref$infile){if (ref($infile)=~ /^(SCALAR|ARRAY|HASH|CODE|REF)$/){croak "Input from $1 reference not supported!\n"}$myData{_INFILE}=${$infile};$in_fh=$infile}elsif (!defined($infile)||!length($infile)|| ($infile eq '-')|| ($infile =~ /^<&(?:STDIN|0)$/i)){$infile ||= '-';$myData{_INFILE}='<standard input>';$in_fh=\*STDIN}else {$myData{_INFILE}=$infile;open($in_fh,"< $infile")or croak "Can't open $infile for reading: $!\n";$close_input=1}if (ref$outfile){if (ref($outfile)=~ /^(ARRAY|HASH|CODE)$/){croak "Output to $1 reference not supported!\n"}elsif (ref($outfile)eq 'SCALAR'){croak "Output to SCALAR reference not supported!\n"}else {$myData{_OUTFILE}=${$outfile};$out_fh=$outfile}}elsif (!defined($outfile)||!length($outfile)|| ($outfile eq '-')|| ($outfile =~ /^>&?(?:STDOUT|1)$/i)){if (defined$myData{_TOP_STREAM}){$out_fh=$myData{_OUTPUT}}else {$outfile ||= '-';$myData{_OUTFILE}='<standard output>';$out_fh=\*STDOUT}}elsif ($outfile =~ /^>&(STDERR|2)$/i){$myData{_OUTFILE}='<standard error>';$out_fh=\*STDERR}else {$myData{_OUTFILE}=$outfile;(-d $outfile)and croak "$outfile is a directory, not POD input!\n";open($out_fh,"> $outfile")or croak "Can't open $outfile for writing: $!\n";$close_output=1}$self->parse_from_filehandle(\%opts,$in_fh,$out_fh);$close_input and close($in_fh)|| croak "Can't close $infile after reading: $!\n";$close_output and close($out_fh)|| croak "Can't close $outfile after writing: $!\n"}sub errorsub {return (@_ > 1)? ($_[0]->{_ERRORSUB}=$_[1]): $_[0]->{_ERRORSUB}}sub cutting {return (@_ > 1)? ($_[0]->{_CUTTING}=$_[1]): $_[0]->{_CUTTING}}sub parseopts {local*myData=shift;local*myOpts=($myData{_PARSEOPTS}||= {});return%myOpts if (@_==0);if (@_==1){local $_=shift;return ref($_)? $myData{_PARSEOPTS}=$_ : $myOpts{$_}}my@newOpts=(%myOpts,@_);$myData{_PARSEOPTS}={@newOpts }}sub output_file {return $_[0]->{_OUTFILE}}sub output_handle {return $_[0]->{_OUTPUT}}sub input_file {return $_[0]->{_INFILE}}sub input_handle {return $_[0]->{_INPUT}}sub input_streams {return $_[0]->{_INPUT_STREAMS}}sub top_stream {return $_[0]->{_TOP_STREAM}|| undef}sub _push_input_stream {my ($self,$in_fh,$out_fh)=@_;local*myData=$self;unless (defined$myData{_TOP_STREAM}){$out_fh=\*STDOUT unless (defined$out_fh);$myData{_CUTTING}=1;$myData{_INPUT_STREAMS}=[]}$myData{_OUTFILE}='(unknown)' unless (defined$myData{_OUTFILE});$myData{_OUTPUT}=$out_fh if (defined$out_fh);$in_fh=\*STDIN unless (defined$in_fh);$myData{_INFILE}='(unknown)' unless (defined$myData{_INFILE});$myData{_INPUT}=$in_fh;my$input_top=$myData{_TOP_STREAM}=new Pod::InputSource(-name=>$myData{_INFILE},-handle=>$in_fh,-was_cutting=>$myData{_CUTTING});local*input_stack=$myData{_INPUT_STREAMS};push(@input_stack,$input_top);$self->begin_pod()if (@input_stack==1);$self->begin_input();return$input_top}sub _pop_input_stream {my ($self)=@_;local*myData=$self;local*input_stack=$myData{_INPUT_STREAMS};$self->end_input()if (@input_stack > 0);$self->end_pod()if (@input_stack==1);my$old_top=pop(@input_stack);$myData{_CUTTING}=$old_top->was_cutting();my$input_top=undef;if (@input_stack > 0){$input_top=$myData{_TOP_STREAM}=$input_stack[-1];$myData{_INFILE}=$input_top->name();$myData{_INPUT}=$input_top->handle()}else {delete$myData{_TOP_STREAM};delete$myData{_INPUT_STREAMS}}return$input_top}1;
POD_PARSER

$fatpacked{"Pod/PlainText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PLAINTEXT';
  package Pod::PlainText;use strict;require 5.005;use Carp qw(carp croak);use Pod::Select ();use vars qw(@ISA %ESCAPES $VERSION);@ISA=qw(Pod::Select);$VERSION='2.07';BEGIN {if ($] < 5.006){require Symbol;import Symbol}}%ESCAPES=('amp'=>'&','lt'=>'<','gt'=>'>','quot'=>'"',"Aacute"=>"\xC1","aacute"=>"\xE1","Acirc"=>"\xC2","acirc"=>"\xE2","AElig"=>"\xC6","aelig"=>"\xE6","Agrave"=>"\xC0","agrave"=>"\xE0","Aring"=>"\xC5","aring"=>"\xE5","Atilde"=>"\xC3","atilde"=>"\xE3","Auml"=>"\xC4","auml"=>"\xE4","Ccedil"=>"\xC7","ccedil"=>"\xE7","Eacute"=>"\xC9","eacute"=>"\xE9","Ecirc"=>"\xCA","ecirc"=>"\xEA","Egrave"=>"\xC8","egrave"=>"\xE8","ETH"=>"\xD0","eth"=>"\xF0","Euml"=>"\xCB","euml"=>"\xEB","Iacute"=>"\xCD","iacute"=>"\xED","Icirc"=>"\xCE","icirc"=>"\xEE","Igrave"=>"\xCD","igrave"=>"\xED","Iuml"=>"\xCF","iuml"=>"\xEF","Ntilde"=>"\xD1","ntilde"=>"\xF1","Oacute"=>"\xD3","oacute"=>"\xF3","Ocirc"=>"\xD4","ocirc"=>"\xF4","Ograve"=>"\xD2","ograve"=>"\xF2","Oslash"=>"\xD8","oslash"=>"\xF8","Otilde"=>"\xD5","otilde"=>"\xF5","Ouml"=>"\xD6","ouml"=>"\xF6","szlig"=>"\xDF","THORN"=>"\xDE","thorn"=>"\xFE","Uacute"=>"\xDA","uacute"=>"\xFA","Ucirc"=>"\xDB","ucirc"=>"\xFB","Ugrave"=>"\xD9","ugrave"=>"\xF9","Uuml"=>"\xDC","uuml"=>"\xFC","Yacute"=>"\xDD","yacute"=>"\xFD","yuml"=>"\xFF","lchevron"=>"\xAB","rchevron"=>"\xBB",);sub initialize {my$self=shift;$$self{alt}=0 unless defined $$self{alt};$$self{indent}=4 unless defined $$self{indent};$$self{loose}=0 unless defined $$self{loose};$$self{sentence}=0 unless defined $$self{sentence};$$self{width}=76 unless defined $$self{width};$$self{INDENTS}=[];$$self{MARGIN}=$$self{indent};return$self->SUPER::initialize}sub command {my$self=shift;my$command=shift;return if$command eq 'pod';return if ($$self{EXCLUDE}&& $command ne 'end');if (defined $$self{ITEM}){$self->item ("\n");local $_="\n";$self->output($_)if($command eq 'back')}$command='cmd_' .$command;return$self->$command (@_)}sub verbatim {my$self=shift;return if $$self{EXCLUDE};$self->item if defined $$self{ITEM};local $_=shift;return if /^\s*$/;s/^(\s*\S+)/(' ' x $$self{MARGIN}) . $1/gme;return$self->output($_)}sub textblock {my$self=shift;return if $$self{EXCLUDE};if($$self{VERBATIM}){$self->output($_[0]);return}local $_=shift;my$line=shift;s{
          (
            L<                    # A link of the form L</something>.
                /
                (
                    [:\w]+        # The item has to be a simple word...
                    (\(\))?       # ...or simple function.
                )
            >
            (
                ,?\s+(and\s+)?    # Allow lots of them, conjuncted.
                L<  
                    /
                    (
                        [:\w]+
                        (\(\))?
                    )
                >
            )+
          )
      } {
          local $_ = $1;
          s%L</([^>]+)>%$1%g;
          my @items = split /(?:,?\s+(?:and\s+)?)/;
          my $string = "the ";
          my $i;
          for ($i = 0; $i < @items; $i++) {
              $string .= $items[$i];
              $string .= ", " if @items > 2 && $i != $#items;
              $string .= " and " if ($i == $#items - 1);
          }
          $string .= " entries elsewhere in this document";
          $string;
      }gex;$_=$self->interpolate ($_,$line);s/\s*$/\n/s;if (defined $$self{ITEM}){$self->item ($_ ."\n")}else {$self->output ($self->reformat ($_ ."\n"))}}sub interior_sequence {my$self=shift;my$command=shift;local $_=shift;return '' if ($command eq 'X' || $command eq 'Z');if ($command eq 'E'){return$ESCAPES{$_}if defined$ESCAPES{$_};carp "Unknown escape: E<$_>";return "E<$_>"}return if $_ eq '';if ($command eq 'S'){s/\s{2,}/ /g;tr/ /\01/;return $_}if ($command eq 'B'){return$self->seq_b ($_)}elsif ($command eq 'C'){return$self->seq_c ($_)}elsif ($command eq 'F'){return$self->seq_f ($_)}elsif ($command eq 'I'){return$self->seq_i ($_)}elsif ($command eq 'L'){return$self->seq_l ($_)}else {carp "Unknown sequence $command<$_>"}}sub preprocess_paragraph {my$self=shift;local $_=shift;1 while s/^(.*?)(\t+)/$1 . ' ' x (length ($2) * 8 - length ($1) % 8)/me;return $_}sub cmd_head1 {my$self=shift;local $_=shift;s/\s+$//s;$_=$self->interpolate ($_,shift);if ($$self{alt}){$self->output ("\n==== $_ ====\n\n")}else {$_ .= "\n" if $$self{loose};$self->output ($_ ."\n")}}sub cmd_head2 {my$self=shift;local $_=shift;s/\s+$//s;$_=$self->interpolate ($_,shift);if ($$self{alt}){$self->output ("\n==   $_   ==\n\n")}else {$_ .= "\n" if $$self{loose};$self->output (' ' x ($$self{indent}/ 2).$_ ."\n")}}sub cmd_head3 {my$self=shift;local $_=shift;s/\s+$//s;$_=$self->interpolate ($_,shift);if ($$self{alt}){$self->output ("\n= $_ =\n")}else {$_ .= "\n" if $$self{loose};$self->output (' ' x ($$self{indent}).$_ ."\n")}}*cmd_head4=\&cmd_head3;sub cmd_over {my$self=shift;local $_=shift;unless (/^[-+]?\d+\s+$/){$_=$$self{indent}}push (@{$$self{INDENTS}},$$self{MARGIN});$$self{MARGIN}+= ($_ + 0)}sub cmd_back {my$self=shift;$$self{MARGIN}=pop @{$$self{INDENTS}};unless (defined $$self{MARGIN}){carp 'Unmatched =back';$$self{MARGIN}=$$self{indent}}}sub cmd_item {my$self=shift;if (defined $$self{ITEM}){$self->item}local $_=shift;s/\s+$//s;$$self{ITEM}=$self->interpolate ($_)}sub cmd_begin {my$self=shift;local $_=shift;my ($kind)=/^(\S+)/ or return;if ($kind eq 'text'){$$self{VERBATIM}=1}else {$$self{EXCLUDE}=1}}sub cmd_end {my$self=shift;$$self{EXCLUDE}=0;$$self{VERBATIM}=0}sub cmd_for {my$self=shift;local $_=shift;my$line=shift;return unless s/^text\b[ \t]*\r?\n?//;$self->verbatim ($_,$line)}sub cmd_encoding {return}sub seq_b {return $_[0]{alt}? "``$_[1]''" : $_[1]}sub seq_c {return $_[0]{alt}? "``$_[1]''" : "`$_[1]'"}sub seq_f {return $_[0]{alt}? "\"$_[1]\"" : $_[1]}sub seq_i {return '*' .$_[1].'*'}sub seq_l {my$self=shift;local $_=shift;s/\s+/ /g;if (/^([^|]+)\|/){return $1}s/^\s+//;s/\s+$//;my ($manpage,$section)=('',$_);if (/^(?:https?|ftp|news):/){return $_}elsif (/^"\s*(.*?)\s*"$/){$section='"' .$1 .'"'}elsif (m/^[-:.\w]+(?:\(\S+\))?$/){($manpage,$section)=($_,'')}elsif (m{/}){($manpage,$section)=split (/\s*\/\s*/,$_,2)}my$text='';if (!length$section){$text="the $manpage manpage" if length$manpage}elsif ($section =~ /^[:\w]+(?:\(\))?/){$text .= 'the ' .$section .' entry';$text .= (length$manpage)? " in the $manpage manpage" : ' elsewhere in this document'}else {$section =~ s/^\"\s*//;$section =~ s/\s*\"$//;$text .= 'the section on "' .$section .'"';$text .= " in the $manpage manpage" if length$manpage}return$text}sub item {my$self=shift;local $_=shift;my$tag=$$self{ITEM};unless (defined$tag){carp 'item called without tag';return}undef $$self{ITEM};my$indent=$$self{INDENTS}[-1];unless (defined$indent){$indent=$$self{indent}}my$space=' ' x $indent;$space =~ s/^ /:/ if $$self{alt};if (!$_ || /^\s+$/ || ($$self{MARGIN}- $indent < length ($tag)+ 1)){my$margin=$$self{MARGIN};$$self{MARGIN}=$indent;my$output=$self->reformat ($tag);$output =~ s/[\r\n]*$/\n/;$self->output ($output);$$self{MARGIN}=$margin;$self->output ($self->reformat ($_))if /\S/}else {$_=$self->reformat ($_);s/^ /:/ if ($$self{alt}&& $indent > 0);my$tagspace=' ' x length$tag;s/^($space)$tagspace/$1$tag/ or carp 'Bizarre space in item';$self->output ($_)}}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{width}- $$self{MARGIN};while (length > $width){if (s/^([^\r\n]{0,$width})\s+// || s/^([^\r\n]{$width})//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}sub reformat {my$self=shift;local $_=shift;if ($$self{sentence}){s/ +$//mg;s/\.\r?\n/. \n/g;s/[\r\n]+/ /g;s/   +/  /g}else {s/\s+/ /g}return$self->wrap($_)}sub output {$_[1]=~ tr/\01/ /;print {$_[0]->output_handle}$_[1]}sub pod2text {my@args;while ($_[0]=~ /^-/){my$flag=shift;if ($flag eq '-a'){push (@args,alt=>1)}elsif ($flag =~ /^-(\d+)$/){push (@args,width=>$1)}else {unshift (@_,$flag);last}}my$parser=Pod::PlainText->new (@args);if (defined $_[1]){my$infh;if ($] < 5.006){$infh=gensym()}unless (open ($infh,$_[0])){croak ("Can't open $_[0] for reading: $!\n")}$_[0]=$infh;return$parser->parse_from_filehandle (@_)}else {return$parser->parse_from_file (@_)}}1;
POD_PLAINTEXT

$fatpacked{"Pod/Select.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SELECT';
  package Pod::Select;use strict;use vars qw($VERSION @ISA @EXPORT $MAX_HEADING_LEVEL %myData @section_headings @selected_sections);$VERSION='1.63';require 5.005;use Carp;use Pod::Parser 1.04;@ISA=qw(Pod::Parser);@EXPORT=qw(&podselect);*MAX_HEADING_LEVEL=\3;sub _init_headings {my$self=shift;local*myData=$self;unless (defined$myData{_SECTION_HEADINGS}){local*section_headings=$myData{_SECTION_HEADINGS}=[];for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$section_headings[$i]=''}}}sub curr_headings {my$self=shift;$self->_init_headings()unless (defined$self->{_SECTION_HEADINGS});my@headings=@{$self->{_SECTION_HEADINGS}};return (@_ > 0 and $_[0]=~ /^\d+$/)? $headings[$_[0]- 1]: @headings}sub select {my ($self,@sections)=@_;local*myData=$self;local $_;my$add=($sections[0]eq '+')? shift(@sections): '';unless (@sections){delete$myData{_SELECTED_SECTIONS}unless ($add);return}$myData{_SELECTED_SECTIONS}=[]unless ($add && exists$myData{_SELECTED_SECTIONS});local*selected_sections=$myData{_SELECTED_SECTIONS};for my$spec (@sections){if (defined($_=_compile_section_spec($spec))){push(@selected_sections,$_)}else {carp qq{Ignoring section spec "$spec"!\n}}}}sub add_selection {my$self=shift;return$self->select('+',@_)}sub clear_selections {my$self=shift;return$self->select()}sub match_section {my$self=shift;my (@headings)=@_;local*myData=$self;my$selections=(exists$myData{_SELECTED_SECTIONS})? $myData{_SELECTED_SECTIONS}: undef;return 1 unless ((defined$selections)&& @{$selections});my@current_headings=$self->curr_headings();for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){(defined$headings[$i])or $headings[$i]=$current_headings[$i]}for my$section_spec (@{$selections}){my$match=1;for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){my$regex=$section_spec->[$i];my$negated=($regex =~ s/^\!//);$match &= ($negated ? ($headings[$i]!~ /${regex}/): ($headings[$i]=~ /${regex}/));last unless ($match)}return 1 if ($match)}return 0}sub is_selected {my ($self,$paragraph)=@_;local $_;local*myData=$self;$self->_init_headings()unless (defined$myData{_SECTION_HEADINGS});$_=$paragraph;if (/^=((?:sub)*)(?:head(?:ing)?|sec(?:tion)?)(\d*)\s+(.*?)\s*$/){my ($level,$heading)=($2,$3);$level=1 + (length($1)/ 3)if ((!length$level)|| (length $1));$myData{_SECTION_HEADINGS}->[$level - 1]=$heading;for (my$i=$level;$i < $MAX_HEADING_LEVEL;++$i){$myData{_SECTION_HEADINGS}->[$i]=''}}return$self->match_section()}sub podselect {my(@argv)=@_;my%defaults=();my$pod_parser=new Pod::Select(%defaults);my$num_inputs=0;my$output='>&STDOUT';my%opts;local $_;for (@argv){my$ref=ref($_);if ($ref && $ref eq 'HASH'){%opts=(%defaults,%{$_});%opts=map {my ($key,$val)=(lc $_,$opts{$_});$key =~ s/^(?=\w)/-/;$key =~ /^-se[cl]/ and $key='-sections';($key=>$val)}(keys%opts);(exists$opts{'-output'})and $output=$opts{'-output'};$pod_parser->select(@{$opts{'-sections'}})if ((defined$opts{'-sections'})&& ((ref$opts{'-sections'})eq 'ARRAY'))}elsif(!$ref || $ref eq 'GLOB'){$pod_parser->parse_from_file($_,$output);++$num_inputs}else {croak "Input from $ref reference not supported!\n"}}$pod_parser->parse_from_file('-')unless ($num_inputs > 0)}sub _compile_section_spec {my ($section_spec)=@_;my (@regexs,$negated);local $_=$section_spec;s{\\\\}{\001}g;s{\\/}{\002}g;@regexs=split(/\//,$_,$MAX_HEADING_LEVEL);for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$regexs[$i]='.*' unless ((defined$regexs[$i])&& (length$regexs[$i]))}my$bad_regexs=0;for (@regexs){$_ .= '.+' if ($_ eq '!');s{\001}{\\\\}g;s{\002}{\\/}g;$negated=s/^\!//;eval "m{$_}";if ($@){++$bad_regexs;carp qq{Bad regular expression /$_/ in "$section_spec": $@\n}}else {$_='^' .$_ unless (/^\^/);$_=$_ .'$' unless (/\$$/);$_='!' .$_ if ($negated)}}return (!$bad_regexs)? [@regexs ]: undef}1;
POD_SELECT

$fatpacked{"Pod/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE';
  require 5;package Pod::Simple;use strict;use Carp ();BEGIN {*DEBUG=sub () {0}unless defined&DEBUG}use integer;use Pod::Escapes 1.04 ();use Pod::Simple::LinkSection ();use Pod::Simple::BlackBox ();use vars qw($VERSION @ISA @Known_formatting_codes @Known_directives %Known_formatting_codes %Known_directives $NL);@ISA=('Pod::Simple::BlackBox');$VERSION='3.35';@Known_formatting_codes=qw(I B C L E F S X Z);%Known_formatting_codes=map(($_=>1),@Known_formatting_codes);@Known_directives=qw(head1 head2 head3 head4 item over back);%Known_directives=map(($_=>'Plain'),@Known_directives);$NL=$/ unless defined$NL;BEGIN {if(defined&ASCII){}elsif(chr(65)eq 'A'){*ASCII=sub () {1}}else {*ASCII=sub () {''}}unless(defined&MANY_LINES){*MANY_LINES=sub () {20}}DEBUG > 4 and print STDERR "MANY_LINES is ",MANY_LINES(),"\n";unless(MANY_LINES()>= 1){die "MANY_LINES is too small (",MANY_LINES(),")!\nAborting"}if(defined&UNICODE){}elsif($] >= 5.008){*UNICODE=sub() {1}}else {*UNICODE=sub() {''}}}if(DEBUG > 2){print STDERR "# We are ",ASCII ? '' : 'not ',"in ASCII-land\n";print STDERR "# We are under a Unicode-safe Perl.\n"}if ($] ge 5.007_003){$Pod::Simple::nbsp=chr utf8::unicode_to_native(0xA0);$Pod::Simple::shy=chr utf8::unicode_to_native(0xAD)}elsif (Pod::Simple::ASCII){$Pod::Simple::nbsp="\xA0";$Pod::Simple::shy="\xAD"}else {$Pod::Simple::nbsp="\x41";$Pod::Simple::shy="\xCA"}__PACKAGE__->_accessorize('nbsp_for_S','source_filename','source_dead','output_fh','hide_line_numbers','line_count','pod_para_count','no_whining','no_errata_section','complain_stderr','doc_has_started','bare_output','keep_encoding_directive','nix_X_codes','merge_text','preserve_whitespace','strip_verbatim_indent','parse_characters','content_seen','errors_seen','codes_in_verbatim','code_handler','cut_handler','pod_handler','whiteline_handler','parse_empty_lists','raw_mode',);sub any_errata_seen {return shift->{'errors_seen'}|| 0}sub errata_seen {return shift->{'all_errata'}|| {}}sub detected_encoding {return shift->{'detected_encoding'}}sub encoding {my$this=shift;return$this->{'encoding'}unless @_;$this->_handle_encoding_line("=encoding $_[0]");if ($this->{'_processed_encoding'}){delete$this->{'_processed_encoding'};if(!$this->{'encoding_command_statuses'}){DEBUG > 2 and print STDERR " CRAZY ERROR: encoding wasn't really handled?!\n"}elsif($this->{'encoding_command_statuses'}[-1]){$this->scream("=encoding $_[0]",sprintf "Couldn't do %s: %s",$this->{'encoding_command_reqs' }[-1],$this->{'encoding_command_statuses'}[-1],)}else {DEBUG > 2 and print STDERR " (encoding successfully handled.)\n"}return$this->{'encoding'}}else {return undef}}BEGIN {*pretty=\&Pod::Simple::BlackBox::pretty;*stringify_lol=\&Pod::Simple::BlackBox::stringify_lol}sub version_report {my$class=ref($_[0])|| $_[0];if($class eq __PACKAGE__){return "$class $VERSION"}else {my$v=$class->VERSION;return "$class $v (" .__PACKAGE__ ." $VERSION)"}}sub output_string {my$this=shift;return$this->{'output_string'}unless @_;require Pod::Simple::TiedOutFH;my$x=(defined($_[0])and ref($_[0]))? $_[0]: \($_[0]);$$x='' unless defined $$x;DEBUG > 4 and print STDERR "# Output string set to $x ($$x)\n";$this->{'output_fh'}=Pod::Simple::TiedOutFH->handle_on($_[0]);return $this->{'output_string'}=$_[0]}sub abandon_output_string {$_[0]->abandon_output_fh;delete $_[0]{'output_string'}}sub abandon_output_fh {$_[0]->output_fh(undef)}sub new {my$class=ref($_[0])|| $_[0];return bless {'accept_codes'=>{map(($_=>$_),@Known_formatting_codes)},'accept_directives'=>{%Known_directives },'accept_targets'=>{},},$class}sub _handle_element_start {my($self,$element_name,$attr_hash_r)=@_;return}sub _handle_element_end {my($self,$element_name)=@_;return}sub _handle_text {my($self,$text)=@_;return}sub accept_directive_as_verbatim {shift->_accept_directives('Verbatim',@_)}sub accept_directive_as_data {shift->_accept_directives('Data',@_)}sub accept_directive_as_processed {shift->_accept_directives('Plain',@_)}sub _accept_directives {my($this,$type)=splice @_,0,2;for my$d (@_){next unless defined$d and length$d;Carp::croak "\"$d\" isn't a valid directive name" unless$d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;Carp::croak "\"$d\" is already a reserved Pod directive name" if exists$Known_directives{$d};$this->{'accept_directives'}{$d}=$type;DEBUG > 2 and print STDERR "Learning to accept \"=$d\" as directive of type $type\n"}DEBUG > 6 and print STDERR "$this\'s accept_directives : ",pretty($this->{'accept_directives'}),"\n";return sort keys %{$this->{'accept_directives'}}if wantarray;return}sub unaccept_directive {shift->unaccept_directives(@_)};sub unaccept_directives {my$this=shift;for my$d (@_){next unless defined$d and length$d;Carp::croak "\"$d\" isn't a valid directive name" unless$d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;Carp::croak "But you must accept \"$d\" directives -- it's a builtin!" if exists$Known_directives{$d};delete$this->{'accept_directives'}{$d};DEBUG > 2 and print STDERR "OK, won't accept \"=$d\" as directive.\n"}return sort keys %{$this->{'accept_directives'}}if wantarray;return}sub accept_target {shift->accept_targets(@_)}sub accept_target_as_text {shift->accept_targets_as_text(@_)}sub accept_targets {shift->_accept_targets('1',@_)}sub accept_targets_as_text {shift->_accept_targets('force_resolve',@_)}sub _accept_targets {my($this,$type)=splice @_,0,2;for my$t (@_){next unless defined$t and length$t;$this->{'accept_targets'}{$t}=$type;DEBUG > 2 and print STDERR "Learning to accept \"$t\" as target of type $type\n"}return sort keys %{$this->{'accept_targets'}}if wantarray;return}sub unaccept_target {shift->unaccept_targets(@_)}sub unaccept_targets {my$this=shift;for my$t (@_){next unless defined$t and length$t;delete$this->{'accept_targets'}{$t};DEBUG > 2 and print STDERR "OK, won't accept \"$t\" as target.\n"}return sort keys %{$this->{'accept_targets'}}if wantarray;return}my$xml_name_re=eval "qr/[^-.0-8:A-Z_a-z[:^ascii:]]/";if (!defined$xml_name_re){$xml_name_re=qr/[\x00-\x2C\x2F\x39\x3B-\x40\x5B-\x5E\x60\x7B-\x7F]/}sub accept_code {shift->accept_codes(@_)}sub accept_codes {my$this=shift;for my$new_code (@_){next unless defined$new_code and length$new_code;Carp::croak "\"$new_code\" isn't a valid element name" if$new_code =~ $xml_name_re or $new_code =~ m/^[-\.0-9]/s or $new_code =~ m/:[-\.0-9]/s;$this->{'accept_codes'}{$new_code}=$new_code}return}sub unaccept_code {shift->unaccept_codes(@_)}sub unaccept_codes {my$this=shift;for my$new_code (@_){next unless defined$new_code and length$new_code;Carp::croak "\"$new_code\" isn't a valid element name" if$new_code =~ $xml_name_re or $new_code =~ m/^[-\.0-9]/s or $new_code =~ m/:[-\.0-9]/s;Carp::croak "But you must accept \"$new_code\" codes -- it's a builtin!" if grep$new_code eq $_,@Known_formatting_codes;delete$this->{'accept_codes'}{$new_code};DEBUG > 2 and print STDERR "OK, won't accept the code $new_code<...>.\n"}return}sub parse_string_document {my$self=shift;my@lines;for my$line_group (@_){next unless defined$line_group and length$line_group;pos($line_group)=0;while($line_group =~ m/([^\n\r]*)(\r?\n?)/g){$self->parse_lines($1)if length($1)or length($2)or pos($line_group)!=length($line_group)}}$self->parse_lines(undef);return$self}sub _init_fh_source {my($self,$source)=@_;return}sub parse_file {my($self,$source)=(@_);if(!defined$source){Carp::croak("Can't use empty-string as a source for parse_file")}elsif(ref(\$source)eq 'GLOB'){$self->{'source_filename'}='' .($source)}elsif(ref$source){$self->{'source_filename'}='' .($source)}elsif(!length$source){Carp::croak("Can't use empty-string as a source for parse_file")}else {{local*PODSOURCE;open(PODSOURCE,"<$source")|| Carp::croak("Can't open $source: $!");$self->{'source_filename'}=$source;$source=*PODSOURCE{IO}}$self->_init_fh_source($source)}$self->{'source_fh'}=$source;my($i,@lines);until($self->{'source_dead'}){splice@lines;for($i=MANY_LINES;$i--;){local $/=$NL;push@lines,scalar(<$source>);last unless defined$lines[-1]}my$at_eof=!$lines[-1];pop@lines if$at_eof;s/\r\n?/\n/g for@lines;@lines=split(/(?<=\n)/,join('',@lines));push@lines,undef if$at_eof;$self->parse_lines(@lines)}delete($self->{'source_fh'});return$self}sub parse_from_file {my($self,$source,$to)=@_;$self=$self->new unless ref($self);if(!defined$source){$source=*STDIN{IO}}elsif(ref(\$source)eq 'GLOB'){}elsif(ref($source)){}elsif(!length$source or $source eq '-' or $source =~ m/^<&(?:STDIN|0)$/i){$source=*STDIN{IO}}if(!defined$to){$self->output_fh(*STDOUT{IO})}elsif(ref(\$to)eq 'GLOB'){$self->output_fh($to)}elsif(ref($to)){$self->output_fh($to)}elsif(!length$to or $to eq '-' or $to =~ m/^>&?(?:STDOUT|1)$/i){$self->output_fh(*STDOUT{IO})}elsif($to =~ m/^>&(?:STDERR|2)$/i){$self->output_fh(*STDERR{IO})}else {require Symbol;my$out_fh=Symbol::gensym();DEBUG and print STDERR "Write-opening to $to\n";open($out_fh,">$to")or Carp::croak "Can't write-open $to: $!";binmode($out_fh)if$self->can('write_with_binmode')and $self->write_with_binmode;$self->output_fh($out_fh)}return$self->parse_file($source)}sub whine {my$self=shift(@_);++$self->{'errors_seen'};if($self->{'no_whining'}){DEBUG > 9 and print STDERR "Discarding complaint (at line $_[0]) $_[1]\n because no_whining is on.\n";return}push @{$self->{'all_errata'}{$_[0]}},$_[1];return$self->_complain_warn(@_)if$self->{'complain_stderr'};return$self->_complain_errata(@_)}sub scream {my$self=shift(@_);++$self->{'errors_seen'};push @{$self->{'all_errata'}{$_[0]}},$_[1];return$self->_complain_warn(@_)if$self->{'complain_stderr'};return$self->_complain_errata(@_)}sub _complain_warn {my($self,$line,$complaint)=@_;return printf STDERR "%s around line %s: %s\n",$self->{'source_filename'}|| 'Pod input',$line,$complaint}sub _complain_errata {my($self,$line,$complaint)=@_;if($self->{'no_errata_section'}){DEBUG > 9 and print STDERR "Discarding erratum (at line $line) $complaint\n because no_errata_section is on.\n"}else {DEBUG > 9 and print STDERR "Queuing erratum (at line $line) $complaint\n";push @{$self->{'errata'}{$line}},$complaint}return 1}sub _get_initial_item_type {my($self,$para)=@_;return$para->[1]{'~type'}if$para->[1]{'~type'};return$para->[1]{'~type'}='text' if join("\n",@{$para}[2 .. $#$para])=~ m/^\s*(\d+)\.?\s*$/s and $1 ne '1';return$self->_get_item_type($para)}sub _get_item_type {my($self,$para)=@_;return$para->[1]{'~type'}if$para->[1]{'~type'};my$content=join "\n",@{$para}[2 .. $#$para];if($content =~ m/^\s*\*\s*$/s or $content =~ m/^\s*$/s){splice @$para,2;$para->[1]{'~orig_content'}=$content;return$para->[1]{'~type'}='bullet'}elsif($content =~ m/^\s*\*\s+(.+)/s){$para->[1]{'~orig_content'}=$content;$para->[1]{'~_freaky_para_hack'}=$1;DEBUG > 2 and print STDERR " Tolerating $$para[2] as =item *\\n\\n$1\n";splice @$para,2;return$para->[1]{'~type'}='bullet'}elsif($content =~ m/^\s*(\d+)\.?\s*$/s){$para->[1]{'~orig_content'}=$content;$para->[1]{'number'}=$1;splice @$para,2;return$para->[1]{'~type'}='number'}else {return$para->[1]{'~type'}='text'}}sub _make_treelet {my$self=shift;my$treelet;if(!@_){return ['']}if(ref $_[0]and ref $_[0][0]and $_[0][0][0]eq '~Top'){DEBUG and print STDERR "Applying precooked treelet hack to $_[0][0]\n";$treelet=$_[0][0];splice @$treelet,0,2;return$treelet}else {$treelet=$self->_treelet_from_formatting_codes(@_)}if($self->_remap_sequences($treelet)){$self->_treat_Zs($treelet);$self->_treat_Ls($treelet);$self->_treat_Es($treelet);$self->_treat_Ss($treelet);$self->_wrap_up($treelet)}else {DEBUG and print STDERR "Formatless treelet gets fast-tracked.\n"}splice @$treelet,0,2;return$treelet}sub _wrap_up {my($self,@stack)=@_;my$nixx=$self->{'nix_X_codes'};my$merge=$self->{'merge_text' };return unless$nixx or $merge;DEBUG > 2 and print STDERR "\nStarting _wrap_up traversal.\n",$merge ? (" Merge mode on\n"): (),$nixx ? (" Nix-X mode on\n"): (),;my($i,$treelet);while($treelet=shift@stack){DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";for($i=2;$i < @$treelet;++$i){DEBUG > 3 and print STDERR " Considering child at $i ",pretty($treelet->[$i]),"\n";if($nixx and ref$treelet->[$i]and $treelet->[$i][0]eq 'X'){DEBUG > 3 and print STDERR "   Nixing X node at $i\n";splice(@$treelet,$i,1);redo}elsif($merge and $i!=2 and !ref$treelet->[$i]and!ref$treelet->[$i - 1]){DEBUG > 3 and print STDERR "   Merging ",$i-1,":[$treelet->[$i-1]] and $i\:[$treelet->[$i]]\n";$treelet->[$i-1].= (splice(@$treelet,$i,1))[0];DEBUG > 4 and print STDERR "    Now: ",$i-1,":[$treelet->[$i-1]]\n";--$i;next}elsif(ref$treelet->[$i]){DEBUG > 4 and print STDERR "  Enqueuing ",pretty($treelet->[$i])," for traversal.\n";push@stack,$treelet->[$i];if($treelet->[$i][0]eq 'L'){my$thing;for my$attrname ('section','to'){if(defined($thing=$treelet->[$i][1]{$attrname})and ref$thing){unshift@stack,$thing;DEBUG > 4 and print STDERR "  +Enqueuing ",pretty($treelet->[$i][1]{$attrname})," as an attribute value to tweak.\n"}}}}}}DEBUG > 2 and print STDERR "End of _wrap_up traversal.\n\n";return}sub _remap_sequences {my($self,@stack)=@_;if(@stack==1 and @{$stack[0]}==3 and!ref$stack[0][2]){DEBUG and print STDERR "Skipping _remap_sequences: formatless treelet.\n";return 0}my$map=($self->{'accept_codes'}|| die "NO accept_codes in $self?!?");my$start_line=$stack[0][1]{'start_line'};DEBUG > 2 and printf "\nAbout to start _remap_sequences on treelet from line %s.\n",$start_line || '[?]' ;DEBUG > 3 and print STDERR " Map: ",join('; ',map "$_=" .(ref($map->{$_})? join(",",@{$map->{$_}}): $map->{$_}),sort keys %$map),("B~C~E~F~I~L~S~X~Z" eq join '~',sort keys %$map)? "  (all normal)\n" : "\n" ;my($is,$was,$i,$treelet);while($treelet=shift@stack){DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";for($i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];DEBUG > 4 and print STDERR "  Noting child $i : $treelet->[$i][0]<...>\n";$is=$treelet->[$i][0]=$map->{$was=$treelet->[$i][0]};if(DEBUG > 3){if(!defined$is){print STDERR "   Code $was<> is UNKNOWN!\n"}elsif($is eq $was){DEBUG > 4 and print STDERR "   Code $was<> stays the same.\n"}else {print STDERR "   Code $was<> maps to ",ref($is)? ("tags ",map("$_<",@$is),'...',map('>',@$is),"\n"): "tag $is<...>.\n"}}if(!defined$is){$self->whine($start_line,"Deleting unknown formatting code $was<>");$is=$treelet->[$i][0]='1'}if(ref$is){my@dynasty=@$is;DEBUG > 4 and print STDERR "    Renaming $was node to $dynasty[-1]\n";$treelet->[$i][0]=pop@dynasty;my$nugget;while(@dynasty){DEBUG > 4 and printf "    Grafting a new %s node between %s and %s\n",$dynasty[-1],$treelet->[0],$treelet->[$i][0],;splice @$treelet,$i,1,[pop(@dynasty),{},$treelet->[$i]]}}elsif($is eq '0'){splice(@$treelet,$i,1);--$i}elsif($is eq '1'){splice(@$treelet,$i,1 =>splice @{$treelet->[$i]},2);--$i}else {unshift@stack,$treelet->[$i]}}}DEBUG > 2 and print STDERR "End of _remap_sequences traversal.\n\n";if(@_==2 and @{$_[1]}==3 and!ref $_[1][2]){DEBUG and print STDERR "Noting that the treelet is now formatless.\n";return 0}return 1}sub _ponder_extend {my($self,$para)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG > 2 and print STDERR "Ogling extensor: =extend $content\n";if($content =~ m/^
        (\S+)         # 1 : new item
        \s+
        (\S+)         # 2 : fallback(s)
        (?:\s+(\S+))? # 3 : element name(s)
        \s*
        $
      /xs){my$new_letter=$1;my$fallbacks_one=$2;my$elements_one;$elements_one=defined($3)? $3 : $1;DEBUG > 2 and print STDERR "Extensor has good syntax.\n";unless($new_letter =~ m/^[A-Z]$/s or $new_letter){DEBUG > 2 and print STDERR " $new_letter isn't a valid thing to entend.\n";$self->whine($para->[1]{'start_line'},"You can extend only formatting codes A-Z, not like \"$new_letter\"");return}if(grep$new_letter eq $_,@Known_formatting_codes){DEBUG > 2 and print STDERR " $new_letter isn't a good thing to extend, because known.\n";$self->whine($para->[1]{'start_line'},"You can't extend an established code like \"$new_letter\"");return}unless($fallbacks_one =~ m/^[A-Z](,[A-Z])*$/s or $fallbacks_one eq '0' or $fallbacks_one eq '1'){$self->whine($para->[1]{'start_line'},"Format for second =extend parameter must be like" ." M or 1 or 0 or M,N or M,N,O but you have it like " .$fallbacks_one);return}unless($elements_one =~ m/^[^ ,]+(,[^ ,]+)*$/s){$self->whine($para->[1]{'start_line'},"Format for third =extend parameter: like foo or bar,Baz,qu:ux but not like " .$elements_one);return}my@fallbacks=split ',',$fallbacks_one,-1;my@elements=split ',',$elements_one,-1;for my$f (@fallbacks){next if exists$Known_formatting_codes{$f}or $f eq '0' or $f eq '1';DEBUG > 2 and print STDERR "  Can't fall back on unknown code $f\n";$self->whine($para->[1]{'start_line'},"Can't use unknown formatting code '$f' as a fallback for '$new_letter'");return}DEBUG > 3 and printf STDERR "Extensor: Fallbacks <%s> Elements <%s>.\n",@fallbacks,@elements;my$canonical_form;for my$e (@elements){if(exists$self->{'accept_codes'}{$e}){DEBUG > 1 and print STDERR " Mapping '$new_letter' to known extension '$e'\n";$canonical_form=$e;last}else {DEBUG > 1 and print STDERR " Can't map '$new_letter' to unknown extension '$e'\n"}}if(defined$canonical_form){$self->{'accept_codes'}{$new_letter}=$canonical_form;DEBUG > 2 and print "Extensor maps $new_letter => known element $canonical_form.\n"}else {$self->{'accept_codes'}{$new_letter}=(@fallbacks==1)? $fallbacks[0]: \@fallbacks;DEBUG > 2 and print "Extensor maps $new_letter => fallbacks @fallbacks.\n"}}else {DEBUG > 2 and print STDERR "Extensor has bad syntax.\n";$self->whine($para->[1]{'start_line'},"Unknown =extend syntax: $content")}return}sub _treat_Zs {my($self,@stack)=@_;my($i,$treelet);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for($i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];unless($treelet->[$i][0]eq 'Z'){unshift@stack,$treelet->[$i];next}DEBUG > 1 and print STDERR "Nixing Z node @{$treelet->[$i]}\n";unless(@{$treelet->[$i]}==2 or (@{$treelet->[$i]}==3 and $treelet->[$i][2]eq '')){$self->whine($start_line,"A non-empty Z<>")}splice(@$treelet,$i,1);--$i}}return}sub _treat_Ls {my($self,@stack)=@_;my($i,$treelet);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for(my$i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];unless($treelet->[$i][0]eq 'L'){unshift@stack,$treelet->[$i];next}my$ell=$treelet->[$i];DEBUG > 1 and print STDERR "Ogling L node $ell\n";if(@{$ell}==2 or (@{$ell}==3 and $ell->[2]eq '')){$self->whine($start_line,"An empty L<>");$treelet->[$i]='L<>';next}if((!ref$ell->[2]&& $ell->[2]=~ /\A\s/)||(!ref$ell->[-1]&& $ell->[-1]=~ /\s\z/)){$self->whine($start_line,"L<> starts or ends with whitespace")}if (my ($url_index,$text_part,$url_part)=sub {for (2..$#$ell){next if ref$ell->[$_];next unless$ell->[$_]=~ m/^(?:([^|]*)\|)?(\w+:[^:\s]\S*)$/s;return ($_,$1,$2)}return}->()){$ell->[1]{'type'}='url';my@text=@{$ell}[2..$url_index-1];push@text,$text_part if defined$text_part;my@url=@{$ell}[$url_index+1..$#$ell];unshift@url,$url_part;unless (@text){$ell->[1]{'content-implicit'}='yes';@text=@url}$ell->[1]{to}=Pod::Simple::LinkSection->new(@url==1 ? $url[0]: ['',{},@url ],);splice @$ell,2,$#$ell,@text;next}if(@{$ell}==3 and!ref$ell->[2]){my$it=$ell->[2];if($it =~ m{^[^/|]+[(][-a-zA-Z0-9]+[)]$}s){DEBUG > 1 and print STDERR "Catching \"$it\" as manpage link.\n";$ell->[1]{'type'}='man';$ell->[1]{'content-implicit'}='yes';$ell->[1]{'to' }=Pod::Simple::LinkSection->new($it);next}if($it =~ m/^[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+(\:\:[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+)*$/s){DEBUG > 1 and print STDERR "Catching \"$it\" as ho-hum L<Modulename> link.\n";$ell->[1]{'type'}='pod';$ell->[1]{'content-implicit'}='yes';$ell->[1]{'to' }=Pod::Simple::LinkSection->new($it);next}}DEBUG > 1 and print STDERR "Running a real parse on this non-trivial L\n";my$link_text;my@ell_content=@$ell;splice@ell_content,0,2;DEBUG > 3 and print STDERR " Ell content to start: ",pretty(@ell_content),"\n";DEBUG > 3 and print STDERR "  Peering at L content for a '|' ...\n";for(my$j=0;$j < @ell_content;++$j){next if ref$ell_content[$j];DEBUG > 3 and print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '|'.\n";if($ell_content[$j]=~ m/^([^\|]*)\|(.*)$/s){my@link_text=($1);$ell_content[$j]=$2;DEBUG > 3 and print STDERR "     FOUND a '|' in it.  Splitting into [$1] + [$2]\n";if ($link_text[0]=~ m{[|/]}){$self->whine($start_line,"alternative text '$link_text[0]' contains non-escaped | or /")}unshift@link_text,splice@ell_content,0,$j;@ell_content=grep ref($_)||length($_),@ell_content ;$link_text=[grep ref($_)||length($_),@link_text ];DEBUG > 3 and printf "  So link text is %s\n  and remaining ell content is %s\n",pretty($link_text),pretty(@ell_content);last}}my$section_name;DEBUG > 3 and print STDERR "  Peering at L-content for a '/' ...\n";for(my$j=0;$j < @ell_content;++$j){next if ref$ell_content[$j];DEBUG > 3 and print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '/'.\n";if($ell_content[$j]=~ m/^([^\/]*)\/(.*)$/s){my@section_name=($2);$ell_content[$j]=$1;DEBUG > 3 and print STDERR "     FOUND a '/' in it.","  Splitting to page [...$1] + section [$2...]\n";push@section_name,splice@ell_content,1+$j;@ell_content=grep ref($_)||length($_),@ell_content ;@section_name=grep ref($_)||length($_),@section_name ;if(@section_name and!ref($section_name[0])and!ref($section_name[-1])and $section_name[0]=~ m/^\"/s and $section_name[-1]=~ m/\"$/s and!(@section_name==1 and $section_name[0]eq '"')){$section_name[0]=~ s/^\"//s;$section_name[-1]=~ s/\"$//s;DEBUG > 3 and print STDERR "     Quotes removed: ",pretty(@section_name),"\n"}else {DEBUG > 3 and print STDERR "     No need to remove quotes in ",pretty(@section_name),"\n"}$section_name=\@section_name;last}}if(!$section_name and @ell_content and!ref($ell_content[0])and!ref($ell_content[-1])and $ell_content[0]=~ m/^\"/s and $ell_content[-1]=~ m/\"$/s and!(@ell_content==1 and $ell_content[0]eq '"')){$section_name=[splice@ell_content];$section_name->[0]=~ s/^\"//s;$section_name->[-1]=~ s/\"$//s}if(!$section_name and!$link_text and @ell_content and grep!ref($_)&& m/ /s,@ell_content){$section_name=[splice@ell_content]}unless($link_text){$ell->[1]{'content-implicit'}='yes';$link_text=[];push @$link_text,'"',@$section_name,'"' if$section_name;if(@ell_content){$link_text->[-1].= ' in ' if$section_name;push @$link_text,@ell_content}}if(@ell_content==1 and!ref($ell_content[0])and $ell_content[0]=~ m{^[^/]+[(][-a-zA-Z0-9]+[)]$}s){$ell->[1]{'type'}='man';DEBUG > 3 and print STDERR "Considering this ($ell_content[0]) a man link.\n"}else {$ell->[1]{'type'}='pod';DEBUG > 3 and print STDERR "Considering this a pod link (not man or url).\n"}if(defined$section_name){$ell->[1]{'section'}=Pod::Simple::LinkSection->new(['',{},@$section_name]);DEBUG > 3 and print STDERR "L-section content: ",pretty($ell->[1]{'section'}),"\n"}if(@ell_content){$ell->[1]{'to'}=Pod::Simple::LinkSection->new(['',{},@ell_content]);DEBUG > 3 and print STDERR "L-to content: ",pretty($ell->[1]{'to'}),"\n"}@$ell=(@$ell[0,1],defined($link_text)? splice(@$link_text): '');DEBUG > 2 and print STDERR "End of L-parsing for this node $treelet->[$i]\n";unshift@stack,$treelet->[$i]}}return}sub _treat_Es {my($self,@stack)=@_;my($i,$treelet,$content,$replacer,$charnum);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for(my$i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];if($treelet->[$i][0]eq 'L'){my$thing;for my$attrname ('section','to'){if(defined($thing=$treelet->[$i][1]{$attrname})and ref$thing){unshift@stack,$thing;DEBUG > 2 and print STDERR "  Enqueuing ",pretty($treelet->[$i][1]{$attrname})," as an attribute value to tweak.\n"}}unshift@stack,$treelet->[$i];next}elsif($treelet->[$i][0]ne 'E'){unshift@stack,$treelet->[$i];next}DEBUG > 1 and print STDERR "Ogling E node ",pretty($treelet->[$i]),"\n";if(@{$treelet->[$i]}==2 or (@{$treelet->[$i]}==3 and $treelet->[$i][2]eq '')){$self->whine($start_line,"An empty E<>");$treelet->[$i]='E<>';next}unless(@{$treelet->[$i]}==3 and!ref($content=$treelet->[$i][2])){$self->whine($start_line,"An E<...> surrounding strange content");$replacer=$treelet->[$i];splice(@$treelet,$i,1,'E<',splice(@$replacer,2),'>');next}DEBUG > 1 and print STDERR "Ogling E<$content>\n";$charnum=Pod::Escapes::e2charnum($content);DEBUG > 1 and print STDERR " Considering E<$content> with char ",defined($charnum)? $charnum : "undef",".\n";if(!defined($charnum)){DEBUG > 1 and print STDERR "I don't know how to deal with E<$content>.\n";$self->whine($start_line,"Unknown E content in E<$content>");$replacer="E<$content>"}elsif($charnum >= 255 and!UNICODE){$replacer=ASCII ? "\xA4" : "?";DEBUG > 1 and print STDERR "This Perl version can't handle ","E<$content> (chr $charnum), so replacing with $replacer\n"}else {$replacer=Pod::Escapes::e2char($content);DEBUG > 1 and print STDERR " Replacing E<$content> with $replacer\n"}splice(@$treelet,$i,1,$replacer)}}return}sub _treat_Ss {my($self,$treelet)=@_;_change_S_to_nbsp($treelet,0)if$self->{'nbsp_for_S'};return}sub _change_S_to_nbsp {my($treelet,$in_s)=@_;my$is_s=('S' eq $treelet->[0]);$in_s ||= $is_s;for(my$i=2;$i < @$treelet;++$i){if(ref$treelet->[$i]){if(_change_S_to_nbsp($treelet->[$i],$in_s)){my$to_pull_up=$treelet->[$i];splice @$to_pull_up,0,2;splice @$treelet,$i,1,@$to_pull_up;$i += @$to_pull_up - 1}}else {$treelet->[$i]=~ s/\s/$Pod::Simple::nbsp/g if$in_s}}return$is_s}sub _accessorize {no strict 'refs';for my$attrname (@_){next if$attrname =~ m/::/;*{caller().'::' .$attrname}=sub {use strict;$Carp::CarpLevel=1,Carp::croak("Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)")unless (@_==1 or @_==2)and ref $_[0];(@_==1)? $_[0]->{$attrname}: ($_[0]->{$attrname}=$_[1])}}return}sub filter {my($class,$source)=@_;my$new=$class->new;$new->output_fh(*STDOUT{IO});if(ref($source || '')eq 'SCALAR'){$new->parse_string_document($$source)}elsif(ref($source)){$new->parse_file($source)}else {$new->parse_file($source)}return$new}sub _out {my$class=shift(@_);my$mutor=shift(@_)if @_ and ref($_[0]|| '')eq 'CODE';DEBUG and print STDERR "\n\n",'#' x 76,"\nAbout to parse source: {{\n$_[0]\n}}\n\n";my$parser=ref$class && $class->isa(__PACKAGE__)? $class : $class->new;$parser->hide_line_numbers(1);my$out='';$parser->output_string(\$out);DEBUG and print STDERR " _out to ",\$out,"\n";$mutor->($parser)if$mutor;$parser->parse_string_document($_[0]);return$out}sub _duo {my$class=shift(@_);Carp::croak "But $class->_duo is useful only in list context!" unless wantarray;my$mutor=shift(@_)if @_ and ref($_[0]|| '')eq 'CODE';Carp::croak "But $class->_duo takes two parameters, not: @_" unless @_==2;my(@out);while(@_){my$parser=$class->new;push@out,'';$parser->output_string(\($out[-1]));DEBUG and print STDERR " _duo out to ",$parser->output_string()," = $parser->{'output_string'}\n";$parser->hide_line_numbers(1);$mutor->($parser)if$mutor;$parser->parse_string_document(shift(@_))}return@out}1;
POD_SIMPLE

$fatpacked{"Pod/Simple/BlackBox.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_BLACKBOX';
  package Pod::Simple::BlackBox;use integer;use strict;use Carp ();use vars qw($VERSION);$VERSION='3.35';BEGIN {require Pod::Simple;*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}my$non_ascii_re=eval "qr/[[:^ascii:]]/";$non_ascii_re=qr/[\x80-\xFF]/ if!defined$non_ascii_re;my$utf8_bom;if (($] ge 5.007_003)){$utf8_bom="\x{FEFF}";utf8::encode($utf8_bom)}else {$utf8_bom="\xEF\xBB\xBF"}sub parse_line {shift->parse_lines(@_)}sub parse_lines {my$self=shift;my$code_handler=$self->{'code_handler'};my$cut_handler=$self->{'cut_handler'};my$wl_handler=$self->{'whiteline_handler'};$self->{'line_count'}||= 0;my$scratch;DEBUG > 4 and print STDERR "# Parsing starting at line ",$self->{'line_count'},".\n";DEBUG > 5 and print STDERR "#  About to parse lines: ",join(' ',map defined($_)? "[$_]" : "EOF",@_),"\n";my$paras=($self->{'paras'}||= []);$self->{'pod_para_count'}||= 0;my$line;for my$source_line (@_){if($self->{'source_dead'}){DEBUG > 4 and print STDERR "# Source is dead.\n";last}unless(defined$source_line){DEBUG > 4 and print STDERR "# Undef-line seen.\n";push @$paras,['~end',{'start_line'=>$self->{'line_count'}}];push @$paras,$paras->[-1],$paras->[-1];$self->{'source_dead'}=1;$self->_ponder_paragraph_buffer;next}if($self->{'line_count'}++){($line=$source_line)=~ tr/\n\r//d}else {DEBUG > 2 and print STDERR "First line: [$source_line]\n";if(($line=$source_line)=~ s/^$utf8_bom//s){DEBUG and print STDERR "UTF-8 BOM seen.  Faking a '=encoding utf8'.\n";$self->_handle_encoding_line("=encoding utf8");delete$self->{'_processed_encoding'};$line =~ tr/\n\r//d}elsif($line =~ s/^\xFE\xFF//s){DEBUG and print STDERR "Big-endian UTF-16 BOM seen.  Aborting parsing.\n";$self->scream($self->{'line_count'},"UTF16-BE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet.");splice @_;push @_,undef;next}elsif($line =~ s/^\xFF\xFE//s){DEBUG and print STDERR "Little-endian UTF-16 BOM seen.  Aborting parsing.\n";$self->scream($self->{'line_count'},"UTF16-LE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet.");splice @_;push @_,undef;next}else {DEBUG > 2 and print STDERR "First line is BOM-less.\n";($line=$source_line)=~ tr/\n\r//d}}if(!$self->{'parse_characters'}&&!$self->{'encoding'}&& ($self->{'in_pod'}|| $line =~ /^=/s)&& $line =~ /$non_ascii_re/){my$encoding;while ($line =~ m/($non_ascii_re+)/g){my$non_ascii_seq=$1;if (length$non_ascii_seq==1){$encoding='CP1252';goto guessed}elsif ($] ge 5.007_003){my$is_utf8;{no warnings 'utf8';$is_utf8=utf8::decode($non_ascii_seq)}if (!$is_utf8){$encoding='CP1252';goto guessed}}elsif (ord("A")==65){if ($non_ascii_seq !~ /^[\xC2-\xF4][\x80-\xBF]/){$encoding='CP1252';goto guessed}}}$encoding='UTF-8';guessed: $self->_handle_encoding_line("=encoding $encoding");delete$self->{'_processed_encoding'};$self->{'_transcoder'}&& $self->{'_transcoder'}->($line);my ($word)=$line =~ /(\S*$non_ascii_re\S*)/;$self->whine($self->{'line_count'},"Non-ASCII character seen before =encoding in '$word'. Assuming $encoding")}DEBUG > 5 and print STDERR "# Parsing line: [$line]\n";if(!$self->{'in_pod'}){if($line =~ m/^=([a-zA-Z][a-zA-Z0-9]*)(?:\s|$)/s){if($1 eq 'cut'){$self->scream($self->{'line_count'},"=cut found outside a pod block.  Skipping to next block.");next}else {$self->{'in_pod'}=$self->{'start_of_pod_block'}=$self->{'last_was_blank'}=1}}else {DEBUG > 5 and print STDERR "# It's a code-line.\n";$code_handler->(map $_,$line,$self->{'line_count'},$self)if$code_handler;if($line =~ m/^#\s*line\s+(\d+)\s*(?:\s"([^"]+)")?\s*$/){DEBUG > 1 and print STDERR "# Setting nextline to $1\n";$self->{'line_count'}=$1 - 1}next}}$self->{'_transcoder'}&& $self->{'_transcoder'}->($line);if($line =~ m/^=encoding\s+\S+\s*$/s){next if$self->parse_characters;$line=$self->_handle_encoding_line($line)}if($line =~ m/^=cut/s){DEBUG > 1 and print STDERR "Noting =cut at line ${$self}{'line_count'}\n";$self->{'in_pod'}=0;$self->_ponder_paragraph_buffer();$cut_handler->(map $_,$line,$self->{'line_count'},$self)if$cut_handler}elsif($line =~ m/^(\s*)$/s){if (defined $1 and $1 =~ /[^\S\r\n]/){$wl_handler->(map $_,$line,$self->{'line_count'},$self)if$wl_handler}if(!$self->{'start_of_pod_block'}and @$paras and $paras->[-1][0]eq '~Verbatim'){DEBUG > 1 and print STDERR "Saving blank line at line ${$self}{'line_count'}\n";push @{$paras->[-1]},$line}if(!$self->{'start_of_pod_block'}and!$self->{'last_was_blank'}){DEBUG > 1 and print STDERR "Noting para ends with blank line at ${$self}{'line_count'}\n"}$self->{'last_was_blank'}=1}elsif($self->{'last_was_blank'}){if($line =~ m/^(=[a-zA-Z][a-zA-Z0-9]*)(?:\s+|$)(.*)/s){my$new=[$1,{'start_line'=>$self->{'line_count'}},$2];++$self->{'pod_para_count'};$self->_ponder_paragraph_buffer();push @$paras,$new;DEBUG > 1 and print STDERR "Starting new ${$paras}[-1][0] para at line ${$self}{'line_count'}\n"}elsif($line =~ m/^\s/s){if(!$self->{'start_of_pod_block'}and @$paras and $paras->[-1][0]eq '~Verbatim'){DEBUG > 1 and print STDERR "Resuming verbatim para at line ${$self}{'line_count'}\n";push @{$paras->[-1]},$line}else {++$self->{'pod_para_count'};$self->_ponder_paragraph_buffer();DEBUG > 1 and print STDERR "Starting verbatim para at line ${$self}{'line_count'}\n";push @$paras,['~Verbatim',{'start_line'=>$self->{'line_count'}},$line]}}else {++$self->{'pod_para_count'};$self->_ponder_paragraph_buffer();push @$paras,['~Para',{'start_line'=>$self->{'line_count'}},$line];DEBUG > 1 and print STDERR "Starting plain para at line ${$self}{'line_count'}\n"}$self->{'last_was_blank'}=$self->{'start_of_pod_block'}=0}else {if(@$paras){DEBUG > 2 and print STDERR "Line ${$self}{'line_count'} continues current paragraph\n";push @{$paras->[-1]},$line}else {die "Continuing a paragraph but \@\$paras is empty?"}$self->{'last_was_blank'}=$self->{'start_of_pod_block'}=0}}DEBUG > 1 and print STDERR (pretty(@$paras),"\n");return$self}sub _handle_encoding_line {my($self,$line)=@_;return if$self->parse_characters;return$line unless$line =~ m/^=encoding\s+(\S+)\s*$/s;DEBUG > 1 and print STDERR "Found an encoding line \"=encoding $1\"\n";my$e=$1;my$orig=$e;push @{$self->{'encoding_command_reqs'}},"=encoding $orig";my$enc_error;require Pod::Simple::Transcode;if($self->{'encoding'}){my$norm_current=$self->{'encoding'};my$norm_e=$e;for my$that ($norm_current,$norm_e){$that=lc($that);$that =~ s/[-_]//g}if($norm_current eq $norm_e){DEBUG > 1 and print STDERR "The '=encoding $orig' line is ","redundant.  ($norm_current eq $norm_e).  Ignoring.\n";$enc_error=''}else {$enc_error="Encoding is already set to " .$self->{'encoding'};DEBUG > 1 and print STDERR$enc_error}}elsif (do {DEBUG > 1 and print STDERR " Setting encoding to $e\n";$self->{'encoding'}=$e;1}and $e eq 'HACKRAW'){DEBUG and print STDERR " Putting in HACKRAW (no-op) encoding mode.\n"}elsif(Pod::Simple::Transcode::->encoding_is_available($e)){die($enc_error="WHAT? _transcoder is already set?!")if$self->{'_transcoder'};require Pod::Simple::Transcode;$self->{'_transcoder'}=Pod::Simple::Transcode::->make_transcoder($e);eval {my@x=('',"abc","123");$self->{'_transcoder'}->(@x)};$@ && die($enc_error="Really unexpected error setting up encoding $e: $@\nAborting");$self->{'detected_encoding'}=$e}else {my@supported=Pod::Simple::Transcode::->all_encodings;DEBUG and print STDERR " Encoding [$e] is unsupported.","\nSupporteds: @supported\n";my$suggestion='';my$norm=lc($e);$norm =~ tr[-_][]d;my$n;for my$enc (@supported){$n=lc($enc);$n =~ tr[-_][]d;next unless$n eq $norm;$suggestion="  (Maybe \"$e\" should be \"$enc\"?)";last}my$encmodver=Pod::Simple::Transcode::->encmodver;$enc_error=join ''=>"This document probably does not appear as it should, because its ","\"=encoding $e\" line calls for an unsupported encoding.",$suggestion,"  [$encmodver\'s supported encodings are: @supported]" ;$self->scream($self->{'line_count'},$enc_error)}push @{$self->{'encoding_command_statuses'}},$enc_error;if (defined($self->{'_processed_encoding'})){$self->scream($self->{'line_count'},'Cannot have multiple =encoding directives')}$self->{'_processed_encoding'}=$orig;return$line}sub _handle_encoding_second_level {my($self,$para)=@_;my@x=@$para;my$content=join ' ',splice@x,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG > 2 and print STDERR "Ogling encoding directive: =encoding $content\n";if (defined($self->{'_processed_encoding'})){delete$self->{'_processed_encoding'};if(!$self->{'encoding_command_statuses'}){DEBUG > 2 and print STDERR " CRAZY ERROR: It wasn't really handled?!\n"}elsif($self->{'encoding_command_statuses'}[-1]){$self->whine($para->[1]{'start_line'},sprintf "Couldn't do %s: %s",$self->{'encoding_command_reqs' }[-1],$self->{'encoding_command_statuses'}[-1],)}else {DEBUG > 2 and print STDERR " (Yup, it was successfully handled already.)\n"}}else {$self->whine($para->[1]{'start_line'},"Invalid =encoding syntax: $content")}return}{my$m=-321;sub _gen_errata {my$self=$_[0];return()unless$self->{'errata'}and keys %{$self->{'errata'}};my@out;for my$line (sort {$a <=> $b}keys %{$self->{'errata'}}){push@out,['=item',{'start_line'=>$m},"Around line $line:"],map(['~Para',{'start_line'=>$m,'~cooked'=>1},$_ ],@{$self->{'errata'}{$line}})}unshift@out,['=head1',{'start_line'=>$m,'errata'=>1},'POD ERRORS'],['~Para',{'start_line'=>$m,'~cooked'=>1,'errata'=>1},"Hey! ",['B',{},'The above document had some coding errors, which are explained below:' ]],['=over',{'start_line'=>$m,'errata'=>1},''],;push@out,['=back',{'start_line'=>$m,'errata'=>1},''],;DEBUG and print STDERR "\n<<\n",pretty(\@out),"\n>>\n\n";return@out}}sub _ponder_paragraph_buffer {my$self=$_[0];my$paras;return unless @{$paras=$self->{'paras'}};my$curr_open=($self->{'curr_open'}||= []);my$scratch;DEBUG > 10 and print STDERR "# Paragraph buffer: <<",pretty($paras),">>\n";unless($self->{'doc_has_started'}){$self->{'doc_has_started'}=1;my$starting_contentless;$starting_contentless=(!@$curr_open and @$paras and!grep $_->[0]ne '~end',@$paras);DEBUG and print STDERR "# Starting ",$starting_contentless ? 'contentless' : 'contentful'," document\n" ;$self->_handle_element_start(($scratch='Document'),{'start_line'=>$paras->[0][1]{'start_line'},$starting_contentless ? ('contentless'=>1): (),},)}my($para,$para_type);while(@$paras){last if @$paras==1 and ($paras->[0][0]eq '=over' or $paras->[0][0]eq '~Verbatim' or $paras->[0][0]eq '=item');$para=shift @$paras;$para_type=$para->[0];DEBUG > 1 and print STDERR "Pondering a $para_type paragraph, given the stack: (",$self->_dump_curr_open(),")\n";if($para_type eq '=for'){next if$self->_ponder_for($para,$curr_open,$paras)}elsif($para_type eq '=begin'){next if$self->_ponder_begin($para,$curr_open,$paras)}elsif($para_type eq '=end'){next if$self->_ponder_end($para,$curr_open,$paras)}elsif($para_type eq '~end'){next if$self->_ponder_doc_end($para,$curr_open,$paras)}if(grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print STDERR "Skipping $para_type paragraph because in ignore mode.\n";next}if($para_type eq '=pod'){$self->_ponder_pod($para,$curr_open,$paras)}elsif($para_type eq '=over'){next if$self->_ponder_over($para,$curr_open,$paras)}elsif($para_type eq '=back'){next if$self->_ponder_back($para,$curr_open,$paras)}else {DEBUG > 1 and print STDERR "Pondering non-magical $para_type\n";my$i;if($para_type =~ m/^=head\d$/s and!$self->{'accept_heads_anywhere'}and @$curr_open and $curr_open->[-1][0]eq '=over'){DEBUG > 2 and print STDERR "'=$para_type' inside an '=over'!\n";$self->whine($para->[1]{'start_line'},"You forgot a '=back' before '$para_type'");unshift @$paras,['=back',{},''],$para;next}if($para_type eq '=item'){my$over;unless(@$curr_open and $over=(grep {$_->[0]eq '=over'}@$curr_open)[-1]){$self->whine($para->[1]{'start_line'},"'=item' outside of any '=over'");unshift @$paras,['=over',{'start_line'=>$para->[1]{'start_line'}},''],$para ;next}my$over_type=$over->[1]{'~type'};if(!$over_type){die "Typeless over in stack, starting at line " .$over->[1]{'start_line'}}elsif($over_type eq 'block'){unless($curr_open->[-1][1]{'~bitched_about'}){$curr_open->[-1][1]{'~bitched_about'}=1;$self->whine($curr_open->[-1][1]{'start_line'},"You can't have =items (as at line " .$para->[1]{'start_line'}.") unless the first thing after the =over is an =item")}$para->[0]='~Para';unshift @$paras,$para;next}elsif($over_type eq 'text'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'text'){}elsif($item_type eq 'number' or $item_type eq 'bullet'){$self->whine($para->[1]{'start_line'},"Expected text after =item, not a $item_type");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}else {die "Unhandled item type $item_type"}}elsif($over_type eq 'number'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";my$expected_value=++ $curr_open->[-1][1]{'~counter'};if($item_type eq 'bullet'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'");push @$para,$para->[1]{'~orig_content'}}elsif($item_type eq 'text'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'")}elsif($item_type ne 'number'){die "Unknown item type $item_type"}elsif($expected_value==$para->[1]{'number'}){DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n"}else {DEBUG > 1 and print STDERR " Numeric item has ",$para->[1]{'number'}," instead of the expected value of $expected_value\n";$self->whine($para->[1]{'start_line'},"You have '=item " .$para->[1]{'number'}."' instead of the expected '=item $expected_value'");$para->[1]{'number'}=$expected_value}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print STDERR "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}elsif($over_type eq 'bullet'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'bullet'){if($para->[1]{'~_freaky_para_hack'}){DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";push @$para,delete$para->[1]{'~_freaky_para_hack'}}}elsif($item_type eq 'number'){$self->whine($para->[1]{'start_line'},"Expected '=item *'");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}elsif($item_type eq 'text'){$self->whine($para->[1]{'start_line'},"Expected '=item *'")}else {die "Unhandled item type $item_type"}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print STDERR "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}else {die "Unhandled =over type \"$over_type\"?"}$para_type='Plain';$para->[0].= '-' .$over_type}elsif($para_type eq '=extend'){$self->_ponder_extend($para);next}elsif($para_type eq '=encoding'){$self->_handle_encoding_second_level($para);next unless$self->keep_encoding_directive;$para_type='Plain'}elsif($para_type eq '~Verbatim'){$para->[0]='Verbatim';$para_type='?Verbatim'}elsif($para_type eq '~Para'){$para->[0]='Para';$para_type='?Plain'}elsif($para_type eq 'Data'){$para->[0]='Data';$para_type='?Data'}elsif($para_type =~ s/^=//s and defined($para_type=$self->{'accept_directives'}{$para_type})){DEBUG > 1 and print STDERR " Pondering known directive ${$para}[0] as $para_type\n"}else {DEBUG > 1 and printf STDERR "Unhandled directive %s (Handled: %s)\n",$para->[0],join(' ',sort keys %{$self->{'accept_directives'}});$self->whine($para->[1]{'start_line'},"Unknown directive: $para->[0]");next}if($para_type =~ s/^\?//s){if(!@$curr_open){DEBUG and print STDERR "Treating $para_type paragraph as such because stack is empty.\n"}else {my@fors=grep $_->[0]eq '=for',@$curr_open;DEBUG > 1 and print STDERR "Containing fors: ",join(',',map $_->[1]{'target'},@fors),"\n";if(!@fors){DEBUG and print STDERR "Treating $para_type paragraph as such because stack has no =for's\n"}elsif($fors[-1][1]{'~resolve'}){if($para_type eq 'Data'){DEBUG and print STDERR "Treating Data paragraph as Plain/Verbatim because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";$para->[0]='Para';$para_type='Plain'}else {DEBUG and print STDERR "Treating $para_type paragraph as such because the containing =for ($fors[-1][1]{'target'}) is a resolver\n"}}else {DEBUG and print STDERR "Treating $para_type paragraph as Data because the containing =for ($fors[-1][1]{'target'}) is a non-resolver\n";$para->[0]=$para_type='Data'}}}if($para_type eq 'Plain'){$self->_ponder_Plain($para)}elsif($para_type eq 'Verbatim'){$self->_ponder_Verbatim($para)}elsif($para_type eq 'Data'){$self->_ponder_Data($para)}else {die "\$para type is $para_type -- how did that happen?"}$para->[0]=~ s/^[~=]//s;DEBUG and print STDERR "\n",pretty($para),"\n";$self->{'content_seen'}||= 1;$self->_traverse_treelet_bit(@$para)}}return}sub _ponder_for {my ($self,$para,$curr_open,$paras)=@_;my$target;if(grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print STDERR "Ignoring ignorable =for\n";return 1}for(my$i=2;$i < @$para;++$i){if($para->[$i]=~ s/^\s*(\S+)\s*//s){$target=$1;last}}unless(defined$target){$self->whine($para->[1]{'start_line'},"=for without a target?");return 1}DEBUG > 1 and print STDERR "Faking out a =for $target as a =begin $target / =end $target\n";$para->[0]='Data';unshift @$paras,['=begin',{'start_line'=>$para->[1]{'start_line'},'~really'=>'=for'},$target,],$para,['=end',{'start_line'=>$para->[1]{'start_line'},'~really'=>'=for'},$target,],;return 1}sub _ponder_begin {my ($self,$para,$curr_open,$paras)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;unless(length($content)){$self->whine($para->[1]{'start_line'},"=begin without a target?");DEBUG and print STDERR "Ignoring targetless =begin\n";return 1}my ($target,$title)=$content =~ m/^(\S+)\s*(.*)$/;$para->[1]{'title'}=$title if ($title);$para->[1]{'target'}=$target;$content=$target;$content =~ s/^:!/!:/s;my$neg;$neg=1 if$content =~ s/^!//s;my$to_resolve;$to_resolve=1 if$content =~ s/^://s;my$dont_ignore;for my$target_name (split(',',$content,-1),$neg ? (): '*'){DEBUG > 2 and print STDERR " Considering whether =begin $content matches $target_name\n";next unless$self->{'accept_targets'}{$target_name};DEBUG > 2 and print STDERR "  It DOES match the acceptable target $target_name!\n";$to_resolve=1 if$self->{'accept_targets'}{$target_name}eq 'force_resolve';$dont_ignore=1;$para->[1]{'target_matching'}=$target_name;last}if($neg){if($dont_ignore){$dont_ignore='';delete$para->[1]{'target_matching'};DEBUG > 2 and print STDERR " But the leading ! means that this is a NON-match!\n"}else {$dont_ignore=1;$para->[1]{'target_matching'}='!';DEBUG > 2 and print STDERR " But the leading ! means that this IS a match!\n"}}$para->[0]='=for';$para->[1]{'~really'}||= '=begin';$para->[1]{'~ignore'}=(!$dont_ignore)|| 0;$para->[1]{'~resolve'}=$to_resolve || 0;DEBUG > 1 and print STDERR " Making note to ",$dont_ignore ? 'not ' : '',"ignore contents of this region\n";DEBUG > 1 and $dont_ignore and print STDERR " Making note to treat contents as ",($to_resolve ? 'verbatim/plain' : 'data')," paragraphs\n";DEBUG > 1 and print STDERR " (Stack now: ",$self->_dump_curr_open(),")\n";push @$curr_open,$para;if(!$dont_ignore or scalar grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print STDERR "Ignoring ignorable =begin\n"}else {$self->{'content_seen'}||= 1;$self->_handle_element_start((my$scratch='for'),$para->[1])}return 1}sub _ponder_end {my ($self,$para,$curr_open,$paras)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG and print STDERR "Ogling '=end $content' directive\n";unless(length($content)){$self->whine($para->[1]{'start_line'},"'=end' without a target?" .((@$curr_open and $curr_open->[-1][0]eq '=for')? (" (Should be \"=end " .$curr_open->[-1][1]{'target'}.'")'): ''));DEBUG and print STDERR "Ignoring targetless =end\n";return 1}unless($content =~ m/^\S+$/){$self->whine($para->[1]{'start_line'},"'=end $content' is invalid.  (Stack: " .$self->_dump_curr_open().')');DEBUG and print STDERR "Ignoring mistargetted =end $content\n";return 1}unless(@$curr_open and $curr_open->[-1][0]eq '=for'){$self->whine($para->[1]{'start_line'},"=end $content without matching =begin.  (Stack: " .$self->_dump_curr_open().')');DEBUG and print STDERR "Ignoring mistargetted =end $content\n";return 1}unless($content eq $curr_open->[-1][1]{'target'}){$self->whine($para->[1]{'start_line'},"=end $content doesn't match =begin " .$curr_open->[-1][1]{'target'}.".  (Stack: " .$self->_dump_curr_open().')');DEBUG and print STDERR "Ignoring mistargetted =end $content at line $para->[1]{'start_line'}\n";return 1}if(grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print STDERR "Not firing any event for this =end $content because in an ignored region\n"}else {$curr_open->[-1][1]{'start_line'}=$para->[1]{'start_line'};$self->{'content_seen'}||= 1;$self->_handle_element_end(my$scratch='for',$para->[1])}DEBUG > 1 and print STDERR "Popping $curr_open->[-1][0] $curr_open->[-1][1]{'target'} because of =end $content\n";pop @$curr_open;return 1}sub _ponder_doc_end {my ($self,$para,$curr_open,$paras)=@_;if(@$curr_open){DEBUG and print STDERR "Stack is nonempty at end-document: (",$self->_dump_curr_open(),")\n";DEBUG > 9 and print STDERR "Stack: ",pretty($curr_open),"\n";unshift @$paras,$self->_closers_for_all_curr_open;@$paras=grep $_->[0]ne '~end',@$paras;push @$paras,$para,$para;return 1}else {DEBUG and print STDERR "Okay, stack is empty now.\n"}unless($self->{'~tried_gen_errata'}){$self->{'~tried_gen_errata'}=1;my@extras=$self->_gen_errata();if(@extras){unshift @$paras,@extras;DEBUG and print STDERR "Generated errata... relooping...\n";return 1}}splice @$paras;DEBUG and print STDERR "Throwing end-document event.\n";$self->_handle_element_end(my$scratch='Document');return 1}sub _ponder_pod {my ($self,$para,$curr_open,$paras)=@_;$self->whine($para->[1]{'start_line'},"=pod directives shouldn't be over one line long!  Ignoring all " .(@$para - 2)." lines of content")if @$para > 3;if (my$pod_handler=$self->{'pod_handler'}){my ($line_num,$line)=map $_,$para->[1]{'start_line'},$para->[2];$line=$line eq '' ? "=pod" : "=pod $line";$pod_handler->($line,$line_num,$self)}return}sub _ponder_over {my ($self,$para,$curr_open,$paras)=@_;return 1 unless @$paras;my$list_type;if($paras->[0][0]eq '=item'){$list_type=$self->_get_initial_item_type($paras->[0])}elsif($paras->[0][0]eq '=back'){if ($self->{'parse_empty_lists'}){$list_type='empty'}else {shift @$paras;return 1}}elsif($paras->[0][0]eq '~end'){$self->whine($para->[1]{'start_line'},"=over is the last thing in the document?!");return 1}else {$list_type='block'}$para->[1]{'~type'}=$list_type;push @$curr_open,$para;my$content=join ' ',splice @$para,2;my$overness;if($content =~ m/^\s*$/s){$para->[1]{'indent'}=4}elsif($content =~ m/^\s*((?:\d*\.)?\d+)\s*$/s){no integer;$para->[1]{'indent'}=$1;if($1==0){$self->whine($para->[1]{'start_line'},"Can't have a 0 in =over $content");$para->[1]{'indent'}=4}}else {$self->whine($para->[1]{'start_line'},"=over should be: '=over' or '=over positive_number'");$para->[1]{'indent'}=4}DEBUG > 1 and print STDERR "=over found of type $list_type\n";$self->{'content_seen'}||= 1;$self->_handle_element_start((my$scratch='over-' .$list_type),$para->[1]);return}sub _ponder_back {my ($self,$para,$curr_open,$paras)=@_;my$content=join ' ',splice @$para,2;if($content =~ m/\S/){$self->whine($para->[1]{'start_line'},"=back doesn't take any parameters, but you said =back $content")}if(@$curr_open and $curr_open->[-1][0]eq '=over'){DEBUG > 1 and print STDERR "=back happily closes matching =over\n";$self->{'content_seen'}||= 1;$self->_handle_element_end(my$scratch='over-' .((pop @$curr_open)->[1]{'~type'}),$para->[1])}else {DEBUG > 1 and print STDERR "=back found without a matching =over.  Stack: (",join(', ',map $_->[0],@$curr_open),").\n";$self->whine($para->[1]{'start_line'},'=back without =over');return 1}}sub _ponder_item {my ($self,$para,$curr_open,$paras)=@_;my$over;unless(@$curr_open and $over=(grep {$_->[0]eq '=over'}@$curr_open)[-1]){$self->whine($para->[1]{'start_line'},"'=item' outside of any '=over'");unshift @$paras,['=over',{'start_line'=>$para->[1]{'start_line'}},''],$para ;return 1}my$over_type=$over->[1]{'~type'};if(!$over_type){die "Typeless over in stack, starting at line " .$over->[1]{'start_line'}}elsif($over_type eq 'block'){unless($curr_open->[-1][1]{'~bitched_about'}){$curr_open->[-1][1]{'~bitched_about'}=1;$self->whine($curr_open->[-1][1]{'start_line'},"You can't have =items (as at line " .$para->[1]{'start_line'}.") unless the first thing after the =over is an =item")}$para->[0]='~Para';unshift @$paras,$para;return 1}elsif($over_type eq 'text'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'text'){}elsif($item_type eq 'number' or $item_type eq 'bullet'){$self->whine($para->[1]{'start_line'},"Expected text after =item, not a $item_type");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}else {die "Unhandled item type $item_type"}}elsif($over_type eq 'number'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";my$expected_value=++ $curr_open->[-1][1]{'~counter'};if($item_type eq 'bullet'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'");push @$para,$para->[1]{'~orig_content'}}elsif($item_type eq 'text'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'")}elsif($item_type ne 'number'){die "Unknown item type $item_type"}elsif($expected_value==$para->[1]{'number'}){DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n"}else {DEBUG > 1 and print STDERR " Numeric item has ",$para->[1]{'number'}," instead of the expected value of $expected_value\n";$self->whine($para->[1]{'start_line'},"You have '=item " .$para->[1]{'number'}."' instead of the expected '=item $expected_value'");$para->[1]{'number'}=$expected_value}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print STDERR "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}elsif($over_type eq 'bullet'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'bullet'){if($para->[1]{'~_freaky_para_hack'}){DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";push @$para,delete$para->[1]{'~_freaky_para_hack'}}}elsif($item_type eq 'number'){$self->whine($para->[1]{'start_line'},"Expected '=item *'");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}elsif($item_type eq 'text'){$self->whine($para->[1]{'start_line'},"Expected '=item *'")}else {die "Unhandled item type $item_type"}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print STDERR "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}else {die "Unhandled =over type \"$over_type\"?"}$para->[0].= '-' .$over_type;return}sub _ponder_Plain {my ($self,$para)=@_;DEBUG and print STDERR " giving plain treatment...\n";unless(@$para==2 or (@$para==3 and $para->[2]eq '')or $para->[1]{'~cooked'}){push @$para,@{$self->_make_treelet(join("\n",splice(@$para,2)),$para->[1]{'start_line'})}}return}sub _ponder_Verbatim {my ($self,$para)=@_;DEBUG and print STDERR " giving verbatim treatment...\n";$para->[1]{'xml:space'}='preserve';my$indent=$self->strip_verbatim_indent;if ($indent && ref$indent eq 'CODE'){my@shifted=(shift @{$para},shift @{$para});$indent=$indent->($para);unshift @{$para},@shifted}for(my$i=2;$i < @$para;$i++){for my$line ($para->[$i]){$line =~ s/^\Q$indent// if$indent &&!($self->{accept_codes}&& $self->{accept_codes}{VerbatimFormatted});while($line =~ s/^([^\t]*)(\t+)/$1.(" " x ((length($2)<<3)-(length($1)&7)))/e){}}}if($self->{'accept_codes'}and $self->{'accept_codes'}{'VerbatimFormatted'}){while(@$para > 3 and $para->[-1]!~ m/\S/){pop @$para}$self->_verbatim_format($para)}elsif ($self->{'codes_in_verbatim'}){push @$para,@{$self->_make_treelet(join("\n",splice(@$para,2)),$para->[1]{'start_line'},$para->[1]{'xml:space'})};$para->[-1]=~ s/\n+$//s}else {push @$para,join "\n",splice(@$para,2)if @$para > 3;$para->[-1]=~ s/\n+$//s}return}sub _ponder_Data {my ($self,$para)=@_;DEBUG and print STDERR " giving data treatment...\n";$para->[1]{'xml:space'}='preserve';push @$para,join "\n",splice(@$para,2)if @$para > 3;return}sub _traverse_treelet_bit {my($self,$name)=splice @_,0,2;my$scratch;$self->_handle_element_start(($scratch=$name),shift @_);while (@_){my$x=shift;if (ref($x)){&_traverse_treelet_bit($self,@$x)}else {$x .= shift while @_ &&!ref($_[0]);$self->_handle_text($x)}}$self->_handle_element_end($scratch=$name);return}sub _closers_for_all_curr_open {my$self=$_[0];my@closers;for my$still_open (@{$self->{'curr_open'}|| return}){my@copy=@$still_open;$copy[1]={%{$copy[1]}};if($copy[0]eq '=for'){$copy[0]='=end'}elsif($copy[0]eq '=over'){$self->whine($still_open->[1]{start_line},"=over without closing =back");$copy[0]='=back'}else {die "I don't know how to auto-close an open $copy[0] region"}unless(@copy > 2){push@copy,$copy[1]{'target'};$copy[-1]='' unless defined$copy[-1]}$copy[1]{'fake-closer'}=1;DEBUG and print STDERR "Queuing up fake-o event: ",pretty(\@copy),"\n";unshift@closers,\@copy}return@closers}sub _verbatim_format {my($it,$p)=@_;my$formatting;for(my$i=2;$i < @$p;$i++){DEBUG and print STDERR "_verbatim_format appends a newline to $i: $p->[$i]\n";$p->[$i].= "\n"}if(DEBUG > 4){print STDERR "<<\n";for(my$i=$#$p;$i >= 2;$i--){print STDERR "_verbatim_format $i: $p->[$i]"}print STDERR ">>\n"}for(my$i=$#$p;$i > 2;$i--){DEBUG > 5 and print STDERR "Scrutinizing line $i: $$p[$i]\n";if($p->[$i]=~ m{^#:([ \^\/\%]*)\n?$}s){DEBUG > 5 and print STDERR "  It's a formatty line.  ","Peeking at previous line ",$i-1,": $$p[$i-1]: \n";if($p->[$i-1]=~ m{^#:[ \^\/\%]*\n?$}s){DEBUG > 5 and print STDERR "  Previous line is formatty!  Skipping this one.\n";next}else {DEBUG > 5 and print STDERR "  Previous line is non-formatty!  Yay!\n"}}else {DEBUG > 5 and print STDERR "  It's not a formatty line.  Ignoring\n";next}DEBUG > 4 and print STDERR "_verbatim_format considers:\n<$p->[$i-1]>\n<$p->[$i]>\n";$formatting='  ' .$1;$formatting =~ s/\s+$//s;unless(length$formatting and $p->[$i-1]=~ m/\S/){splice @$p,$i,1;$i--;next}if(length($formatting)>= length($p->[$i-1])){$formatting=substr($formatting,0,length($p->[$i-1])- 1).' '}else {$formatting .= ' ' x (length($p->[$i-1])- length($formatting))}DEBUG > 4 and print STDERR "Formatting <$formatting>    on <",$p->[$i-1],">\n";my@new_line;while($formatting =~ m{\G(( +)|(\^+)|(\/+)|(\%+))}g){if($2){push@new_line,substr($p->[$i-1],pos($formatting)-length($1),length($1))}else {push@new_line,[($3 ? 'VerbatimB' : $4 ? 'VerbatimI' : $5 ? 'VerbatimBI' : die("Should never get called")),{},substr($p->[$i-1],pos($formatting)-length($1),length($1))]}}my@nixed=splice @$p,$i-1,2,@new_line;DEBUG > 10 and print STDERR "Nixed count: ",scalar(@nixed),"\n";DEBUG > 6 and print STDERR "New version of the above line is these tokens (",scalar(@new_line),"):",map(ref($_)?"<@$_> ":"<$_>",@new_line),"\n";$i--}$p->[0]='VerbatimFormatted';for(my$i=2;$i > $#$p;$i++ ){if(!ref($p->[$i])and!ref($p->[$i + 1])){DEBUG > 5 and print STDERR "_verbatim_format merges {$p->[$i]} and {$p->[$i+1]}\n";$p->[$i].= splice @$p,$i+1,1;--$i}}for(my$i=$#$p;$i >= 2;$i-- ){if(!ref($p->[$i])){if($p->[$i]=~ s/\n$//s){DEBUG > 5 and print STDERR "_verbatim_format killed the terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]}\n"}else {DEBUG > 5 and print STDERR "No terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]} !?\n"}last}}return}sub _treelet_from_formatting_codes {my($self,$para,$start_line,$preserve_space)=@_;my$treelet=['~Top',{'start_line'=>$start_line},];unless ($preserve_space || $self->{'preserve_whitespace'}){$para =~ s/\s+/ /g;$para =~ s/ $//;$para =~ s/^ //}my@stack;my@lineage=($treelet);my$raw='';my$inL=0;DEBUG > 4 and print STDERR "Paragraph:\n$para\n\n";while($para =~ m/\G
        (?:
          # Match starting codes, including the whitespace following a
          # multiple-delimiter start code.  $1 gets the whole start code and
          # $2 gets all but one of the <s in the multiple-bracket case.
          ([A-Z]<(?:(<+)\s+)?)
          |
          # Match multiple-bracket end codes.  $3 gets the whitespace that
          # should be discarded before an end bracket but kept in other cases
          # and $4 gets the end brackets themselves.
          (\s+|(?<=\s\s))(>{2,})
          |
          (\s?>)          # $5: simple end-codes
          |
          (               # $6: stuff containing no start-codes or end-codes
            (?:
              [^A-Z\s>]
              |
              (?:
                [A-Z](?!<)
              )
              |
              # whitespace is ok, but we don't want to eat the whitespace before
              # a multiple-bracket end code.
              # NOTE: we may still have problems with e.g. S<<    >>
              (?:
                \s(?!\s*>{2,})
              )
            )+
          )
        )
      /xgo){DEBUG > 4 and print STDERR "\nParagraphic tokenstack = (@stack)\n";if(defined $1){if(defined $2){DEBUG > 3 and print STDERR "Found complex start-text code \"$1\"\n";push@stack,length($2)+ 1}else {DEBUG > 3 and print STDERR "Found simple start-text code \"$1\"\n";push@stack,0}push@lineage,[substr($1,0,1),{},];push @{$lineage[-2]},$lineage[-1];if ('L' eq substr($1,0,1)){$raw=$inL ? $raw.$1 : '';$inL=1}else {$raw .= $1 if$inL}}elsif(defined $4){DEBUG > 3 and print STDERR "Found apparent complex end-text code \"$3$4\"\n";if(!@stack){DEBUG > 4 and print STDERR " But it's really just stuff.\n";push @{$lineage[-1]},$3,$4;next}elsif(!$stack[-1]){DEBUG > 4 and print STDERR " And that's more than we needed to close simple.\n";push @{$lineage[-1]},$3;pos($para)=pos($para)- length($4)+ 1}elsif($stack[-1]==length($4)){DEBUG > 4 and print STDERR " And that's exactly what we needed to close complex.\n"}elsif($stack[-1]< length($4)){DEBUG > 4 and print STDERR " And that's more than we needed to close complex.\n";pos($para)=pos($para)- length($4)+ $stack[-1]}else {DEBUG > 4 and print STDERR " But it's really just stuff, because we needed more.\n";push @{$lineage[-1]},$3,$4;next}push @{$lineage[-1]},'' if 2==@{$lineage[-1]};pop@stack;pop@lineage;unless (@stack){$inL=0;if (ref$lineage[-1][-1]&& $lineage[-1][-1][0]eq 'L'){$lineage[-1][-1][1]{'raw'}=$raw}}$raw .= $3.$4 if$inL}elsif(defined $5){DEBUG > 3 and print STDERR "Found apparent simple end-text code \"$5\"\n";if(@stack and!$stack[-1]){DEBUG > 4 and print STDERR " It's indeed an end-code.\n";if(length($5)==2){push @{$lineage[-1]},' '}elsif(2==@{$lineage[-1]}){push @{$lineage[-1]},''}pop@stack;pop@lineage}else {DEBUG > 4 and print STDERR " It's just stuff.\n";push @{$lineage[-1]},$5}unless (@stack){$inL=0;if (ref$lineage[-1][-1]&& $lineage[-1][-1][0]eq 'L'){$lineage[-1][-1][1]{'raw'}=$raw}}$raw .= $5 if$inL}elsif(defined $6){DEBUG > 3 and print STDERR "Found stuff \"$6\"\n";push @{$lineage[-1]},$6;$raw .= $6 if$inL}else {DEBUG and print STDERR "AYYAYAAAAA at line ",__LINE__,"\n";die "SPORK 512512!"}}if(@stack){my$x="...";while(@stack){push @{$lineage[-1]},'' if 2==@{$lineage[-1]};my$code=(pop@lineage)->[0];my$ender_length=pop@stack;if($ender_length){--$ender_length;$x=$code .("<" x $ender_length)." $x " .(">" x $ender_length)}else {$x=$code ."<$x>"}}DEBUG > 1 and print STDERR "Unterminated $x sequence\n";$self->whine($start_line,"Unterminated $x sequence",)}return$treelet}sub text_content_of_treelet {return stringify_lol($_[1])}sub stringify_lol {my$string_form='';_stringify_lol($_[0]=>\$string_form);return$string_form}sub _stringify_lol {my($lol,$to)=@_;for(my$i=2;$i < @$lol;++$i){if(ref($lol->[$i]|| '')and UNIVERSAL::isa($lol->[$i],'ARRAY')){_stringify_lol($lol->[$i],$to)}else {$$to .= $lol->[$i]}}return}sub _dump_curr_open {my$curr_open=$_[0]{'curr_open'};return '[empty]' unless @$curr_open;return join '; ',map {;($_->[0]eq '=for')? (($_->[1]{'~really'}|| '=over').' ' .$_->[1]{'target'}): $_->[0]}@$curr_open }my%pretty_form=("\a"=>'\a',"\b"=>'\b',"\e"=>'\e',"\f"=>'\f',"\t"=>'\t',"\cm"=>'\cm',"\cj"=>'\cj',"\n"=>'\n','"'=>'\"','\\'=>'\\\\','$'=>'\\$','@'=>'\\@','%'=>'\\%','#'=>'\\#',);sub pretty {my@stuff=@_;my$x;my$out=join ", ",map {;if(!defined($_)){"undef"}elsif(ref($_)eq 'ARRAY' or ref($_)eq 'Pod::Simple::LinkSection'){$x="[ " .pretty(@$_)." ]" ;$x}elsif(ref($_)eq 'SCALAR'){$x="\\" .pretty($$_);$x}elsif(ref($_)eq 'HASH'){my$hr=$_;$x="{" .join(", ",map(pretty($_).'=>' .pretty($hr->{$_}),sort keys %$hr))."}" ;$x}elsif(!length($_)){q{''}}elsif($_ eq '0' or(m/^-?(?:[123456789]\d*|0)(?:\.\d+)?$/s and $_ ne '-0')){$_}else {s<([^ !#'()*+,\-./0123456789:;\<=\>?ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\]^_`abcdefghijklmnopqrstuvwxyz{|}~])>
           <$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg;qq{"$_"}}}@stuff;return$out}sub reinit {my$self=shift;for (qw(source_dead source_filename doc_has_started start_of_pod_block content_seen last_was_blank paras curr_open line_count pod_para_count in_pod ~tried_gen_errata all_errata errata errors_seen Title)){delete$self->{$_}}}1;
POD_SIMPLE_BLACKBOX

$fatpacked{"Pod/Simple/Checker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_CHECKER';
  require 5;package Pod::Simple::Checker;use strict;use Carp ();use Pod::Simple::Methody ();use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.35';@ISA=('Pod::Simple::Methody');BEGIN {*DEBUG=defined(&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : sub() {0}}use Text::Wrap 98.112902 ();$Text::Wrap::wrap='overflow';sub any_errata_seen {return $_[1]->{'Errata_seen'}}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->{'Thispara'}='';$new->{'Indent'}=0;$new->{'Indentstring'}='   ';$new->{'Errata_seen'}=0;return$new}sub handle_text {$_[0]{'Errata_seen'}and $_[0]{'Thispara'}.= $_[1]}sub start_Para {$_[0]{'Thispara'}=''}sub start_head1 {if($_[0]{'Errata_seen'}){$_[0]{'Thispara'}=''}else {if($_[1]{'errata'}){$_[0]{'Errata_seen'}=1;$_[0]{'Thispara'}=$_[0]{'source_filename'}? "$_[0]{'source_filename'} -- " : ''}}}sub start_head2 {$_[0]{'Thispara'}=''}sub start_head3 {$_[0]{'Thispara'}=''}sub start_head4 {$_[0]{'Thispara'}=''}sub start_Verbatim {$_[0]{'Thispara'}=''}sub start_item_bullet {$_[0]{'Thispara'}='* '}sub start_item_number {$_[0]{'Thispara'}="$_[1]{'number'}. "}sub start_item_text {$_[0]{'Thispara'}=''}sub start_over_bullet {++$_[0]{'Indent'}}sub start_over_number {++$_[0]{'Indent'}}sub start_over_text {++$_[0]{'Indent'}}sub start_over_block {++$_[0]{'Indent'}}sub end_over_bullet {--$_[0]{'Indent'}}sub end_over_number {--$_[0]{'Indent'}}sub end_over_text {--$_[0]{'Indent'}}sub end_over_block {--$_[0]{'Indent'}}sub end_head1 {$_[0]->emit_par(-4)}sub end_head2 {$_[0]->emit_par(-3)}sub end_head3 {$_[0]->emit_par(-2)}sub end_head4 {$_[0]->emit_par(-1)}sub end_Para {$_[0]->emit_par(0)}sub end_item_bullet {$_[0]->emit_par(0)}sub end_item_number {$_[0]->emit_par(0)}sub end_item_text {$_[0]->emit_par(-2)}sub emit_par {return unless $_[0]{'Errata_seen'};my($self,$tweak_indent)=splice(@_,0,2);my$indent=' ' x (2 * $self->{'Indent'}+ ($tweak_indent||0));$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$out=Text::Wrap::wrap($indent,$indent,$self->{'Thispara'}.= "\n");$out =~ s/$Pod::Simple::nbsp/ /g;print {$self->{'output_fh'}}$out,;$self->{'Thispara'}='';return}sub end_Verbatim {return unless $_[0]{'Errata_seen'};my$self=shift;$self->{'Thispara'}=~ s/$Pod::Simple::nbsp/ /g;$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$i=' ' x (2 * $self->{'Indent'}+ 4);$self->{'Thispara'}=~ s/^/$i/mg;print {$self->{'output_fh'}}'',$self->{'Thispara'},"\n\n" ;$self->{'Thispara'}='';return}1;
POD_SIMPLE_CHECKER

$fatpacked{"Pod/Simple/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DEBUG';
  require 5;package Pod::Simple::Debug;use strict;use vars qw($VERSION);$VERSION='3.35';sub import {my($value,$variable);if(@_==2){$value=$_[1]}elsif(@_==3){($variable,$value)=@_[1,2];($variable,$value)=($value,$variable)if defined$value and ref($value)eq 'SCALAR' and not(defined$variable and ref($variable)eq 'SCALAR');unless(defined$variable and ref($variable)eq 'SCALAR'){require Carp;Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}}else {require Carp;Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}if(defined&Pod::Simple::DEBUG){require Carp;Carp::croak("It's too late to call Pod::Simple::Debug -- " ."Pod::Simple has already loaded\nAborting")}$value=0 unless defined$value;unless($value =~ m/^-?\d+$/){require Carp;Carp::croak("$value isn't a numeric value." ."\nUsage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}if(defined$variable){*Pod::Simple::DEBUG=sub () {$$variable};$$variable=$value;print STDERR "# Starting Pod::Simple::DEBUG = non-constant $variable with val $value\n"}else {*Pod::Simple::DEBUG=eval " sub () { $value } ";print STDERR "# Starting Pod::Simple::DEBUG = $value\n"}require Pod::Simple;return}1;
POD_SIMPLE_DEBUG

$fatpacked{"Pod/Simple/DumpAsText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASTEXT';
  require 5;package Pod::Simple::DumpAsText;$VERSION='3.35';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->accept_codes('VerbatimFormatted');$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print STDERR "++ $_[1]\n";print$fh '  ' x ($_[0]{'indent'}|| 0),"++",$_[1],"\n";$_[0]{'indent'}++;while(($key,$value)=each %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_perly_escape($key);_perly_escape($value);printf$fh qq{%s \\ "%s" => "%s"\n},'  ' x ($_[0]{'indent'}|| 0),$key,$value}}return}sub _handle_text {DEBUG and print STDERR "== \"$_[1]\"\n";if(length $_[1]){my$indent='  ' x $_[0]{'indent'};my$text=$_[1];_perly_escape($text);$text =~ s/(
           [^\n]{55}         # Snare some characters from a line
           [^\n\ ]{0,50}     #  and finish any current word
          )
          \ {1,10}(?!\n)     # capture some spaces not at line-end
         /$1"\n$indent . "/gx ;print {$_[0]{'output_fh'}}$indent,'* "',$text,"\"\n"}return}sub _handle_element_end {DEBUG and print STDERR "-- $_[1]\n";print {$_[0]{'output_fh'}}'  ' x --$_[0]{'indent'},"--",$_[1],"\n";return}sub _perly_escape {for my$x (@_){$x =~ s/([^\x00-\xFF])/sprintf'\x{%X}',ord($1)/eg;$x =~ s/([^-\n\t \&\<\>\'!\#\%\(\)\*\+,\.\/\:\;=\?\~\[\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf'\x%02X',ord($1)/eg}return}1;
POD_SIMPLE_DUMPASTEXT

$fatpacked{"Pod/Simple/DumpAsXML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASXML';
  require 5;package Pod::Simple::DumpAsXML;$VERSION='3.35';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();use Text::Wrap qw(wrap);BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->accept_codes('VerbatimFormatted');$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print STDERR "++ $_[1]\n";print$fh '  ' x ($_[0]{'indent'}|| 0),"<",$_[1];for my$key (sort keys %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value=$_[2]{$key});print$fh ' ',$key,'="',$value,'"'}}print$fh ">\n";$_[0]{'indent'}++;return}sub _handle_text {DEBUG and print STDERR "== \"$_[1]\"\n";if(length $_[1]){my$indent='  ' x $_[0]{'indent'};my$text=$_[1];_xml_escape($text);local$Text::Wrap::huge='overflow';$text=wrap('',$indent,$text);print {$_[0]{'output_fh'}}$indent,$text,"\n"}return}sub _handle_element_end {DEBUG and print STDERR "-- $_[1]\n";print {$_[0]{'output_fh'}}'  ' x --$_[0]{'indent'},"</",$_[1],">\n";return}sub _xml_escape {for my$x (@_){if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}}return}1;
POD_SIMPLE_DUMPASXML

$fatpacked{"Pod/Simple/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTML';
  require 5;package Pod::Simple::HTML;use strict;use Pod::Simple::PullParser ();use vars qw(@ISA %Tagmap $Computerese $LamePad $Linearization_Limit $VERSION $Perldoc_URL_Prefix $Perldoc_URL_Postfix $Man_URL_Prefix $Man_URL_Postfix $Title_Prefix $Title_Postfix $HTML_EXTENSION %ToIndex $Doctype_decl $Content_decl);@ISA=('Pod::Simple::PullParser');$VERSION='3.35';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}$Doctype_decl ||= '';$Content_decl ||= q{<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >};$HTML_EXTENSION='.html' unless defined$HTML_EXTENSION;$Computerese="" unless defined$Computerese;$LamePad='' unless defined$LamePad;$Linearization_Limit=120 unless defined$Linearization_Limit;$Perldoc_URL_Prefix='http://search.cpan.org/perldoc?' unless defined$Perldoc_URL_Prefix;$Perldoc_URL_Postfix='' unless defined$Perldoc_URL_Postfix;$Man_URL_Prefix='http://man.he.net/man';$Man_URL_Postfix='';$Title_Prefix='' unless defined$Title_Prefix;$Title_Postfix='' unless defined$Title_Postfix;%ToIndex=map {;$_=>1}qw(head1 head2 head3 head4);__PACKAGE__->_accessorize('perldoc_url_prefix','perldoc_url_postfix','man_url_prefix','man_url_postfix','batch_mode','batch_mode_current_level','title_prefix','title_postfix','html_h_level','html_header_before_title','html_header_after_title','html_footer','top_anchor','index','html_css','html_javascript','force_title','default_title',);my@_to_accept;%Tagmap=('Verbatim'=>"\n<pre$Computerese>",'/Verbatim'=>"</pre>\n",'VerbatimFormatted'=>"\n<pre$Computerese>",'/VerbatimFormatted'=>"</pre>\n",'VerbatimB'=>"<b>",'/VerbatimB'=>"</b>",'VerbatimI'=>"<i>",'/VerbatimI'=>"</i>",'VerbatimBI'=>"<b><i>",'/VerbatimBI'=>"</i></b>",'Data'=>"\n",'/Data'=>"\n",'head1'=>"\n<h1>",'head2'=>"\n<h2>",'head3'=>"\n<h3>",'head4'=>"\n<h4>",'/head1'=>"</a></h1>\n",'/head2'=>"</a></h2>\n",'/head3'=>"</a></h3>\n",'/head4'=>"</a></h4>\n",'X'=>"<!--\n\tINDEX: ",'/X'=>"\n-->",changes(qw(Para=p B=b I=i over-bullet=ul over-number=ol over-text=dl over-block=blockquote item-bullet=li item-number=li item-text=dt)),changes2(map {;m/^([-a-z]+)/s && push@_to_accept,$1;$_}qw[sample=samp definition=dfn keyboard=kbd variable=var citation=cite abbreviation=abbr acronym=acronym subscript=sub superscript=sup big=big small=small underline=u strikethrough=s preformat=pre teletype=tt]),'/item-bullet'=>"</li>$LamePad\n",'/item-number'=>"</li>$LamePad\n",'/item-text'=>"</a></dt>$LamePad\n",'item-body'=>"\n<dd>",'/item-body'=>"</dd>\n",'B'=>"<b>",'/B'=>"</b>",'I'=>"<i>",'/I'=>"</i>",'F'=>"<em$Computerese>",'/F'=>"</em>",'C'=>"<code$Computerese>",'/C'=>"</code>",'L'=>"<a href='YOU_SHOULD_NEVER_SEE_THIS'>",'/L'=>"</a>",);sub changes {return map {;m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s ? ($1,=>"\n<$2>","/$1",=>"</$2>\n"): die "Funky $_"}@_}sub changes2 {return map {;m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s ? ($1,=>"<$2>","/$1",=>"</$2>"): die "Funky $_"}@_}sub go {Pod::Simple::HTML->parse_from_file(@ARGV);exit 0}sub new {my$new=shift->SUPER::new(@_);$new->nbsp_for_S(1);$new->accept_targets('html','HTML');$new->accept_codes('VerbatimFormatted');$new->accept_codes(@_to_accept);DEBUG > 2 and print STDERR "To accept: ",join(' ',@_to_accept),"\n";$new->perldoc_url_prefix($Perldoc_URL_Prefix);$new->perldoc_url_postfix($Perldoc_URL_Postfix);$new->man_url_prefix($Man_URL_Prefix);$new->man_url_postfix($Man_URL_Postfix);$new->title_prefix($Title_Prefix);$new->title_postfix($Title_Postfix);$new->html_header_before_title(qq[$Doctype_decl<html><head><title>]);$new->html_header_after_title(join "\n"=>"</title>",$Content_decl,"</head>\n<body class='pod'>",$new->version_tag_comment,"<!-- start doc -->\n",);$new->html_footer(qq[\n<!-- end doc -->\n\n</body></html>\n]);$new->top_anchor("<a name='___top' class='dummyTopAnchor' ></a>\n");$new->{'Tagmap'}={%Tagmap};return$new}sub __adjust_html_h_levels {my ($self)=@_;my$Tagmap=$self->{'Tagmap'};my$add=$self->html_h_level;return unless defined$add;return if ($self->{'Adjusted_html_h_levels'}||0)==$add;$add -= 1;for (1 .. 4){$Tagmap->{"head$_"}=~ s/$_/$_ + $add/e;$Tagmap->{"/head$_"}=~ s/$_/$_ + $add/e}}sub batch_mode_page_object_init {my($self,$batchconvobj,$module,$infile,$outfile,$depth)=@_;DEBUG and print STDERR "Initting $self\n  for $module\n","  in $infile\n  out $outfile\n  depth $depth\n";$self->batch_mode(1);$self->batch_mode_current_level($depth);return$self}sub run {my$self=$_[0];return$self->do_middle if$self->bare_output;return $self->do_beginning && $self->do_middle && $self->do_end}sub do_beginning {my$self=$_[0];my$title;if(defined$self->force_title){$title=$self->force_title;DEBUG and print STDERR "Forcing title to be $title\n"}else {$title=$self->get_short_title();unless($self->content_seen){DEBUG and print STDERR "No content seen in search for title.\n";return}$self->{'Title'}=$title;if(defined$title and $title =~ m/\S/){$title=$self->title_prefix .esc($title).$self->title_postfix}else {$title=$self->default_title;$title='' unless defined$title;DEBUG and print STDERR "Title defaults to $title\n"}}my$after=$self->html_header_after_title || '';if($self->html_css){my$link=$self->html_css =~ m/</ ? $self->html_css : sprintf(qq[<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="%s">\n],$self->html_css,);$after =~ s{(</head>)}{$link\n$1}i}$self->_add_top_anchor(\$after);if($self->html_javascript){my$link=$self->html_javascript =~ m/</ ? $self->html_javascript : sprintf(qq[<script type="text/javascript" src="%s"></script>\n],$self->html_javascript,);$after =~ s{(</head>)}{$link\n$1}i}print {$self->{'output_fh'}}$self->html_header_before_title || '',$title,$after,;DEBUG and print STDERR "Returning from do_beginning...\n";return 1}sub _add_top_anchor {my($self,$text_r)=@_;unless($$text_r and $$text_r =~ m/name=['"]___top['"]/){$$text_r .= $self->top_anchor || ''}return}sub version_tag_comment {my$self=shift;return sprintf "<!--\n  generated by %s v%s,\n  using %s v%s,\n  under Perl v%s at %s GMT.\n\n %s\n\n-->\n",esc(ref($self),$self->VERSION(),$ISA[0],$ISA[0]->VERSION(),$],scalar(gmtime),),$self->_modnote(),}sub _modnote {my$class=ref($_[0])|| $_[0];return join "\n   "=>grep m/\S/,split "\n",qq{
  If you want to change this HTML document, you probably shouldn't do that
  by changing it directly.  Instead, see about changing the calling options
  to $class, and/or subclassing $class,
  then reconverting this document from the Pod source.
  When in doubt, email the author of $class for advice.
  See 'perldoc $class' for more info.
  }}sub do_end {my$self=$_[0];print {$self->{'output_fh'}}$self->html_footer || '';return 1}sub do_middle {my$self=$_[0];return$self->_do_middle_main_loop unless$self->index;if($self->output_string){my$out=$self->output_string;my$sneakytag="\f\f\e\e\b\bIndex Here\e\e\b\b\f\f\n";$$out .= $sneakytag;$self->_do_middle_main_loop;$sneakytag=quotemeta($sneakytag);my$index=$self->index_as_html();if($$out =~ s/$sneakytag/$index/s){DEBUG and print STDERR "Inserted ",length($index)," bytes of index HTML into $out.\n"}else {DEBUG and print STDERR "Odd, couldn't find where to insert the index in the output!\n"}return 1}unless($self->output_fh){require Carp;Carp::confess("Parser object \$p doesn't seem to have any output object!  I don't know how to deal with that.")}my$fh=$self->output_fh;my$content='';{$self->output_string(\$content);$self->_do_middle_main_loop;$self->abandon_output_string();$self->output_fh($fh)}print$fh $self->index_as_html();print$fh $content;return 1}sub index_as_html {my$self=$_[0];my$points=$self->{'PSHTML_index_points'}|| [];@$points > 1 or return qq[<div class='indexgroupEmpty'></div>\n];my(@out)=qq{\n<div class='indexgroup'>};my$level=0;my($target_level,$previous_tagname,$tagname,$text,$anchorname,$indent);for my$p (@$points,['head0','(end)']){($tagname,$text)=@$p;$anchorname=$self->section_escape($text);if($tagname =~ m{^head(\d+)$}){$target_level=0 + $1}else {if($previous_tagname =~ m{^head\d+$}){$target_level=$level + 1}else {$target_level=$level}}while($level > $target_level){--$level;push@out,("  " x $level)."</ul>"}while($level < $target_level){++$level;push@out,("  " x ($level-1))."<ul   class='indexList indexList$level'>"}$previous_tagname=$tagname;next unless$level;$indent='  ' x $level;push@out,sprintf "%s<li class='indexItem indexItem%s'><a href='#%s'>%s</a>",$indent,$level,esc($anchorname),esc($text)}push@out,"</div>\n";return join "\n",@out}sub _do_middle_main_loop {my$self=$_[0];my$fh=$self->{'output_fh'};my$tagmap=$self->{'Tagmap'};$self->__adjust_html_h_levels;my($token,$type,$tagname,$linkto,$linktype);my@stack;my$dont_wrap=0;while($token=$self->get_token){if(($type=$token->type)eq 'start'){if(($tagname=$token->tagname)eq 'L'){$linktype=$token->attr('type')|| 'insane';$linkto=$self->do_link($token);if(defined$linkto and length$linkto){esc($linkto);print$fh qq{<a href="$linkto" class="podlink$linktype"\n>}}else {print$fh "<a>"}}elsif ($tagname eq 'item-text' or $tagname =~ m/^head\d$/s){print$fh $tagmap->{$tagname}|| next;my@to_unget;while(1){push@to_unget,$self->get_token;last if$to_unget[-1]->is_end and $to_unget[-1]->tagname eq $tagname}my$name=$self->linearize_tokens(@to_unget);$name=$self->do_section($name,$token)if defined$name;print$fh "<a ";if ($tagname =~ m/^head\d$/s){print$fh "class='u'",$self->index ? " href='#___top' title='click to go to top of document'\n" : "\n"}if(defined$name){my$esc=esc($self->section_name_tidy($name));print$fh qq[name="$esc"];DEBUG and print STDERR "Linearized ",scalar(@to_unget)," tokens as \"$name\".\n";push @{$self->{'PSHTML_index_points'}},[$tagname,$name]if$ToIndex{$tagname }}else {DEBUG and print STDERR "Linearized ",scalar(@to_unget)," tokens, but it was too long, so nevermind.\n"}print$fh "\n>";$self->unget_token(@to_unget)}elsif ($tagname eq 'Data'){my$next=$self->get_token;next unless defined$next;unless($next->type eq 'text'){$self->unget_token($next);next}DEBUG and print STDERR "    raw text ",$next->text,"\n";(my$text=$next->text)=~ s/\n\z//;print$fh $text,"\n";next}else {if($tagname =~ m/^over-/s){push@stack,''}elsif($tagname =~ m/^item-/s and @stack and $stack[-1]){print$fh $stack[-1];$stack[-1]=''}print$fh $tagmap->{$tagname}|| next;++$dont_wrap if$tagname eq 'Verbatim' or $tagname eq "VerbatimFormatted" or $tagname eq 'X'}}elsif($type eq 'end'){if(($tagname=$token->tagname)=~ m/^over-/s){if(my$end=pop@stack){print$fh $end}}elsif($tagname =~ m/^item-/s and @stack){$stack[-1]=$tagmap->{"/$tagname"};if($tagname eq 'item-text' and defined(my$next=$self->get_token)){$self->unget_token($next);if($next->type eq 'start'){print$fh $tagmap->{"/item-text"},$tagmap->{"item-body"};$stack[-1]=$tagmap->{"/item-body"}}}next}print$fh $tagmap->{"/$tagname"}|| next;--$dont_wrap if$tagname eq 'Verbatim' or $tagname eq 'X'}elsif($type eq 'text'){esc($type=$token->text);$type =~ s/([\?\!\"\'\.\,]) /$1\n/g unless$dont_wrap;print$fh $type}}return 1}sub do_section {my($self,$name,$token)=@_;return$name}sub do_link {my($self,$token)=@_;my$type=$token->attr('type');if(!defined$type){$self->whine("Typeless L!?",$token->attr('start_line'))}elsif($type eq 'pod'){return$self->do_pod_link($token)}elsif($type eq 'url'){return$self->do_url_link($token)}elsif($type eq 'man'){return$self->do_man_link($token)}else {$self->whine("L of unknown type $type!?",$token->attr('start_line'))}return 'FNORG'}sub do_url_link {return $_[1]->attr('to')}sub do_man_link {my ($self,$link)=@_;my$to=$link->attr('to');my$frag=$link->attr('section');return undef unless defined$to and length$to;$frag=$self->section_escape($frag)if defined$frag and length($frag .= '');DEBUG and print STDERR "Resolving \"$to/$frag\"\n\n";return$self->resolve_man_page_link($to,$frag)}sub do_pod_link {my($self,$link)=@_;my$to=$link->attr('to');my$section=$link->attr('section');return undef unless((defined$to and length$to)or (defined$section and length$section));$section=$self->section_escape($section)if defined$section and length($section .= '');DEBUG and printf STDERR "Resolving \"%s\" \"%s\"...\n",$to || "(nil)",$section || "(nil)";{my$complete_url=$self->resolve_pod_link_by_table($to,$section);if($complete_url){DEBUG > 1 and print STDERR "resolve_pod_link_by_table(T,S) gives ",$complete_url,"\n  (Returning that.)\n";return$complete_url}else {DEBUG > 4 and print STDERR " resolve_pod_link_by_table(T,S)"," didn't return anything interesting.\n"}}if(defined$to and length$to){my$there=$self->resolve_pod_link_by_table($to);if(defined$there and length$there){DEBUG > 1 and print STDERR "resolve_pod_link_by_table(T) gives $there\n"}else {$there=$self->resolve_pod_page_link($to,$section);DEBUG > 1 and print STDERR "resolve_pod_page_link gives ",$there || "(nil)","\n";unless(defined$there and length$there){DEBUG and print STDERR "Can't resolve $to\n";return undef}}$to=$there}my$out=(defined$to and length$to)? $to : '';$out .= "#" .$section if defined$section and length$section;unless(length$out){DEBUG and printf STDERR "Oddly, couldn't resolve \"%s\" \"%s\"...\n",$to || "(nil)",$section || "(nil)";return undef}DEBUG and print STDERR "Resolved to $out\n";return$out}sub section_escape {my($self,$section)=@_;return$self->section_url_escape($self->section_name_tidy($section))}sub section_name_tidy {my($self,$section)=@_;$section =~ s/^\s+//;$section =~ s/\s+$//;$section =~ tr/ /_/;if ($] ge 5.006){$section =~ s/[[:cntrl:][:^ascii:]]//g}elsif ('A' eq chr(65)){$section =~ tr/\x00-\x1F\x80-\x9F//d}$section=$self->unicode_escape_url($section);$section='_' unless length$section;return$section}sub section_url_escape {shift->general_url_escape(@_)}sub pagepath_url_escape {shift->general_url_escape(@_)}sub manpage_url_escape {shift->general_url_escape(@_)}sub general_url_escape {my($self,$string)=@_;$string =~ s/([^\x00-\xFF])/join '', map sprintf('%%%02X',$_), unpack 'C*', $1/eg;if ($] ge 5.007_003){$string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',utf8::native_to_unicode(ord($1)))/eg}else {$string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',ord($1))/eg}return$string}sub resolve_pod_page_link {my$self=shift;return$self->batch_mode()? $self->resolve_pod_page_link_batch_mode(@_): $self->resolve_pod_page_link_singleton_mode(@_)}sub resolve_pod_page_link_singleton_mode {my($self,$it)=@_;return undef unless defined$it and length$it;my$url=$self->pagepath_url_escape($it);$url =~ s{::$}{}s;$url =~ s{::}{/}g unless$self->perldoc_url_prefix =~ m/\?/s;return undef unless length$url;return$self->perldoc_url_prefix .$url .$self->perldoc_url_postfix}sub resolve_pod_page_link_batch_mode {my($self,$to)=@_;DEBUG > 1 and print STDERR " During batch mode, resolving $to ...\n";my@path=grep length($_),split m/::/s,$to,-1;unless(@path){DEBUG and print STDERR "Very odd!  Splitting $to gives (nil)!\n";return undef}$self->batch_mode_rectify_path(\@path);my$out=join('/',map$self->pagepath_url_escape($_),@path).$HTML_EXTENSION;DEBUG > 1 and print STDERR " => $out\n";return$out}sub batch_mode_rectify_path {my($self,$pathbits)=@_;my$level=$self->batch_mode_current_level;$level--;if($level < 1){unshift @$pathbits,'.'}else {unshift @$pathbits,('..')x $level}return}sub resolve_man_page_link {my ($self,$to,$frag)=@_;my ($page,$section)=$to =~ /^([^(]+)(?:[(](\d+)[)])?$/;return undef unless defined$page and length$page;$section ||= 1;return$self->man_url_prefix ."$section/" .$self->manpage_url_escape($page).$self->man_url_postfix}sub resolve_pod_link_by_table {return unless $_[0]->{'podhtml_LOT'};my($self,$to,$section)=@_;if(defined$section){$to='' unless defined$to and length$to;return$self->{'podhtml_LOT'}{"$to#$section"}}else {return$self->{'podhtml_LOT'}{$to}}return}sub linearize_tokens {my$self=shift;my$out='';my$t;while($t=shift @_){if(!ref$t or!UNIVERSAL::can($t,'is_text')){$out .= $t}elsif($t->is_text){$out .= $t->text}elsif($t->is_start and $t->tag eq 'X'){my$x_open=1;while($x_open){next if(($t=shift @_)->is_text);if($t->is_start and $t->tag eq 'X'){++$x_open}elsif($t->is_end and $t->tag eq 'X'){--$x_open}}}}return undef if length$out > $Linearization_Limit;return$out}sub unicode_escape_url {my($self,$string)=@_;$string =~ s/([^\x00-\xFF])/'('.ord($1).')'/eg;return$string}sub esc {if(defined wantarray){if(wantarray){@_=splice @_}else {my$x=shift;if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}return$x}}for my$x (@_){if (defined$x){if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}}}return @_}1;
POD_SIMPLE_HTML

$fatpacked{"Pod/Simple/HTMLBatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLBATCH';
  require 5;package Pod::Simple::HTMLBatch;use strict;use vars qw($VERSION $HTML_RENDER_CLASS $HTML_EXTENSION $CSS $JAVASCRIPT $SLEEPY $SEARCH_CLASS @ISA);$VERSION='3.35';@ISA=();use Pod::Simple::HTML ();BEGIN {*esc=\&Pod::Simple::HTML::esc}use File::Spec ();use Pod::Simple::Search;$SEARCH_CLASS ||= 'Pod::Simple::Search';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}$SLEEPY=1 if!defined$SLEEPY and $^O =~ /mswin|mac/i;$HTML_RENDER_CLASS ||= "Pod::Simple::HTML";Pod::Simple::_accessorize(__PACKAGE__,'verbose','html_render_class','search_class','contents_file','index','progress','contents_page_start','contents_page_end','css_flurry','_css_wad','javascript_flurry','_javascript_wad','no_contents_links','_contents',);sub go {@ARGV==2 or die sprintf("Usage: perl -M%s -e %s:go indirs outdir\n  (or use \"\@INC\" for indirs)\n",__PACKAGE__,__PACKAGE__,);if(defined($ARGV[1])and length($ARGV[1])){my$d=$ARGV[1];-e $d or die "I see no output directory named \"$d\"\nAborting";-d $d or die "But \"$d\" isn't a directory!\nAborting";-w $d or die "Directory \"$d\" isn't writeable!\nAborting"}__PACKAGE__->batch_convert(@ARGV)}sub new {my$new=bless {},ref($_[0])|| $_[0];$new->html_render_class($HTML_RENDER_CLASS);$new->search_class($SEARCH_CLASS);$new->verbose(1 + DEBUG);$new->_contents([]);$new->index(1);$new-> _css_wad([]);$new->css_flurry(1);$new->_javascript_wad([]);$new->javascript_flurry(1);$new->contents_file('index' .($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION));$new->contents_page_start(join "\n",grep $_,$Pod::Simple::HTML::Doctype_decl,"<html><head>","<title>Perl Documentation</title>",$Pod::Simple::HTML::Content_decl,"</head>","\n<body class='contentspage'>\n<h1>Perl Documentation</h1>\n");$new->contents_page_end(sprintf("\n\n<p class='contentsfooty'>Generated by %s v%s under Perl v%s\n<br >At %s GMT, which is %s local time.</p>\n\n</body></html>\n",esc(ref($new),eval {$new->VERSION}|| $VERSION,$],scalar(gmtime),scalar(localtime),)));return$new}sub muse {my$self=shift;if($self->verbose){print 'T+',int(time()- $self->{'_batch_start_time'}),"s: ",@_,"\n"}return 1}sub batch_convert {my($self,$dirs,$outdir)=@_;$self ||= __PACKAGE__;$self=$self->new unless ref$self;if(!defined($dirs)or $dirs eq '' or $dirs eq '@INC'){$dirs=''}elsif(ref$dirs){}else {require Config;my$ps=quotemeta($Config::Config{'path_sep'}|| ":");$dirs=[grep length($_),split qr/$ps/,$dirs ]}$outdir=$self->filespecsys->curdir unless defined$outdir and length$outdir;$self->_batch_convert_main($dirs,$outdir)}sub _batch_convert_main {my($self,$dirs,$outdir)=@_;$self->{'_batch_start_time'}||= time();$self->muse("= ",scalar(localtime));$self->muse("Starting batch conversion to \"$outdir\"");my$progress=$self->progress;if(!$progress and $self->verbose > 0 and $self->verbose()<= 5){require Pod::Simple::Progress;$progress=Pod::Simple::Progress->new(($self->verbose < 2)? (): ($self->verbose==2)? 1 : 0);$self->progress($progress)}if($dirs){$self->muse(scalar(@$dirs)," dirs to scan: @$dirs")}else {$self->muse("Scanning \@INC.  This could take a minute or two.")}my$mod2path=$self->find_all_pods($dirs ? $dirs : ());$self->muse("Done scanning.");my$total=keys %$mod2path;unless($total){$self->muse("No pod found.  Aborting batch conversion.\n");return$self}$progress and $progress->goal($total);$self->muse("Now converting pod files to HTML.",($total > 25)? "  This will take a while more." : ());$self->_spray_css($outdir);$self->_spray_javascript($outdir);$self->_do_all_batch_conversions($mod2path,$outdir);$progress and $progress->done(sprintf ("Done converting %d files.",$self->{"__batch_conv_page_count"}));return$self->_batch_convert_finish($outdir);return$self}sub _do_all_batch_conversions {my($self,$mod2path,$outdir)=@_;$self->{"__batch_conv_page_count"}=0;for my$module (sort {lc($a)cmp lc($b)}keys %$mod2path){$self->_do_one_batch_conversion($module,$mod2path,$outdir);sleep($SLEEPY - 1)if$SLEEPY}return}sub _batch_convert_finish {my($self,$outdir)=@_;$self->write_contents_file($outdir);$self->muse("Done with batch conversion.  $$self{'__batch_conv_page_count'} files done.");$self->muse("= ",scalar(localtime));$self->progress and $self->progress->done("All done!");return}sub _do_one_batch_conversion {my($self,$module,$mod2path,$outdir,$outfile)=@_;my$retval;my$total=scalar keys %$mod2path;my$infile=$mod2path->{$module};my@namelets=grep m/\S/,split "::",$module;my$depth=scalar@namelets;die "Contentless thingie?! $module $infile" unless@namelets;$outfile ||= do {my@n=@namelets;$n[-1].= $HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION;$self->filespecsys->catfile($outdir,@n)};my$progress=$self->progress;my$page=$self->html_render_class->new;if(DEBUG > 5){$self->muse($self->{"__batch_conv_page_count"}+ 1,"/$total: ",ref($page)," render ($depth) $module => $outfile")}elsif(DEBUG > 2){$self->muse($self->{"__batch_conv_page_count"}+ 1,"/$total: $module => $outfile")}$page->batch_mode_page_object_init($self,$module,$infile,$outfile,$depth)if$page->can('batch_mode_page_object_init');$self->batch_mode_page_object_init($page,$module,$infile,$outfile,$depth)if$self->can('batch_mode_page_object_init');$self->makepath($outdir=>\@namelets);$progress and $progress->reach($self->{"__batch_conv_page_count"},"Rendering $module");if($retval=$page->parse_from_file($infile,$outfile)){++ $self->{"__batch_conv_page_count"};$self->note_for_contents_file(\@namelets,$infile,$outfile)}else {$self->muse("Odd, parse_from_file(\"$infile\", \"$outfile\") returned false.")}$page->batch_mode_page_object_kill($self,$module,$infile,$outfile,$depth)if$page->can('batch_mode_page_object_kill');$self->batch_mode_page_object_kill($page,$module,$infile,$outfile,$depth)if$self->can('batch_mode_page_object_kill');DEBUG > 4 and printf STDERR "%s %sb < $infile %s %sb\n",$outfile,-s $outfile,$infile,-s $infile ;undef($page);return$retval}sub filespecsys {$_[0]{'_filespecsys'}|| 'File::Spec'}sub note_for_contents_file {my($self,$namelets,$infile,$outfile)=@_;if($self->contents_file){my$c=$self->_contents();push @$c,[join("::",@$namelets),$infile,$outfile,$namelets ];DEBUG > 3 and print STDERR "Noting @$c[-1]\n"}return}sub write_contents_file {my($self,$outdir)=@_;my$outfile=$self->_contents_filespec($outdir)|| return;$self->muse("Preparing list of modules for ToC");my($toplevel,$toplevel_form_freq,)=$self->_prep_contents_breakdown;my$Contents=eval {$self->_wopen($outfile)};if($Contents){$self->muse("Writing contents file $outfile")}else {warn "Couldn't write-open contents file $outfile: $!\nAbort writing to $outfile at all";return}$self->_write_contents_start($Contents,$outfile,);$self->_write_contents_middle($Contents,$outfile,$toplevel,$toplevel_form_freq);$self->_write_contents_end($Contents,$outfile,);return$outfile}sub _write_contents_start {my($self,$Contents,$outfile)=@_;my$starter=$self->contents_page_start || '';{my$css_wad=$self->_css_wad_to_markup(1);if($css_wad){$starter =~ s{(</head>)}{\n$css_wad\n$1}i}my$javascript_wad=$self->_javascript_wad_to_markup(1);if($javascript_wad){$starter =~ s{(</head>)}{\n$javascript_wad\n$1}i}}unless(print$Contents $starter,"<dl class='superindex'>\n"){warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Contents);return 0}return 1}sub _write_contents_middle {my($self,$Contents,$outfile,$toplevel2submodules,$toplevel_form_freq)=@_;for my$t (sort keys %$toplevel2submodules){my@downlines=sort {$a->[-1]cmp $b->[-1]}@{$toplevel2submodules->{$t}};printf$Contents qq[<dt><a name="%s">%s</a></dt>\n<dd>\n],esc($t,$toplevel_form_freq->{$t});my($path,$name);for my$e (@downlines){$name=$e->[0];$path=join("/",'.',esc(@{$e->[3]})).($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION);print$Contents qq{  <a href="$path">},esc($name),"</a>&nbsp;&nbsp;\n"}print$Contents "</dd>\n\n"}return 1}sub _write_contents_end {my($self,$Contents,$outfile)=@_;unless(print$Contents "</dl>\n",$self->contents_page_end || '',){warn "Couldn't write to $outfile: $!"}close($Contents)or warn "Couldn't close $outfile: $!";return 1}sub _prep_contents_breakdown {my($self)=@_;my$contents=$self->_contents;my%toplevel;my%toplevel_form_freq;for my$entry (@$contents){my$toplevel=$entry->[0]=~ m/^perl\w*$/ ? 'perl_core_docs' : $entry->[3][0];++$toplevel_form_freq{lc$toplevel }{$toplevel };push @{$toplevel{lc$toplevel }},$entry;push @$entry,lc($entry->[0])}for my$toplevel (sort keys%toplevel){my$fgroup=$toplevel_form_freq{$toplevel};$toplevel_form_freq{$toplevel}=(sort {$fgroup->{$b}<=> $fgroup->{$a}or $a cmp $b}keys %$fgroup)[0]}return(\%toplevel,\%toplevel_form_freq)if wantarray;return \%toplevel}sub _contents_filespec {my($self,$outdir)=@_;my$outfile=$self->contents_file;return unless$outfile;return$self->filespecsys->catfile($outdir,$outfile)}sub makepath {my($self,$outdir,$namelets)=@_;return unless @$namelets > 1;for my$i (0 .. ($#$namelets - 1)){my$dir=$self->filespecsys->catdir($outdir,@$namelets[0 .. $i]);if(-e $dir){die "$dir exists but not as a directory!?" unless -d $dir;next}DEBUG > 3 and print STDERR "  Making $dir\n";mkdir$dir,0777 or die "Can't mkdir $dir: $!\nAborting" }return}sub batch_mode_page_object_init {my$self=shift;my($page,$module,$infile,$outfile,$depth)=@_;$page->default_title($module);$page->index($self->index);$page->html_css($self-> _css_wad_to_markup($depth));$page->html_javascript($self->_javascript_wad_to_markup($depth));$self->add_header_backlink($page,$module,$infile,$outfile,$depth);$self->add_footer_backlink($page,$module,$infile,$outfile,$depth);return$self}sub add_header_backlink {my$self=shift;return if$self->no_contents_links;my($page,$module,$infile,$outfile,$depth)=@_;$page->html_header_after_title(join '',$page->html_header_after_title || '',qq[<p class="backlinktop"><b><a name="___top" href="],$self->url_up_to_contents($depth),qq[" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>\n],)if$self->contents_file ;return}sub add_footer_backlink {my$self=shift;return if$self->no_contents_links;my($page,$module,$infile,$outfile,$depth)=@_;$page->html_footer(join '',qq[<p class="backlinkbottom"><b><a name="___bottom" href="],$self->url_up_to_contents($depth),qq[" title="All Documents">&lt;&lt;</a></b></p>\n],$page->html_footer || '',)if$self->contents_file ;return}sub url_up_to_contents {my($self,$depth)=@_;--$depth;return join '/',('..')x $depth,esc($self->contents_file)}sub find_all_pods {my($self,$dirs)=@_;return$self->modnames2paths($dirs)}sub modnames2paths {my($self,$dirs)=@_;my$m2p;{my$search=$self->search_class->new;DEBUG and print STDERR "Searching via $search\n";$search->verbose(1)if DEBUG > 10;$search->progress($self->progress->copy->goal(0))if$self->progress;$search->shadows(0);$search->inc($dirs ? 0 : 1);$search->survey($dirs ? @$dirs : ());$m2p=$search->name2path;die "What, no name2path?!" unless$m2p}$self->muse("That's odd... no modules found!")unless keys %$m2p;if(DEBUG > 4){print STDERR "Modules found (name => path):\n";for my$m (sort {lc($a)cmp lc($b)}keys %$m2p){print STDERR "  $m  $$m2p{$m}\n"}print STDERR "(total ",scalar(keys %$m2p),")\n\n"}elsif(DEBUG){print STDERR "Found ",scalar(keys %$m2p)," modules.\n"}$self->muse("Found ",scalar(keys %$m2p)," modules.");return$m2p}sub _wopen {my($self,$outpath)=@_;require Symbol;my$out_fh=Symbol::gensym();DEBUG > 5 and print STDERR "Write-opening to $outpath\n";return$out_fh if open($out_fh,"> $outpath");require Carp;Carp::croak("Can't write-open $outpath: $!")}sub add_css {my($self,$url,$is_default,$name,$content_type,$media,$_code)=@_;return unless$url;unless($name){$name=$url;if($name !~ m/\?/ and $name =~ m{([^/]+)$}s){$name=$1;$name =~ s/\.css//i}}$media ||= 'all';$content_type ||= 'text/css';my$bunch=[$url,$name,$content_type,$media,$_code];if($is_default){unshift @{$self->_css_wad},$bunch}else {push @{$self->_css_wad},$bunch}return}sub _spray_css {my($self,$outdir)=@_;return unless$self->css_flurry();$self->_gen_css_wad();my$lol=$self->_css_wad;for my$chunk (@$lol){my$url=$chunk->[0];my$outfile;if(ref($chunk->[-1])and $url =~ m{^(_[-a-z0-9_]+\.css$)}){$outfile=$self->filespecsys->catfile($outdir,"$1");DEBUG > 5 and print STDERR "Noting $$chunk[0] as a file I'll create.\n"}else {DEBUG > 5 and print STDERR "OK, noting $$chunk[0] as an external CSS.\n";next}my$Cssout=$self->_wopen($outfile);print$Cssout ${$chunk->[-1]}or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Cssout);DEBUG > 5 and print STDERR "Wrote $outfile\n"}return}sub _css_wad_to_markup {my($self,$depth)=@_;my@css=@{$self->_css_wad || return ''};return '' unless@css;my$rel='stylesheet';my$out='';--$depth;my$uplink=$depth ? ('../' x $depth): '';for my$chunk (@css){next unless$chunk and @$chunk;my($url1,$url2,$title,$type,$media)=($self->_maybe_uplink($chunk->[0],$uplink),esc(grep!ref($_),@$chunk));$out .= qq{<link rel="$rel" title="$title" type="$type" href="$url1$url2" media="$media" >\n};$rel='alternate stylesheet'}return$out}sub _maybe_uplink {my($self,$url,$uplink)=@_;($url =~ m{^\./} or $url !~ m{[/\:]})? $uplink : ''}sub _gen_css_wad {my$self=$_[0];my$css_template=$self->_css_template;for my$variation ('110n=blkbluw','010n=blkmagw','100n=blkcynw','101=whtprpk','001=whtnavk','010a=grygrnk','010b=whtgrng','101an=blkgrng','101bn=grygrnw',){my$outname=$variation;my($flipmode,@swap)=(($4 || ''),$1,$2,$3)if$outname =~ s/^([012])([012])([[012])([a-z]*)=?//s;@swap=()if '010' eq join '',@swap;my$this_css="/* This file is autogenerated.  Do not edit.  $variation */\n\n" .$css_template;if($flipmode =~ m/n/){$this_css =~ s/(#[0-9a-fA-F]{3})\b/_color_negate($1)/eg;$this_css =~ s/\bthin\b/medium/g}$this_css =~ s<#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])\b>
                    < join '', '#', ($1,$2,$3)[@swap] >eg if@swap;if($flipmode =~ m/a/){$this_css =~ s/#fff\b/#999/gi}elsif($flipmode =~ m/b/){$this_css =~ s/#000\b/#666/gi}my$name=$outname;$name =~ tr/-_/  /;$self->add_css("_$outname.css",0,$name,0,0,\$this_css)}for my$variation ('blkbluw','whtpurk','whtgrng','grygrnw',){my$outname=$variation;my$this_css=join "\n","/* This file is autogenerated.  Do not edit.  $outname */\n","\@import url(\"./_$variation.css\");",".indexgroup { display: none; }","\n",;my$name=$outname;$name =~ tr/-_/  /;$self->add_css("_$outname.css",0,$name,0,0,\$this_css)}return}sub _color_negate {my$x=lc $_[0];$x =~ tr[0123456789abcdef]
            [fedcba9876543210];return$x}sub add_javascript {my($self,$url,$content_type,$_code)=@_;return unless$url;push @{$self->_javascript_wad},[$url,$content_type || 'text/javascript',$_code ];return}sub _spray_javascript {my($self,$outdir)=@_;return unless$self->javascript_flurry();$self->_gen_javascript_wad();my$lol=$self->_javascript_wad;for my$script (@$lol){my$url=$script->[0];my$outfile;if(ref($script->[-1])and $url =~ m{^(_[-a-z0-9_]+\.js$)}){$outfile=$self->filespecsys->catfile($outdir,"$1");DEBUG > 5 and print STDERR "Noting $$script[0] as a file I'll create.\n"}else {DEBUG > 5 and print STDERR "OK, noting $$script[0] as an external JavaScript.\n";next}my$Jsout=$self->_wopen($outfile);print$Jsout ${$script->[-1]}or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Jsout);DEBUG > 5 and print STDERR "Wrote $outfile\n"}return}sub _gen_javascript_wad {my$self=$_[0];my$js_code=$self->_javascript || return;$self->add_javascript("_podly.js",0,\$js_code);return}sub _javascript_wad_to_markup {my($self,$depth)=@_;my@scripts=@{$self->_javascript_wad || return ''};return '' unless@scripts;my$out='';--$depth;my$uplink=$depth ? ('../' x $depth): '';for my$s (@scripts){next unless$s and @$s;my($url1,$url2,$type,$media)=($self->_maybe_uplink($s->[0],$uplink),esc(grep!ref($_),@$s));$out .= qq{<script type="$type" src="$url1$url2"></script>\n}}return$out}sub _css_template {return$CSS}sub _javascript {return$JAVASCRIPT}$CSS=<<'EOCSS';$JAVASCRIPT=<<'EOJAVASCRIPT';1;
  /* For accessibility reasons, never specify text sizes in px/pt/pc/in/cm/mm */
  
  @media all { .hide { display: none; } }
  
  @media print {
    .noprint, div.indexgroup, .backlinktop, .backlinkbottom { display: none }
  
    * {
      border-color: black !important;
      color: black !important;
      background-color: transparent !important;
      background-image: none !important;
    }
  
    dl.superindex > dd  {
      word-spacing: .6em;
    }
  }
  
  @media aural, braille, embossed {
    div.indexgroup  { display: none; }  /* Too noisy, don't you think? */
    dl.superindex > dt:before { content: "Group ";  }
    dl.superindex > dt:after  { content: " contains:"; }
    .backlinktop    a:before  { content: "Back to contents"; }
    .backlinkbottom a:before  { content: "Back to contents"; }
  }
  
  @media aural {
    dl.superindex > dt  { pause-before: 600ms; }
  }
  
  @media screen, tty, tv, projection {
    .noscreen { display: none; }
  
    a:link    { color: #7070ff; text-decoration: underline; }
    a:visited { color: #e030ff; text-decoration: underline; }
    a:active  { color: #800000; text-decoration: underline; }
    body.contentspage a            { text-decoration: none; }
    a.u { color: #fff !important; text-decoration: none; }
  
    body.pod {
      margin: 0 5px;
      color:            #fff;
      background-color: #000;
    }
  
    body.pod h1, body.pod h2, body.pod h3, body.pod h4  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      margin-top: 1.2em;
      margin-bottom: .1em;
      border-top: thin solid transparent;
      /* margin-left: -5px;  border-left: 2px #7070ff solid;  padding-left: 3px; */
    }
    
    body.pod h1  { border-top-color: #0a0; }
    body.pod h2  { border-top-color: #080; }
    body.pod h3  { border-top-color: #040; }
    body.pod h4  { border-top-color: #010; }
  
    p.backlinktop + h1 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h2 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h3 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h4 { border-top: none; margin-top: 0em;  }
  
    body.pod dt {
      font-size: 105%; /* just a wee bit more than normal */
    }
  
    .indexgroup { font-size: 80%; }
  
    .backlinktop,   .backlinkbottom    {
      margin-left:  -5px;
      margin-right: -5px;
      background-color:         #040;
      border-top:    thin solid #050;
      border-bottom: thin solid #050;
    }
    
    .backlinktop a, .backlinkbottom a  {
      text-decoration: none;
      color: #080;
      background-color:  #000;
      border: thin solid #0d0;
    }
    .backlinkbottom { margin-bottom: 0; padding-bottom: 0; }
    .backlinktop    { margin-top:    0; padding-top:    0; }
  
    body.contentspage {
      color:            #fff;
      background-color: #000;
    }
    
    body.contentspage h1  {
      color:            #0d0;
      margin-left: 1em;
      margin-right: 1em;
      text-indent: -.9em;
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      border-top:    thin solid #fff;
      border-bottom: thin solid #fff;
      text-align: center;
    }
  
    dl.superindex > dt  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      font-size: 90%;
      margin-top: .45em;
      /* margin-bottom: -.15em; */
    }
    dl.superindex > dd  {
      word-spacing: .6em;    /* most important rule here! */
    }
    dl.superindex > a:link  {
      text-decoration: none;
      color: #fff;
    }
  
    .contentsfooty {
      border-top: thin solid #999;
      font-size: 90%;
    }
    
  }
  
  /* The End */
  
  EOCSS
  
  // From http://www.alistapart.com/articles/alternate/
  
  function setActiveStyleSheet(title) {
    var i, a, main;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")) {
        a.disabled = true;
        if(a.getAttribute("title") == title) a.disabled = false;
      }
    }
  }
  
  function getActiveStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("title")
         && !a.disabled
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function getPreferredStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("rel").indexOf("alt") == -1
         && a.getAttribute("title")
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function createCookie(name,value,days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      var expires = "; expires="+date.toGMTString();
    }
    else expires = "";
    document.cookie = name+"="+value+expires+"; path=/";
  }
  
  function readCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0  ;  i < ca.length  ;  i++) {
      var c = ca[i];
      while (c.charAt(0)==' ') c = c.substring(1,c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
  }
  
  window.onload = function(e) {
    var cookie = readCookie("style");
    var title = cookie ? cookie : getPreferredStyleSheet();
    setActiveStyleSheet(title);
  }
  
  window.onunload = function(e) {
    var title = getActiveStyleSheet();
    createCookie("style", title, 365);
  }
  
  var cookie = readCookie("style");
  var title = cookie ? cookie : getPreferredStyleSheet();
  setActiveStyleSheet(title);
  
  // The End
  
  EOJAVASCRIPT
POD_SIMPLE_HTMLBATCH

$fatpacked{"Pod/Simple/HTMLLegacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLLEGACY';
  require 5;package Pod::Simple::HTMLLegacy;use strict;use vars qw($VERSION);use Getopt::Long;$VERSION="5.01";sub pod2html {my@args=(@_);my($verbose,$infile,$outfile,$title);my$index=1;{my($help);my($netscape);local@ARGV=@args;GetOptions("help"=>\$help,"verbose!"=>\$verbose,"infile=s"=>\$infile,"outfile=s"=>\$outfile,"title=s"=>\$title,"index!"=>\$index,"netscape!"=>\$netscape,)or return bad_opts(@args);bad_opts(@args)if@ARGV;return help_message()if$help}for($infile,$outfile){$_=undef unless defined and length}if($verbose){warn sprintf "%s version %s\n",__PACKAGE__,$VERSION;warn "OK, processed args [@args] ...\n";warn sprintf " Verbose: %s\n Index: %s\n Infile: %s\n Outfile: %s\n Title: %s\n",map defined($_)? $_ : "(nil)",$verbose,$index,$infile,$outfile,$title,;*Pod::Simple::HTML::DEBUG=sub(){1}}require Pod::Simple::HTML;Pod::Simple::HTML->VERSION(3);die "No such input file as $infile\n" if defined$infile and!-e $infile;my$pod=Pod::Simple::HTML->new;$pod->force_title($title)if defined$title;$pod->index($index);return$pod->parse_from_file($infile,$outfile)}sub bad_opts {die _help_message()}sub help_message {print STDOUT _help_message()}sub _help_message {join '',"[",__PACKAGE__," version ",$VERSION,qq~]
  Usage:  pod2html --help --infile=<name> --outfile=<name>
     --verbose --index --noindex
  
  Options:
    --help         - prints this message.
    --[no]index    - generate an index at the top of the resulting html
                     (default behavior).
    --infile       - filename for the pod to convert (input taken from stdin
                     by default).
    --outfile      - filename for the resulting html file (output sent to
                     stdout by default).
    --title        - title that will appear in resulting html file.
    --[no]verbose  - self-explanatory (off by default).
  
  Note that pod2html is DEPRECATED, and this version implements only
   some of the options known to older versions.
  For more information, see 'perldoc pod2html'.
  ~}1;
POD_SIMPLE_HTMLLEGACY

$fatpacked{"Pod/Simple/LinkSection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_LINKSECTION';
  require 5;package Pod::Simple::LinkSection;use vars qw($VERSION);$VERSION='3.35';use strict;use Pod::Simple::BlackBox;use vars qw($VERSION);$VERSION='3.35';use overload('""'=>\&Pod::Simple::BlackBox::stringify_lol,'bool'=>\&Pod::Simple::BlackBox::stringify_lol,'fallback'=>1,);sub tack_on {$_[0]=['',{},"$_[0]" ];return $_[0][2].= $_[1]}sub as_string {goto&Pod::Simple::BlackBox::stringify_lol}sub stringify {goto&Pod::Simple::BlackBox::stringify_lol}sub new {my$class=shift;$class=ref($class)|| $class;my$new;if(@_==1){if (!ref($_[0]|| '')){return bless ['',{},$_[0]],$class}elsif(ref($_[0]|| '')eq 'ARRAY'){$new=[@{$_[0]}]}else {Carp::croak("$class new() doesn't know to clone $new")}}else {$new=['',{},@_ ]}for my$x (@$new){if(ref($x || '')eq 'ARRAY'){$x=$class->new($x)}elsif(ref($x || '')eq 'HASH'){$x={%$x }}}return bless$new,$class}1;
POD_SIMPLE_LINKSECTION

$fatpacked{"Pod/Simple/Methody.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_METHODY';
  require 5;package Pod::Simple::Methody;use strict;use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.35';@ISA=('Pod::Simple');sub _handle_element_start {$_[1]=~ tr/-:./__/;($_[0]->can('start_' .$_[1])|| return)->($_[0],$_[2])}sub _handle_text {($_[0]->can('handle_text')|| return)->(@_)}sub _handle_element_end {$_[1]=~ tr/-:./__/;($_[0]->can('end_' .$_[1])|| return)->($_[0],$_[2])}1;
POD_SIMPLE_METHODY

$fatpacked{"Pod/Simple/Progress.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PROGRESS';
  require 5;package Pod::Simple::Progress;$VERSION='3.35';use strict;sub new {my($class,$delay)=@_;my$self=bless {'quiet_until'=>1},ref($class)|| $class;$self->to(*STDOUT{IO});$self->delay(defined($delay)? $delay : 5);return$self}sub copy {my$orig=shift;bless {%$orig,'quiet_until'=>1},ref($orig)}sub reach {my($self,$point,$note)=@_;if((my$now=time)>= $self->{'quiet_until'}){my$goal;my$to=$self->{'to'};print$to join('',($self->{'quiet_until'}==1)? (): '... ',(defined$point)? ('#',($goal=$self->{'goal'})? (' ' x (length($goal)- length($point)),$point,'/',$goal,): $point,$note ? ': ' : (),): (),$note || '',"\n");$self->{'quiet_until'}=$now + $self->{'delay'}}return$self}sub done {my($self,$note)=@_;$self->{'quiet_until'}=1;return$self->reach(undef,$note)}sub delay {return $_[0]{'delay'}if @_==1;$_[0]{'delay'}=$_[1];return $_[0]}sub goal {return $_[0]{'goal' }if @_==1;$_[0]{'goal' }=$_[1];return $_[0]}sub to {return $_[0]{'to' }if @_==1;$_[0]{'to' }=$_[1];return $_[0]}unless(caller){my$p=__PACKAGE__->new->goal(5);$p->reach(1,"Primus!");sleep 1;$p->reach(2,"Secundus!");sleep 3;$p->reach(3,"Tertius!");sleep 5;$p->reach(4);$p->reach(5,"Quintus!");sleep 1;$p->done("All done")}1;
POD_SIMPLE_PROGRESS

$fatpacked{"Pod/Simple/PullParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSER';
  require 5;package Pod::Simple::PullParser;$VERSION='3.35';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();use Pod::Simple::PullParserStartToken;use Pod::Simple::PullParserEndToken;use Pod::Simple::PullParserTextToken;BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}__PACKAGE__->_accessorize('source_fh','source_scalar_ref','source_arrayref',);sub filter {my($self,$source)=@_;$self=$self->new unless ref$self;$source=*STDIN{IO}unless defined$source;$self->set_source($source);$self->output_fh(*STDOUT{IO});$self->run;return$self}sub parse_string_document {my$this=shift;$this->set_source(\ $_[0]);$this->run}sub parse_file {my($this,$filename)=@_;$this->set_source($filename);$this->run}sub run {use Carp ();if(__PACKAGE__ eq ref($_[0])|| $_[0]){Carp::croak "You can call run() only on subclasses of " .__PACKAGE__}else {Carp::croak join '',"You can't call run() because ",ref($_[0])|| $_[0]," didn't define a run() method"}}sub parse_lines {use Carp ();Carp::croak "Use set_source with ",__PACKAGE__," and subclasses, not parse_lines"}sub parse_line {use Carp ();Carp::croak "Use set_source with ",__PACKAGE__," and subclasses, not parse_line"}sub new {my$class=shift;my$self=$class->SUPER::new(@_);die "Couldn't construct for $class" unless$self;$self->{'token_buffer'}||= [];$self->{'start_token_class'}||= 'Pod::Simple::PullParserStartToken';$self->{'text_token_class'}||= 'Pod::Simple::PullParserTextToken';$self->{'end_token_class'}||= 'Pod::Simple::PullParserEndToken';DEBUG > 1 and print STDERR "New pullparser object: $self\n";return$self}sub get_token {my$self=shift;DEBUG > 1 and print STDERR "\nget_token starting up on $self.\n";DEBUG > 2 and print STDERR " Items in token-buffer (",scalar(@{$self->{'token_buffer'}}),") :\n",map("    " .$_->dump ."\n",@{$self->{'token_buffer'}}),@{$self->{'token_buffer'}}? '' : '       (no tokens)',"\n" ;until(@{$self->{'token_buffer'}}){DEBUG > 3 and print STDERR "I need to get something into my empty token buffer...\n";if($self->{'source_dead'}){DEBUG and print STDERR "$self 's source is dead.\n";push @{$self->{'token_buffer'}},undef}elsif(exists$self->{'source_fh'}){my@lines;my$fh=$self->{'source_fh'}|| Carp::croak('You have to call set_source before you can call get_token');DEBUG and print STDERR "$self 's source is filehandle $fh.\n";for(my$i=Pod::Simple::MANY_LINES;$i--;){DEBUG > 3 and print STDERR " Fetching a line from source filehandle $fh...\n";local $/=$Pod::Simple::NL;push@lines,scalar(<$fh>);DEBUG > 3 and print STDERR "  Line is: ",defined($lines[-1])? $lines[-1]: "<undef>\n";unless(defined$lines[-1]){DEBUG and print STDERR "That's it for that source fh!  Killing.\n";delete$self->{'source_fh'};last}}if(DEBUG > 8){print STDERR "* I've gotten ",scalar(@lines)," lines:\n";for my$l (@lines){if(defined$l){print STDERR "  line {$l}\n"}else {print STDERR "  line undef\n"}}print STDERR "* end of ",scalar(@lines)," lines\n"}$self->SUPER::parse_lines(@lines)}elsif(exists$self->{'source_arrayref'}){DEBUG and print STDERR "$self 's source is arrayref $self->{'source_arrayref'}, with ",scalar(@{$self->{'source_arrayref'}})," items left in it.\n";DEBUG > 3 and print STDERR "  Fetching ",Pod::Simple::MANY_LINES," lines.\n";$self->SUPER::parse_lines(splice @{$self->{'source_arrayref'}},0,Pod::Simple::MANY_LINES);unless(@{$self->{'source_arrayref'}}){DEBUG and print STDERR "That's it for that source arrayref!  Killing.\n";$self->SUPER::parse_lines(undef);delete$self->{'source_arrayref'}}}elsif(exists$self->{'source_scalar_ref'}){DEBUG and print STDERR "$self 's source is scalarref $self->{'source_scalar_ref'}, with ",length(${$self->{'source_scalar_ref'}})- (pos(${$self->{'source_scalar_ref'}})|| 0)," characters left to parse.\n";DEBUG > 3 and print STDERR " Fetching a line from source-string...\n";if(${$self->{'source_scalar_ref'}}=~ m/([^\n\r]*)((?:\r?\n)?)/g){$self->SUPER::parse_lines($1)if length($1)or length($2)or pos(${$self->{'source_scalar_ref'}})!=length(${$self->{'source_scalar_ref'}})}else {$self->SUPER::parse_lines(undef);delete$self->{'source_scalar_ref'};DEBUG and print STDERR "That's it for that source scalarref!  Killing.\n"}}else {die "What source??"}}DEBUG and print STDERR "get_token about to return ",Pod::Simple::pretty(@{$self->{'token_buffer'}}? $self->{'token_buffer'}[-1]: undef),"\n";return shift @{$self->{'token_buffer'}}}sub unget_token {my$self=shift;DEBUG and print STDERR "Ungetting ",scalar(@_)," tokens: ",@_ ? "@_\n" : "().\n";for my$t (@_){Carp::croak "Can't unget that, because it's not a token -- it's undef!" unless defined$t;Carp::croak "Can't unget $t, because it's not a token -- it's a string!" unless ref$t;Carp::croak "Can't unget $t, because it's not a token object!" unless UNIVERSAL::can($t,'type')}unshift @{$self->{'token_buffer'}},@_;DEBUG > 1 and print STDERR "Token buffer now has ",scalar(@{$self->{'token_buffer'}})," items in it.\n";return}sub set_source {my$self=shift @_;return$self->{'source_fh'}unless @_;Carp::croak("Cannot assign new source to pull parser; create a new instance, instead")if$self->{'source_fh'}|| $self->{'source_scalar_ref'}|| $self->{'source_arrayref'};my$handle;if(!defined $_[0]){Carp::croak("Can't use empty-string as a source for set_source")}elsif(ref(\($_[0]))eq 'GLOB'){$self->{'source_filename'}='' .($handle=$_[0]);DEBUG and print STDERR "$self 's source is glob $_[0]\n"}elsif(ref($_[0])eq 'SCALAR'){$self->{'source_scalar_ref'}=$_[0];DEBUG and print STDERR "$self 's source is scalar ref $_[0]\n";return}elsif(ref($_[0])eq 'ARRAY'){$self->{'source_arrayref'}=$_[0];DEBUG and print STDERR "$self 's source is array ref $_[0]\n";return}elsif(ref $_[0]){$self->{'source_filename'}='' .($handle=$_[0]);DEBUG and print STDERR "$self 's source is fh-obj $_[0]\n"}elsif(!length $_[0]){Carp::croak("Can't use empty-string as a source for set_source")}else {DEBUG and print STDERR "$self 's source is filename $_[0]\n";{local*PODSOURCE;open(PODSOURCE,"<$_[0]")|| Carp::croak "Can't open $_[0]: $!";$handle=*PODSOURCE{IO}}$self->{'source_filename'}=$_[0];DEBUG and print STDERR "  Its name is $_[0].\n"}$self->{'source_fh'}=$handle;DEBUG and print STDERR "  Its handle is $handle\n";return 1}sub get_title_short {shift->get_short_title(@_)}sub get_short_title {my$title=shift->get_title(@_);$title=$1 if$title =~ m/^(\S{1,60})\s+--?\s+./s;return$title}sub get_title {shift->_get_titled_section('NAME',max_token=>50,desperate=>1,@_)}sub get_version {shift->_get_titled_section('VERSION',max_token=>400,accept_verbatim=>1,max_content_length=>3_000,@_,)}sub get_description {shift->_get_titled_section('DESCRIPTION',max_token=>400,max_content_length=>3_000,@_,)}sub get_authors {shift->get_author(@_)}sub get_author {my$this=shift;$this->_get_titled_section('AUTHOR',max_token=>10_000,@_)|| $this->_get_titled_section('AUTHORS',max_token=>10_000,@_)}sub _get_titled_section {my($self,$titlename,%options)=(@_);my$max_token=delete$options{'max_token'};my$desperate_for_title=delete$options{'desperate'};my$accept_verbatim=delete$options{'accept_verbatim'};my$max_content_length=delete$options{'max_content_length'};my$nocase=delete$options{'nocase'};$max_content_length=120 unless defined$max_content_length;Carp::croak("Unknown " .((1==keys%options)? "option: " : "options: ").join " ",map "[$_]",sort keys%options)if keys%options;my%content_containers;$content_containers{'Para'}=1;if($accept_verbatim){$content_containers{'Verbatim'}=1;$content_containers{'VerbatimFormatted'}=1}my$token_count=0;my$title;my@to_unget;my$state=0;my$depth=0;Carp::croak "What kind of titlename is \"$titlename\"?!" unless defined$titlename and $titlename =~ m/^[A-Z ]{1,60}$/s;my$titlename_re=quotemeta($titlename);my$head1_text_content;my$para_text_content;my$skipX;while(++$token_count <= ($max_token || 1_000_000)and defined(my$token=$self->get_token)){push@to_unget,$token;if ($state==0){if($token->is_start and $token->tagname eq 'head1'){DEBUG and print STDERR "  Found head1.  Seeking content...\n";++$state;$head1_text_content=''}}elsif($state==1){if($token->is_text){unless ($skipX){DEBUG and print STDERR "   Adding \"",$token->text,"\" to head1-content.\n";$head1_text_content .= $token->text}}elsif($token->is_tagname('X')){$skipX=$token->is_start;DEBUG and print STDERR +($skipX ? 'Start' : 'End'),'ing ignoring of X<> tag'}elsif($token->is_end and $token->tagname eq 'head1'){DEBUG and print STDERR "  Found end of head1.  Considering content...\n";$head1_text_content=uc$head1_text_content if$nocase;if($head1_text_content eq $titlename or $head1_text_content =~ m/\($titlename_re\)/s){DEBUG and print STDERR "  Yup, it was $titlename.  Seeking next para-content...\n";++$state}elsif($desperate_for_title and $head1_text_content =~ m/\S/ and $head1_text_content !~ m/^[ A-Z]+$/s and $head1_text_content !~ m/\((?:
               NAME | TITLE | VERSION | AUTHORS? | DESCRIPTION | SYNOPSIS
               | COPYRIGHT | LICENSE | NOTES? | FUNCTIONS? | METHODS?
               | CAVEATS? | BUGS? | SEE\ ALSO | SWITCHES | ENVIRONMENT
              )\)/sx and ($max_content_length ? (length($head1_text_content)<= $max_content_length): 1)){($title=$head1_text_content)=~ s/\s+$//;DEBUG and print STDERR "  It looks titular: \"$title\".\n\n  Using that.\n";last}else {--$state;DEBUG and print STDERR "  Didn't look titular ($head1_text_content).\n","\n  Dropping back to seeking-head1-content mode...\n"}}}elsif($state==2){if($token->is_start and $content_containers{$token->tagname }){DEBUG and print STDERR "  Found start of Para.  Accumulating content...\n";$para_text_content='';++$state}else {DEBUG and print "  Didn't see an immediately subsequent start-Para.  Reseeking H1\n";$state=0}}elsif($state==3){if($token->is_text){DEBUG and print STDERR "   Adding \"",$token->text,"\" to para-content.\n";$para_text_content .= $token->text}elsif($token->is_end and $content_containers{$token->tagname }){DEBUG and print STDERR "  Found end of Para.  Considering content: ",$para_text_content,"\n";if($para_text_content =~ m/\S/ and ($max_content_length ? (length($para_text_content)<= $max_content_length): 1)){DEBUG and print STDERR "  It looks contentworthy, I guess.  Using it.\n";$title=$para_text_content;last}else {DEBUG and print STDERR "  Doesn't look at all contentworthy!\n  Giving up.\n";undef$title;last}}}else {die "IMPOSSIBLE STATE $state!\n"}}$self->unget_token(@to_unget);if(DEBUG){if(defined$title){print STDERR "  Returning title <$title>\n"}else {print STDERR "Returning title <>\n"}}return '' unless defined$title;$title =~ s/^\s+//;return$title}sub _handle_element_start {my$self=shift;DEBUG > 2 and print STDERR "++ $_[0] (",map("<$_> ",%{$_[1]}),")\n";push @{$self->{'token_buffer'}},$self->{'start_token_class'}->new(@_);return}sub _handle_text {my$self=shift;DEBUG > 2 and print STDERR "== $_[0]\n";push @{$self->{'token_buffer'}},$self->{'text_token_class'}->new(@_);return}sub _handle_element_end {my$self=shift;DEBUG > 2 and print STDERR "-- $_[0]\n";push @{$self->{'token_buffer'}},$self->{'end_token_class'}->new(@_);return}1;
POD_SIMPLE_PULLPARSER

$fatpacked{"Pod/Simple/PullParserEndToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERENDTOKEN';
  require 5;package Pod::Simple::PullParserEndToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.35';sub new {my$class=shift;return bless ['end',@_],ref($class)|| $class}sub tagname {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub tag {shift->tagname(@_)}sub is_tagname {$_[0][1]eq $_[1]}sub is_tag {shift->is_tagname(@_)}1;
POD_SIMPLE_PULLPARSERENDTOKEN

$fatpacked{"Pod/Simple/PullParserStartToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERSTARTTOKEN';
  require 5;package Pod::Simple::PullParserStartToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.35';sub new {my$class=shift;return bless ['start',@_],ref($class)|| $class}sub tagname {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub tag {shift->tagname(@_)}sub is_tagname {$_[0][1]eq $_[1]}sub is_tag {shift->is_tagname(@_)}sub attr_hash {$_[0][2]||= {}}sub attr {if(@_==2){${$_[0][2]|| return undef}{$_[1]}}elsif(@_ > 2){${$_[0][2]||= {}}{$_[1]}=$_[2]}else {require Carp;Carp::croak('usage: $object->attr("val") or $object->attr("key", "newval")');return undef}}1;
POD_SIMPLE_PULLPARSERSTARTTOKEN

$fatpacked{"Pod/Simple/PullParserTextToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTEXTTOKEN';
  require 5;package Pod::Simple::PullParserTextToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.35';sub new {my$class=shift;return bless ['text',@_],ref($class)|| $class}sub text {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub text_r {\ $_[0][1]}1;
POD_SIMPLE_PULLPARSERTEXTTOKEN

$fatpacked{"Pod/Simple/PullParserToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTOKEN';
  require 5;package Pod::Simple::PullParserToken;@ISA=();$VERSION='3.35';use strict;sub new {my$class=shift;return bless [@_],ref($class)|| $class}sub type {$_[0][0]}sub dump {Pod::Simple::pretty([@{$_[0]}])}sub is_start {$_[0][0]eq 'start'}sub is_end {$_[0][0]eq 'end'}sub is_text {$_[0][0]eq 'text'}1;
POD_SIMPLE_PULLPARSERTOKEN

$fatpacked{"Pod/Simple/RTF.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_RTF';
  require 5;package Pod::Simple::RTF;use strict;use vars qw($VERSION @ISA %Escape $WRAP %Tagmap);$VERSION='3.35';use Pod::Simple::PullParser ();BEGIN {@ISA=('Pod::Simple::PullParser')}use Carp ();BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}$WRAP=1 unless defined$WRAP;my$cntrl='[:cntrl:]';$cntrl='\x00-\x1F\x7F' unless eval "qr/[$cntrl]/";my$not_ascii='[:^ascii:]';$not_ascii='\x80-\xFF' unless eval "qr/[$not_ascii]/";sub _openclose {return map {;m/^([-A-Za-z]+)=(\w[^\=]*)$/s or die "what's <$_>?";($1,"{\\$2\n","/$1","}")}@_}my@_to_accept;%Tagmap=(_openclose('B=cs18\b','I=cs16\i','C=cs19\f1\lang1024\noproof','F=cs17\i\lang1024\noproof','VerbatimI=cs26\i','VerbatimB=cs27\b','VerbatimBI=cs28\b\i',map {;m/^([-a-z]+)/s && push@_to_accept,$1;$_}qw[underline=ul smallcaps=scaps shadow=shad superscript=super subscript=sub strikethrough=strike outline=outl emboss=embo engrave=impr dotted-underline=uld dash-underline=uldash dot-dash-underline=uldashd dot-dot-dash-underline=uldashdd double-underline=uldb thick-underline=ulth word-underline=ulw wave-underline=ulwave]),'L=pod'=>'{\cs22\i'."\n",'L=url'=>'{\cs23\i'."\n",'L=man'=>'{\cs24\i'."\n",'/L'=>'}','Data'=>"\n",'/Data'=>"\n",'Verbatim'=>"\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",'/Verbatim'=>"\n\\par}\n",'VerbatimFormatted'=>"\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",'/VerbatimFormatted'=>"\n\\par}\n",'Para'=>"\n{\\pard\\li#rtfindent#\\sa180\n",'/Para'=>"\n\\par}\n",'head1'=>"\n{\\pard\\li#rtfindent#\\s31\\keepn\\sb90\\sa180\\f2\\fs#head1_halfpoint_size#\\ul{\n",'/head1'=>"\n}\\par}\n",'head2'=>"\n{\\pard\\li#rtfindent#\\s32\\keepn\\sb90\\sa180\\f2\\fs#head2_halfpoint_size#\\ul{\n",'/head2'=>"\n}\\par}\n",'head3'=>"\n{\\pard\\li#rtfindent#\\s33\\keepn\\sb90\\sa180\\f2\\fs#head3_halfpoint_size#\\ul{\n",'/head3'=>"\n}\\par}\n",'head4'=>"\n{\\pard\\li#rtfindent#\\s34\\keepn\\sb90\\sa180\\f2\\fs#head4_halfpoint_size#\\ul{\n",'/head4'=>"\n}\\par}\n",'item-bullet'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-bullet'=>"\n\\par}\n",'item-number'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-number'=>"\n\\par}\n",'item-text'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-text'=>"\n\\par}\n",);sub new {my$new=shift->SUPER::new(@_);$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->accept_targets('rtf','RTF');$new->{'Tagmap'}={%Tagmap};$new->accept_codes(@_to_accept);$new->accept_codes('VerbatimFormatted');DEBUG > 2 and print STDERR "To accept: ",join(' ',@_to_accept),"\n";$new->doc_lang(($ENV{'RTFDEFLANG'}|| '')=~ m/^(\d{1,10})$/s ? $1 : ($ENV{'RTFDEFLANG'}|| '')=~ m/^0?x([a-fA-F0-9]{1,10})$/s ? hex($1): ($ENV{'RTFDEFLANG'}|| '')=~ m/^([a-fA-F0-9]{4})$/s ? hex($1): '1033');$new->head1_halfpoint_size(32);$new->head2_halfpoint_size(28);$new->head3_halfpoint_size(25);$new->head4_halfpoint_size(22);$new->codeblock_halfpoint_size(18);$new->header_halfpoint_size(17);$new->normal_halfpoint_size(25);return$new}__PACKAGE__->_accessorize('doc_lang','head1_halfpoint_size','head2_halfpoint_size','head3_halfpoint_size','head4_halfpoint_size','codeblock_halfpoint_size','header_halfpoint_size','normal_halfpoint_size','no_proofing_exemptions',);sub run {my$self=$_[0];return$self->do_middle if$self->bare_output;return $self->do_beginning && $self->do_middle && $self->do_end}sub do_middle {my$self=$_[0];my$fh=$self->{'output_fh'};my($token,$type,$tagname,$scratch);my@stack;my@indent_stack;$self->{'rtfindent'}=0 unless defined$self->{'rtfindent'};while($token=$self->get_token){if(($type=$token->type)eq 'text'){if($self->{'rtfverbatim'}){DEBUG > 1 and print STDERR "  $type ",$token->text," in verbatim!\n";rtf_esc_codely($scratch=$token->text);print$fh $scratch;next}DEBUG > 1 and print STDERR "  $type ",$token->text,"\n";$scratch=$token->text;$scratch =~ tr/\t\cb\cc/ /d;$self->{'no_proofing_exemptions'}or $scratch =~ s/(?:
             ^
             |
             (?<=[\r\n\t "\[\<\(])
           )   # start on whitespace, sequence-start, or quote
           ( # something looking like a Perl token:
            (?:
             [\$\@\:\<\*\\_]\S+  # either starting with a sigil, etc.
            )
            |
            # or starting alpha, but containing anything strange:
            (?:
             [a-zA-Z'${not_ascii}]+[\$\@\:_<>\(\\\*]\S+
            )
           )
          /\cb$1\cc/xsg ;rtf_esc($scratch);$scratch =~ s/(
              [^\r\n]{65}        # Snare 65 characters from a line
              [^\r\n ]{0,50}     #  and finish any current word
             )
             (\ {1,10})(?![\r\n]) # capture some spaces not at line-end
            /$1$2\n/gx if$WRAP;print$fh $scratch}elsif($type eq 'start'){DEBUG > 1 and print STDERR "  +$type ",$token->tagname," (",map("<$_> ",%{$token->attr_hash}),")\n";if(($tagname=$token->tagname)eq 'Verbatim' or $tagname eq 'VerbatimFormatted'){++$self->{'rtfverbatim'};my$next=$self->get_token;next unless defined$next;my$line_count=1;if($next->type eq 'text'){my$t=$next->text_r;while($$t =~ m/$/mg){last if ++$line_count > 15}DEBUG > 3 and print STDERR "    verbatim line count: $line_count\n"}$self->unget_token($next);$self->{'rtfkeep'}=($line_count > 15)? '' : '\keepn' }elsif($tagname =~ m/^item-/s){my@to_unget;my$text_count_here=0;$self->{'rtfitemkeepn'}='';while(1){push@to_unget,$self->get_token;pop(@to_unget),last unless defined$to_unget[-1];if($to_unget[-1]->type eq 'text'){if(($text_count_here += length ${$to_unget[-1]->text_r})> 150){DEBUG > 1 and print STDERR "    item-* is too long to be keepn'd.\n";last}}elsif (@to_unget > 1 and $to_unget[-2]->type eq 'end' and $to_unget[-2]->tagname =~ m/^item-/s){$self->{'rtfitemkeepn'}='\keepn' if $to_unget[-1]->type eq 'start' and $to_unget[-1]->tagname eq 'Para';DEBUG > 1 and printf STDERR "    item-* before %s(%s) %s keepn'd.\n",$to_unget[-1]->type,$to_unget[-1]->can('tagname')? $to_unget[-1]->tagname : '',$self->{'rtfitemkeepn'}? "gets" : "doesn't get";last}elsif (@to_unget > 40){DEBUG > 1 and print STDERR "    item-* now has too many tokens (",scalar(@to_unget),(DEBUG > 4)? (q<: >,map($_->dump,@to_unget)): (),") to be keepn'd.\n";last}}$self->unget_token(@to_unget)}elsif($tagname =~ m/^over-/s){push@stack,$1;push@indent_stack,int($token->attr('indent')* 4 * $self->normal_halfpoint_size);DEBUG and print STDERR "Indenting over $indent_stack[-1] twips.\n";$self->{'rtfindent'}+= $indent_stack[-1]}elsif ($tagname eq 'L'){$tagname .= '=' .($token->attr('type')|| 'pod')}elsif ($tagname eq 'Data'){my$next=$self->get_token;next unless defined$next;unless($next->type eq 'text'){$self->unget_token($next);next}DEBUG and print STDERR "    raw text ",$next->text,"\n";printf$fh "\n" .$next->text ."\n";next}defined($scratch=$self->{'Tagmap'}{$tagname})or next;$scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g;print$fh $scratch;if ($tagname eq 'item-number'){print$fh $token->attr('number'),". \n"}elsif ($tagname eq 'item-bullet'){print$fh "\\'",ord("_"),"\n"}}elsif($type eq 'end'){DEBUG > 1 and print STDERR "  -$type ",$token->tagname,"\n";if(($tagname=$token->tagname)=~ m/^over-/s){DEBUG and print STDERR "Indenting back $indent_stack[-1] twips.\n";$self->{'rtfindent'}-= pop@indent_stack;pop@stack}elsif($tagname eq 'Verbatim' or $tagname eq 'VerbatimFormatted'){--$self->{'rtfverbatim'}}defined($scratch=$self->{'Tagmap'}{"/$tagname"})or next;$scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g;print$fh $scratch}}return 1}sub do_beginning {my$self=$_[0];my$fh=$self->{'output_fh'};return print$fh join '',$self->doc_init,$self->font_table,$self->stylesheet,$self->color_table,$self->doc_info,$self->doc_start,"\n" }sub do_end {my$self=$_[0];my$fh=$self->{'output_fh'};return print$fh '}'}sub stylesheet {return sprintf <<'END',$_[0]->codeblock_halfpoint_size(),$_[0]->head1_halfpoint_size(),$_[0]->head2_halfpoint_size(),$_[0]->head3_halfpoint_size(),$_[0]->head4_halfpoint_size(),}sub font_table {return <<'END'}sub doc_init {return <<'END'}sub color_table {return <<'END'}sub doc_info {my$self=$_[0];my$class=ref($self)|| $self;my$tag=__PACKAGE__ .' ' .$VERSION;unless($class eq __PACKAGE__){$tag=" ($tag)";$tag=" v" .$self->VERSION .$tag if defined$self->VERSION;$tag=$class .$tag}return sprintf <<'END',$tag,$ISA[0],$ISA[0]->VERSION(),$],scalar(gmtime),}sub doc_start {my$self=$_[0];my$title=$self->get_short_title();DEBUG and print STDERR "Short Title: <$title>\n";$title .= ' ' if length$title;$title =~ s/ *$/ /s;$title =~ s/^ //s;$title =~ s/ $/, /s;my$is_obviously_module_name;$is_obviously_module_name=1 if$title =~ m/^\S+$/s and $title =~ m/::/s;DEBUG and print STDERR "Title0: <$title>\n";$title=rtf_esc($title);DEBUG and print STDERR "Title1: <$title>\n";$title='\lang1024\noproof ' .$title if$is_obviously_module_name;return sprintf <<'END',($self->doc_lang)x 2,$self->header_halfpoint_size,$title,$self->normal_halfpoint_size,}use integer;sub rtf_esc {my$x;if(!defined wantarray){for(@_){s/([F${cntrl}\-\\\{\}${not_ascii}])/$Escape{$1}/g;s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg}return}elsif(wantarray){return map {;($x=$_)=~ s/([F${cntrl}\-\\\{\}${not_ascii}])/$Escape{$1}/g;$x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;$x}@_}else {($x=((@_==1)? $_[0]: join '',@_))=~ s/([F${cntrl}\-\\\{\}${not_ascii}])/$Escape{$1}/g;$x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;return$x}}sub rtf_esc_codely {my$x;if(!defined wantarray){for(@_){s/([F${cntrl}\\\{\}${not_ascii}])/$Escape{$1}/g;s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg}return}elsif(wantarray){return map {;($x=$_)=~ s/([F${cntrl}\\\{\}${not_ascii}])/$Escape{$1}/g;$x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;$x}@_}else {($x=((@_==1)? $_[0]: join '',@_))=~ s/([F${cntrl}\\\{\}${not_ascii}])/$Escape{$1}/g;$x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;return$x}}%Escape=((($] lt 5.007_003)? (map((chr($_),chr($_)),0x20 .. 0x7E),map((chr($_),sprintf("\\'%02x",$_)),0x00 .. 0x1F,0x5c,0x7b,0x7d,0x7f .. 0xFF,0x46)): (map((chr(utf8::unicode_to_native($_)),chr(utf8::unicode_to_native($_))),0x20 .. 0x7E),map((chr($_),sprintf("\\'%02x",utf8::unicode_to_native($_))),0x00 .. 0x1F,0x5c,0x7b,0x7d,0x7f .. 0xFF,0x46))),"\r"=>"\n","\cj"=>"\n","\n"=>"\n\\line ","\t"=>"\\tab ","\f"=>"\n\\page\n","-"=>"\\_",$Pod::Simple::nbsp=>"\\~",$Pod::Simple::shy=>"\\-","\n"=>"\\line\n","\r"=>"\n","\cb"=>"{\n\\cs21\\lang1024\\noproof ","\cc"=>"}",);1;
  {\stylesheet
  {\snext0 Normal;}
  {\*\cs10 \additive Default Paragraph Font;}
  {\*\cs16 \additive \i \sbasedon10 pod-I;}
  {\*\cs17 \additive \i\lang1024\noproof \sbasedon10 pod-F;}
  {\*\cs18 \additive \b \sbasedon10 pod-B;}
  {\*\cs19 \additive \f1\lang1024\noproof\sbasedon10 pod-C;}
  {\s20\ql \li0\ri0\sa180\widctlpar\f1\fs%s\lang1024\noproof\sbasedon0 \snext0 pod-codeblock;}
  {\*\cs21 \additive \lang1024\noproof \sbasedon10 pod-computerese;}
  {\*\cs22 \additive \i\lang1024\noproof\sbasedon10 pod-L-pod;}
  {\*\cs23 \additive \i\lang1024\noproof\sbasedon10 pod-L-url;}
  {\*\cs24 \additive \i\lang1024\noproof\sbasedon10 pod-L-man;}
  
  {\*\cs25 \additive \f1\lang1024\noproof\sbasedon0 pod-codelbock-plain;}
  {\*\cs26 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-ital;}
  {\*\cs27 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold;}
  {\*\cs28 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold-ital;}
  
  {\s31\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head1;}
  {\s32\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head2;}
  {\s33\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head3;}
  {\s34\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head4;}
  }
  
  END
  {\fonttbl
  {\f0\froman Times New Roman;}
  {\f1\fmodern Courier New;}
  {\f2\fswiss Arial;}
  }
  
  END
  {\rtf1\ansi\deff0
  
  END
  {\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
  END
  {\info{\doccomm
  %s
   using %s v%s
   under Perl v%s at %s GMT}
  {\author [see doc]}{\company [see doc]}{\operator [see doc]}
  }
  
  END
  \deflang%s\plain\lang%s\widowctrl
  {\header\pard\qr\plain\f2\fs%s
  %s
  p.\chpgn\par}
  \fs%s
  
  END
POD_SIMPLE_RTF

$fatpacked{"Pod/Simple/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SEARCH';
  require 5.005;package Pod::Simple::Search;use strict;use vars qw($VERSION $MAX_VERSION_WITHIN $SLEEPY);$VERSION='3.35';BEGIN {*DEBUG=sub () {0}unless defined&DEBUG}use Carp ();$SLEEPY=1 if!defined$SLEEPY and $^O =~ /mswin|mac/i;$MAX_VERSION_WITHIN ||= 60;my$IS_CASE_INSENSITIVE=-e uc __FILE__ && -e lc __FILE__;use File::Spec ();use File::Basename qw(basename dirname);use Config ();use Cwd qw(cwd);__PACKAGE__->_accessorize('callback','progress','dir_prefix','inc','laborious','limit_glob','limit_re','shadows','verbose','name2path','path2name','recurse','ciseen');sub new {my$class=shift;my$self=bless {},ref($class)|| $class;$self->init;return$self}sub init {my$self=shift;$self->inc(1);$self->recurse(1);$self->verbose(DEBUG);return$self}sub survey {my($self,@search_dirs)=@_;$self=$self->new unless ref$self;$self->_expand_inc(\@search_dirs);$self->{'_scan_count'}=0;$self->{'_dirs_visited'}={};$self->path2name({});$self->name2path({});$self->ciseen({});$self->limit_re($self->_limit_glob_to_limit_re)if$self->{'limit_glob'};my$cwd=cwd();my$verbose=$self->verbose;local $_;for my$try (@search_dirs){unless(File::Spec->file_name_is_absolute($try)){$try=File::Spec->catfile($cwd,$try)}$try=File::Spec->canonpath($try);my$start_in;my$modname_prefix;if($self->{'dir_prefix'}){$start_in=File::Spec->catdir($try,grep length($_),split '[\\/:]+',$self->{'dir_prefix'});$modname_prefix=[grep length($_),split m{[:/\\]},$self->{'dir_prefix'}];$verbose and print "Appending \"$self->{'dir_prefix'}\" to $try, ","giving $start_in (= @$modname_prefix)\n"}else {$start_in=$try}if($self->{'_dirs_visited'}{$start_in}){$verbose and print "Directory '$start_in' already seen, skipping.\n";next}else {$self->{'_dirs_visited'}{$start_in}=1}unless(-e $start_in){$verbose and print "Skipping non-existent $start_in\n";next}my$closure=$self->_make_search_callback;if(-d $start_in){$verbose and print "Beginning excursion under $start_in\n";$self->_recurse_dir($start_in,$closure,$modname_prefix);$verbose and print "Back from excursion under $start_in\n\n"}elsif(-f _){$_=basename($start_in);$verbose and print "Pondering $start_in ($_)\n";$closure->($start_in,$_,0,[])}else {$verbose and print "Skipping mysterious $start_in\n"}}$self->progress and $self->progress->done("Noted $$self{'_scan_count'} Pod files total");$self->ciseen({});return unless defined wantarray;return$self->name2path unless wantarray;return$self->name2path,$self->path2name}sub _make_search_callback {my$self=$_[0];my($laborious,$verbose,$shadows,$limit_re,$callback,$progress,$path2name,$name2path,$recurse,$ciseen)=map scalar($self->$_()),qw(laborious verbose shadows limit_re callback progress path2name name2path recurse ciseen);my ($seen,$remember,$files_for);if ($IS_CASE_INSENSITIVE){$seen=sub {$ciseen->{lc $_[0]}};$remember=sub {$name2path->{$_[0]}=$ciseen->{lc $_[0]}=$_[1]};$files_for=sub {my$n=lc $_[0];grep {lc$path2name->{$_}eq $n}%{$path2name}}}else {$seen=sub {$name2path->{$_[0]}};$remember=sub {$name2path->{$_[0]}=$_[1]};$files_for=sub {my$n=$_[0];grep {$path2name->{$_}eq $n}%{$path2name}}}my($file,$shortname,$isdir,$modname_bits);return sub {($file,$shortname,$isdir,$modname_bits)=@_;if($isdir){unless($recurse){$verbose and print "Not recursing into '$file' as per requested.\n";return 'PRUNE'}if($self->{'_dirs_visited'}{$file}){$verbose and print "Directory '$file' already seen, skipping.\n";return 'PRUNE'}print "Looking in dir $file\n" if$verbose;unless ($laborious){if(m/^(\d+\.[\d_]{3,})\z/s and do {my$x=$1;$x =~ tr/_//d;$x!=$]}){$verbose and print "Perl $] version mismatch on $_, skipping.\n";return 'PRUNE'}if(m/^([A-Za-z][a-zA-Z0-9_]*)\z/s){$verbose and print "$_ is a well-named module subdir.  Looking....\n"}else {$verbose and print "$_ is a fishy directory name.  Skipping.\n";return 'PRUNE'}}$self->{'_dirs_visited'}{$file}=1;return}if($laborious){unless(m/\.(pod|pm|plx?)\z/i || -x _ and -T _){$verbose > 1 and print " Brushing off uninteresting $file\n";return}}else {unless(m/^[-_a-zA-Z0-9]+\.(?:pod|pm|plx?)\z/is){$verbose > 1 and print " Brushing off oddly-named $file\n";return}}$verbose and print "Considering item $file\n";my$name=$self->_path2modname($file,$shortname,$modname_bits);$verbose > 0.01 and print " Nominating $file as $name\n";if($limit_re and $name !~ m/$limit_re/i){$verbose and print "Shunning $name as not matching $limit_re\n";return}if(!$shadows and $seen->($name)){$verbose and print "Not worth considering $file ","-- already saw $name as ",join(' ',$files_for->($name)),"\n";return}$progress and $progress->reach($self->{'_scan_count'},"Scanning $file");return unless$self->contains_pod($file);++ $self->{'_scan_count'};if (my$prev=$seen->($name)){$verbose and print "Duplicate POD found (shadowing?): $name ($file)\n","    Already seen in ",join(' ',$files_for->($name)),"\n"}else {$remember->($name,$file)}$verbose and print "  Noting $name = $file\n";if($callback){local $_=$_;$callback->($file,$name)}$path2name->{$file}=$name;return}}sub _path2modname {my($self,$file,$shortname,$modname_bits)=@_;my@m=@$modname_bits;my$x;my$verbose=$self->verbose;while(@m and defined($x=lc($m[0]))and($x eq 'site_perl' or($x eq 'pod' and @m==1 and $shortname =~ m{^perl.*\.pod$}s)or $x =~ m{\\d+\\.z\\d+([_.]?\\d+)?} or $x eq lc($Config::Config{'archname'}))){shift@m}my$name=join '::',@m,$shortname;$self->_simplify_base($name);if ($^O eq 'VMS' && ($name eq lc($name)|| $name eq uc($name))){open PODFILE,"<$file" or die "_path2modname: Can't open $file: $!";my$in_pod=0;my$in_name=0;my$line;while ($line=<PODFILE>){chomp$line;$in_pod=1 if ($line =~ m/^=\w/);$in_pod=0 if ($line =~ m/^=cut/);next unless$in_pod;next if ($line =~ m/^\s*\z/);next if ($in_pod && ($line =~ m/^X</));if ($in_name){if ($line =~ m/(\w+::)?(\w+)/){my$podname=$2;my$prefix=$1 || '';$verbose and print "Attempting case restore of '$name' from '$prefix$podname'\n";unless ($name =~ s/$prefix$podname/$prefix$podname/i){$verbose and print "Attempting case restore of '$name' from '$podname'\n";$name =~ s/$podname/$podname/i}last}}$in_name=1 if ($line =~ m/^=head1 NAME/)}close PODFILE}return$name}sub _recurse_dir {my($self,$startdir,$callback,$modname_bits)=@_;my$maxdepth=$self->{'fs_recursion_maxdepth'}|| 10;my$verbose=$self->verbose;my$here_string=File::Spec->curdir;my$up_string=File::Spec->updir;$modname_bits ||= [];my$recursor;$recursor=sub {my($dir_long,$dir_bare)=@_;if(@$modname_bits >= 10){$verbose and print "Too deep! [@$modname_bits]\n";return}unless(-d $dir_long){$verbose > 2 and print "But it's not a dir! $dir_long\n";return}unless(opendir(INDIR,$dir_long)){$verbose > 2 and print "Can't opendir $dir_long : $!\n";closedir(INDIR);return}my@items=map {$_->[0]}sort {$a->[1]cmp $b->[1]|| $b->[2]cmp $a->[2]}map {(my$t=$_)=~ s/[.]p(m|lx?|od)\z//;[$_,$t,lc($1 || 'z')]}readdir(INDIR);closedir(INDIR);push @$modname_bits,$dir_bare unless$dir_bare eq '';my$i_full;for my$i (@items){next if$i eq $here_string or $i eq $up_string or $i eq '';$i_full=File::Spec->catfile($dir_long,$i);if(!-r $i_full){$verbose and print "Skipping unreadable $i_full\n"}elsif(-f $i_full){$_=$i;$callback->($i_full,$i,0,$modname_bits)}elsif(-d _){$i =~ s/\.DIR\z//i if $^O eq 'VMS';$_=$i;my$rv=$callback->($i_full,$i,1,$modname_bits)|| '';if($rv eq 'PRUNE'){$verbose > 1 and print "OK, pruning"}else {$recursor->(File::Spec->catdir($dir_long,$i),$i)}}else {$verbose > 1 and print "Skipping oddity $i_full\n"}}pop @$modname_bits;return};;local $_;$recursor->($startdir,'');undef$recursor;return}sub run {my$self=__PACKAGE__->new;$self->limit_glob($ARGV[0])if@ARGV;$self->callback(sub {my($file,$name)=@_;my$version='';if($file =~ m/\.pod$/i){DEBUG and print "Not looking for \$VERSION in .pod $file\n"}elsif(!open(INPOD,$file)){DEBUG and print "Couldn't open $file: $!\n";close(INPOD)}else {my$lines=0;while(<INPOD>){last if$lines++ > $MAX_VERSION_WITHIN;if(s/^\s*\$VERSION\s*=\s*//s and m/\d/){DEBUG and print "Found version line (#$lines): $_";s/\s*\#.*//s;s/\;\s*$//s;s/\s+$//s;s/\t+/ /s;$_="v$1" if m{^v?["']?([0-9_]+(\.[0-9_]+)*)["']?$}s or m{\$Revision:\s*([0-9_]+(?:\.[0-9_]+)*)\s*\$}s ;$_=sprintf("v%d.%s",map {s/_//g;$_}$1 =~ m/-(\d+)_([\d_]+)/)if m{\$Name:\s*([^\$]+)\$}s ;$version=$_;DEBUG and print "Noting $version as version\n";last}}close(INPOD)}print "$name\t$version\t$file\n";return});$self->survey}sub simplify_name {my($self,$str)=@_;if ($^O eq 'MacOS'){$str =~ s{^.*:+}{}s}else {$str =~ s{^.*/+}{}s}$self->_simplify_base($str);return$str}sub _simplify_base {$_[1]=~ s/\.(pod|pm|plx?)\z//i;$_[1]=~ s/\.(bat|exe|cmd)\z//i if $^O =~ /mswin|os2/i;$_[1]=~ s/\.(com)\z//i if $^O eq 'VMS';return}sub _expand_inc {my($self,$search_dirs)=@_;return unless$self->{'inc'};my%seen=map {File::Spec->rel2abs($_)=>1}@{$search_dirs};if ($^O eq 'MacOS'){push @$search_dirs,grep {!$seen{File::Spec->rel2abs($_)}++}$self->_mac_whammy(@INC)}else {push @$search_dirs,grep {!$seen{File::Spec->rel2abs($_)}++}@INC}$self->{'laborious'}=0;return}sub _mac_whammy {my@them;(undef,@them)=@_;for $_ (@them){if ($_ eq '.'){$_=':'}elsif ($_ =~ s|^((?:\.\./)+)|':' x (length($1)/3)|e){$_=':'.$_}else {$_ =~ s|^\./|:|}}return@them}sub _limit_glob_to_limit_re {my$self=$_[0];my$limit_glob=$self->{'limit_glob'}|| return;my$limit_re='^' .quotemeta($limit_glob).'$';$limit_re =~ s/\\\?/./g;$limit_re =~ s/\\\*/.*?/g;$limit_re =~ s/\.\*\?\$$//s;$self->{'verbose'}and print "Turning limit_glob $limit_glob into re $limit_re\n";if(!exists($self->{'dir_prefix'})and $limit_glob =~ m/^(?:\w+\:\:)+/s){$self->{'dir_prefix'}=join "::",$limit_glob =~ m/^(?:\w+::)+/sg;$self->{'verbose'}and print " and setting dir_prefix to $self->{'dir_prefix'}\n"}return$limit_re}sub _actual_filenames {my$dir=shift;my$fn=lc shift;opendir my$dh,$dir or return;return map {File::Spec->catdir($dir,$_)}grep {lc $_ eq $fn}readdir$dh}sub find {my($self,$pod,@search_dirs)=@_;$self=$self->new unless ref$self;Carp::carp 'Usage: \$self->find($podname, ...)' unless defined$pod and length$pod;my$verbose=$self->verbose;my@parts=split /::/,$pod;$verbose and print "Chomping {$pod} => {@parts}\n";$self->_expand_inc(\@search_dirs);push@search_dirs,$Config::Config{'scriptdir'}if$self->inc;my%seen_dir;while (my$dir=shift@search_dirs){next unless defined$dir and length$dir;next if$seen_dir{$dir};$seen_dir{$dir}=1;unless(-d $dir){print "Directory $dir does not exist\n" if$verbose}print "Looking in directory $dir\n" if$verbose;my$fullname=File::Spec->catfile($dir,@parts);print "Filename is now $fullname\n" if$verbose;for my$ext ('','.pod','.pm','.pl'){my$fullext=$fullname .$ext;if (-f $fullext and $self->contains_pod($fullext)){print "FOUND: $fullext\n" if$verbose;if (@parts > 1 && lc$parts[0]eq 'pod' && $IS_CASE_INSENSITIVE && $ext eq '.pod'){my$subdir=dirname$fullext;unless (grep {$fullext eq $_}_actual_filenames$subdir,"$parts[-1].pod"){print "# Looking for alternate spelling in $subdir\n" if$verbose;my$pm=$fullname .'.pm';if (-f $pm and $self->contains_pod($pm)){if (grep {$pm eq $_}_actual_filenames$subdir,"$parts[-1].pm"){print "FOUND: $fullext\n" if$verbose;return$pm}}}}return$fullext}}for my$subdir (_actual_filenames($dir,'pod')){if (-d $subdir){$verbose and print "Noticing $subdir and looking there...\n";unshift@search_dirs,$subdir}}}return undef}sub contains_pod {my($self,$file)=@_;my$verbose=$self->{'verbose'};$verbose > 1 and print " Scanning $file for pod...\n";unless(open(MAYBEPOD,"<$file")){print "Error: $file is unreadable: $!\n";return undef}sleep($SLEEPY - 1)if$SLEEPY;local $_;while(<MAYBEPOD>){if(m/^=(head\d|pod|over|item)\b/s){close(MAYBEPOD)|| die "Bizarre error closing $file: $!\nAborting";chomp;$verbose > 1 and print "  Found some pod ($_) in $file\n";return 1}}close(MAYBEPOD)|| die "Bizarre error closing $file: $!\nAborting";$verbose > 1 and print "  No POD in $file, skipping.\n";return 0}sub _accessorize {shift;no strict 'refs';for my$attrname (@_){*{caller().'::' .$attrname}=sub {use strict;$Carp::CarpLevel=1,Carp::croak("Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)")unless (@_==1 or @_==2)and ref $_[0];return $_[0]->{$attrname}if @_==1;$_[0]->{$attrname}=$_[1];return $_[0]}}return}sub _state_as_string {my$self=$_[0];return '' unless ref$self;my@out="{\n  # State of $self ...\n";for my$k (sort keys %$self){push@out,"  ",_esc($k)," => ",_esc($self->{$k}),",\n"}push@out,"}\n";my$x=join '',@out;$x =~ s/^/#/mg;return$x}sub _esc {my$in=$_[0];return 'undef' unless defined$in;$in =~ s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
       <'\\x'.(unpack("H2",$1))>eg;return qq{"$in"}}run()unless caller;1;
POD_SIMPLE_SEARCH

$fatpacked{"Pod/Simple/SimpleTree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SIMPLETREE';
  require 5;package Pod::Simple::SimpleTree;use strict;use Carp ();use Pod::Simple ();use vars qw($ATTR_PAD @ISA $VERSION $SORT_ATTRS);$VERSION='3.35';BEGIN {@ISA=('Pod::Simple');*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}__PACKAGE__->_accessorize('root',);sub _handle_element_start {DEBUG > 2 and print STDERR "Handling $_[1] start-event\n";my$x=[$_[1],$_[2]];if($_[0]{'_currpos'}){push @{$_[0]{'_currpos'}[0]},$x;unshift @{$_[0]{'_currpos'}},$x}else {DEBUG and print STDERR " And oo, it gets to be root!\n";$_[0]{'_currpos'}=[$_[0]{'root'}=$x ]}DEBUG > 3 and print STDERR "Stack is now: ",join(">",map $_->[0],@{$_[0]{'_currpos'}}),"\n";return}sub _handle_element_end {DEBUG > 2 and print STDERR "Handling $_[1] end-event\n";shift @{$_[0]{'_currpos'}};DEBUG > 3 and print STDERR "Stack is now: ",join(">",map $_->[0],@{$_[0]{'_currpos'}}),"\n";return}sub _handle_text {DEBUG > 2 and print STDERR "Handling $_[1] text-event\n";push @{$_[0]{'_currpos'}[0]},$_[1];return}sub _traverse_treelet_bit {DEBUG > 2 and print STDERR "Handling $_[1] paragraph event\n";my$self=shift;push @{$self->{'_currpos'}[0]},[@_];return}1;
POD_SIMPLE_SIMPLETREE

$fatpacked{"Pod/Simple/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXT';
  require 5;package Pod::Simple::Text;use strict;use Carp ();use Pod::Simple::Methody ();use Pod::Simple ();use vars qw(@ISA $VERSION $FREAKYMODE);$VERSION='3.35';@ISA=('Pod::Simple::Methody');BEGIN {*DEBUG=defined(&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : sub() {0}}use Text::Wrap 98.112902 ();$Text::Wrap::huge='overflow';sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->accept_target_as_text(qw(text plaintext plain));$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->{'Thispara'}='';$new->{'Indent'}=0;$new->{'Indentstring'}='   ';return$new}sub handle_text {$_[0]{'Thispara'}.= $_[1]}sub start_Para {$_[0]{'Thispara'}=''}sub start_head1 {$_[0]{'Thispara'}=''}sub start_head2 {$_[0]{'Thispara'}=''}sub start_head3 {$_[0]{'Thispara'}=''}sub start_head4 {$_[0]{'Thispara'}=''}sub start_Verbatim {$_[0]{'Thispara'}=''}sub start_item_bullet {$_[0]{'Thispara'}=$FREAKYMODE ? '' : '* '}sub start_item_number {$_[0]{'Thispara'}=$FREAKYMODE ? '' : "$_[1]{'number'}. "}sub start_item_text {$_[0]{'Thispara'}=''}sub start_over_bullet {++$_[0]{'Indent'}}sub start_over_number {++$_[0]{'Indent'}}sub start_over_text {++$_[0]{'Indent'}}sub start_over_block {++$_[0]{'Indent'}}sub end_over_bullet {--$_[0]{'Indent'}}sub end_over_number {--$_[0]{'Indent'}}sub end_over_text {--$_[0]{'Indent'}}sub end_over_block {--$_[0]{'Indent'}}sub end_head1 {$_[0]->emit_par(-4)}sub end_head2 {$_[0]->emit_par(-3)}sub end_head3 {$_[0]->emit_par(-2)}sub end_head4 {$_[0]->emit_par(-1)}sub end_Para {$_[0]->emit_par(0)}sub end_item_bullet {$_[0]->emit_par(0)}sub end_item_number {$_[0]->emit_par(0)}sub end_item_text {$_[0]->emit_par(-2)}sub start_L {$_[0]{'Link'}=$_[1]if $_[1]->{type}eq 'url'}sub end_L {if (my$link=delete $_[0]{'Link'}){$_[0]{'Thispara'}.= " <$link->{to}>" unless $_[0]{'Thispara'}=~ /\b\Q$link->{to}/}}sub emit_par {my($self,$tweak_indent)=splice(@_,0,2);my$indent=' ' x (2 * $self->{'Indent'}+ 4 + ($tweak_indent||0));$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$out=Text::Wrap::wrap($indent,$indent,$self->{'Thispara'}.= "\n");$out =~ s/$Pod::Simple::nbsp/ /g;print {$self->{'output_fh'}}$out,"\n";$self->{'Thispara'}='';return}sub end_Verbatim {my$self=shift;$self->{'Thispara'}=~ s/$Pod::Simple::nbsp/ /g;$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$i=' ' x (2 * $self->{'Indent'}+ 4);$self->{'Thispara'}=~ s/^/$i/mg;print {$self->{'output_fh'}}'',$self->{'Thispara'},"\n\n" ;$self->{'Thispara'}='';return}1;
POD_SIMPLE_TEXT

$fatpacked{"Pod/Simple/TextContent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXTCONTENT';
  require 5;package Pod::Simple::TextContent;use strict;use Carp ();use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.35';@ISA=('Pod::Simple');sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->nix_X_codes(1);return$new}sub _handle_element_start {print {$_[0]{'output_fh'}}"\n" unless $_[1]=~ m/^[A-Z]$/s;return}sub _handle_text {$_[1]=~ s/$Pod::Simple::shy//g;$_[1]=~ s/$Pod::Simple::nbsp/ /g;print {$_[0]{'output_fh'}}$_[1];return}sub _handle_element_end {print {$_[0]{'output_fh'}}"\n" unless $_[1]=~ m/^[A-Z]$/s;return}1;
POD_SIMPLE_TEXTCONTENT

$fatpacked{"Pod/Simple/TiedOutFH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TIEDOUTFH';
  use strict;package Pod::Simple::TiedOutFH;use Symbol ('gensym');use Carp ();use vars qw($VERSION);$VERSION='3.35';sub handle_on {my$class=shift;$class=ref($class)|| $class;Carp::croak "Usage: ${class}->handle_on(\$somescalar)" unless @_;my$x=(defined($_[0])and ref($_[0]))? $_[0]: (\($_[0]))[0];$$x='' unless defined $$x;my$new=gensym();tie *$new,$class,$x;return$new}sub TIEHANDLE {my($class,$scalar_ref)=@_;$$scalar_ref='' unless defined $$scalar_ref;return bless \$scalar_ref,ref($class)|| $class}sub PRINT {my$it=shift;for my$x (@_){$$$it .= $x}return 1}sub FETCH {return ${$_[0]}}sub PRINTF {my$it=shift;my$format=shift;$$$it .= sprintf$format,@_;return 1}sub FILENO {${$_[0]}+ 100}sub CLOSE {1}1;
POD_SIMPLE_TIEDOUTFH

$fatpacked{"Pod/Simple/Transcode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODE';
  require 5;package Pod::Simple::Transcode;use strict;use vars qw($VERSION @ISA);$VERSION='3.35';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}for my$class ('Pod::Simple::TranscodeSmart','Pod::Simple::TranscodeDumb','',){$class or die "Couldn't load any encoding classes";DEBUG and print STDERR "About to try loading $class...\n";eval "require $class;";if($@){DEBUG and print STDERR "Couldn't load $class: $@\n"}else {DEBUG and print STDERR "OK, loaded $class.\n";@ISA=($class);last}}sub _blorp {return}1;
POD_SIMPLE_TRANSCODE

$fatpacked{"Pod/Simple/TranscodeDumb.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODEDUMB';
  require 5;package Pod::Simple::TranscodeDumb;use strict;use vars qw($VERSION %Supported);$VERSION='3.35';%Supported=('ascii'=>1,'ascii-ctrl'=>1,'iso-8859-1'=>1,'cp1252'=>1,'null'=>1,'latin1'=>1,'latin-1'=>1,%Supported,);sub is_dumb {1}sub is_smart {0}sub all_encodings {return sort keys%Supported}sub encoding_is_available {return exists$Supported{lc $_[1]}}sub encmodver {return __PACKAGE__ ." v" .($VERSION || '?')}sub make_transcoder {my ($e)=$_[1];die "WHAT ENCODING!?!?" unless$e;return sub {}if$e !~ /^cp-?1252$/i;return sub {my%ascii_for=("\x80"=>'e',"\x82"=>',',"\x83"=>'f',"\x84"=>',,',"\x85"=>'...',"\x86"=>'+',"\x87"=>'++',"\x88"=>'^',"\x89"=>'%',"\x8a"=>'S',"\x8b"=>'<',"\x8c"=>'OE',"\x8e"=>'Z',"\x91"=>"'","\x92"=>"'","\x93"=>'"',"\x94"=>'"',"\x95"=>'*',"\x96"=>'-',"\x97"=>'--',"\x98"=>'~',"\x99"=>'(tm)',"\x9a"=>'s',"\x9b"=>'>',"\x9c"=>'oe',"\x9e"=>'z',"\x9f"=>'Y',);s{([\x80-\x9f])}{$ascii_for{$1} || $1}emxsg for @_}}1;
POD_SIMPLE_TRANSCODEDUMB

$fatpacked{"Pod/Simple/TranscodeSmart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODESMART';
  require 5;use 5.008;package Pod::Simple::TranscodeSmart;use strict;use Pod::Simple;require Encode;use vars qw($VERSION);$VERSION='3.35';sub is_dumb {0}sub is_smart {1}sub all_encodings {return Encode::->encodings(':all')}sub encoding_is_available {return Encode::resolve_alias($_[1])}sub encmodver {return "Encode.pm v" .($Encode::VERSION || '?')}sub make_transcoder {my$e=Encode::find_encoding($_[1]);die "WHAT ENCODING!?!?" unless$e;my$x;return sub {for$x (@_){$x=$e->decode($x)unless Encode::is_utf8($x)}return}}1;
POD_SIMPLE_TRANSCODESMART

$fatpacked{"Pod/Simple/XHTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XHTML';
  package Pod::Simple::XHTML;use strict;use vars qw($VERSION @ISA $HAS_HTML_ENTITIES);$VERSION='3.35';use Pod::Simple::Methody ();@ISA=('Pod::Simple::Methody');BEGIN {$HAS_HTML_ENTITIES=eval "require HTML::Entities; 1"}my%entities=(q{>}=>'gt',q{<}=>'lt',q{'}=>'#39',q{"}=>'quot',q{&}=>'amp',);sub encode_entities {my$self=shift;my$ents=$self->html_encode_chars;return HTML::Entities::encode_entities($_[0],$ents)if$HAS_HTML_ENTITIES;if (defined$ents){$ents =~ s,(?<!\\)([]/]),\\$1,g;$ents =~ s,(?<!\\)\\\z,\\\\,}else {$ents=join '',keys%entities}my$str=$_[0];$str =~ s/([$ents])/'&' . ($entities{$1} || sprintf '#x%X', ord $1) . ';'/ge;return$str}__PACKAGE__->_accessorize('perldoc_url_prefix','perldoc_url_postfix','man_url_prefix','man_url_postfix','title_prefix','title_postfix','html_css','html_javascript','html_doctype','html_charset','html_encode_chars','html_h_level','title','default_title','force_title','html_header','html_footer','index','anchor_items','backlink','batch_mode','batch_mode_current_level',);sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->perldoc_url_prefix('http://search.cpan.org/perldoc?');$new->man_url_prefix('http://man.he.net/man');$new->html_charset('ISO-8859-1');$new->nix_X_codes(1);$new->{'scratch'}='';$new->{'to_index'}=[];$new->{'output'}=[];$new->{'saved'}=[];$new->{'ids'}={'_podtop_'=>1 };$new->{'in_li'}=[];$new->{'__region_targets'}=[];$new->{'__literal_targets'}={};$new->accept_targets_as_html('html','HTML');return$new}sub html_header_tags {my$self=shift;return$self->{html_header_tags}=shift if @_;return$self->{html_header_tags}||= '<meta http-equiv="Content-Type" content="text/html; charset=' .$self->html_charset .'" />'}sub __in_literal_xhtml_region {return unless @{$_[0]{__region_targets}};my$target=$_[0]{__region_targets}[-1];return $_[0]{__literal_targets}{$target }}sub accept_targets_as_html {my ($self,@targets)=@_;$self->accept_targets(@targets);$self->{__literal_targets}{$_}=1 for@targets}sub handle_text {my$text=$_[0]->__in_literal_xhtml_region ? $_[1]: $_[0]->encode_entities($_[1]);if ($_[0]{'in_code'}&& @{$_[0]{'in_code'}}){$_[0]->handle_code($_[1],$_[0]{'in_code'}[-1])}else {if ($_[0]->{in_for}){my$newlines=$_[0]->__in_literal_xhtml_region ? "\n\n" : '';if ($_[0]->{started_for}){if ($text =~ /\S/){delete $_[0]->{started_for};$_[0]{'scratch'}.= $text .$newlines}}else {$text =~ s/\n\z//;$_[0]{'scratch'}.= $text .$newlines}}else {$_[0]{'scratch'}.= $text}}$_[0]{htext}.= $text if $_[0]{'in_head'}}sub start_code {$_[0]{'scratch'}.= '<code>'}sub end_code {$_[0]{'scratch'}.= '</code>'}sub handle_code {$_[0]{'scratch'}.= $_[0]->encode_entities($_[1])}sub start_Para {$_[0]{'scratch'}.= '<p>'}sub start_Verbatim {$_[0]{'scratch'}='<pre>';push(@{$_[0]{'in_code'}},'Verbatim');$_[0]->start_code($_[0]{'in_code'}[-1])}sub start_head1 {$_[0]{'in_head'}=1;$_[0]{htext}=''}sub start_head2 {$_[0]{'in_head'}=2;$_[0]{htext}=''}sub start_head3 {$_[0]{'in_head'}=3;$_[0]{htext}=''}sub start_head4 {$_[0]{'in_head'}=4;$_[0]{htext}=''}sub start_item_number {$_[0]{'scratch'}="</li>\n" if ($_[0]{'in_li'}->[-1]&& pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '<li><p>';push @{$_[0]{'in_li'}},1}sub start_item_bullet {$_[0]{'scratch'}="</li>\n" if ($_[0]{'in_li'}->[-1]&& pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '<li><p>';push @{$_[0]{'in_li'}},1}sub start_item_text {}sub start_over_bullet {$_[0]{'scratch'}='<ul>';push @{$_[0]{'in_li'}},0;$_[0]->emit}sub start_over_block {$_[0]{'scratch'}='<ul>';$_[0]->emit}sub start_over_number {$_[0]{'scratch'}='<ol>';push @{$_[0]{'in_li'}},0;$_[0]->emit}sub start_over_text {$_[0]{'scratch'}='<dl>';$_[0]{'dl_level'}++;$_[0]{'in_dd'}||= [];$_[0]->emit}sub end_over_block {$_[0]{'scratch'}.= '</ul>';$_[0]->emit}sub end_over_number {$_[0]{'scratch'}="</li>\n" if (pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '</ol>';pop @{$_[0]{'in_li'}};$_[0]->emit}sub end_over_bullet {$_[0]{'scratch'}="</li>\n" if (pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '</ul>';pop @{$_[0]{'in_li'}};$_[0]->emit}sub end_over_text {if ($_[0]{'in_dd'}[$_[0]{'dl_level'}]){$_[0]{'scratch'}="</dd>\n";$_[0]{'in_dd'}[$_[0]{'dl_level'}]=0}$_[0]{'scratch'}.= '</dl>';$_[0]{'dl_level'}--;$_[0]->emit}sub end_Para {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_Verbatim {$_[0]->end_code(pop(@{$_[0]->{'in_code'}}));$_[0]{'scratch'}.= '</pre>';$_[0]->emit}sub _end_head {my$h=delete $_[0]{in_head};my$add=$_[0]->html_h_level;$add=1 unless defined$add;$h += $add - 1;my$id=$_[0]->idify($_[0]{htext});my$text=$_[0]{scratch};$_[0]{'scratch'}=$_[0]->backlink && ($h - $add==0)? qq{<a href="#_podtop_"><h$h id="$id">$text</h$h></a>} : qq{<h$h id="$id">$text</h$h>};$_[0]->emit;push @{$_[0]{'to_index'}},[$h,$id,delete $_[0]{'htext'}]}sub end_head1 {shift->_end_head(@_)}sub end_head2 {shift->_end_head(@_)}sub end_head3 {shift->_end_head(@_)}sub end_head4 {shift->_end_head(@_)}sub end_item_bullet {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_item_number {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_item_text {my$dt_id=$_[0]{'anchor_items'}? ' id="'.$_[0]->idify($_[0]{'scratch'}).'"' : '';my$text=$_[0]{scratch};$_[0]{'scratch'}='';if ($_[0]{'in_dd'}[$_[0]{'dl_level'}]){$_[0]{'scratch'}="</dd>\n";$_[0]{'in_dd'}[$_[0]{'dl_level'}]=0}$_[0]{'scratch'}.= qq{<dt$dt_id>$text</dt>\n<dd>};$_[0]{'in_dd'}[$_[0]{'dl_level'}]=1;$_[0]->emit}sub start_for {my ($self,$flags)=@_;push @{$self->{__region_targets}},$flags->{target_matching};$self->{started_for}=1;$self->{in_for}=1;unless ($self->__in_literal_xhtml_region){$self->{scratch}.= '<div';$self->{scratch}.= qq( class="$flags->{target}") if$flags->{target};$self->{scratch}.= ">\n\n"}}sub end_for {my ($self)=@_;delete$self->{started_for};delete$self->{in_for};if ($self->__in_literal_xhtml_region){$self->{'scratch'}=~ s/\s+\z//s}else {$self->{'scratch'}.= '</div>'}pop @{$self->{__region_targets}};$self->emit}sub start_Document {my ($self)=@_;if (defined$self->html_header){$self->{'scratch'}.= $self->html_header;$self->emit unless$self->html_header eq ""}else {my ($doctype,$title,$metatags,$bodyid);$doctype=$self->html_doctype || '';$title=$self->force_title || $self->title || $self->default_title || '';$metatags=$self->html_header_tags || '';if (my$css=$self->html_css){if ($css !~ /<link/){$metatags .= '<link rel="stylesheet" href="' .$self->encode_entities($css).'" type="text/css" />'}else {$metatags .= $css}}if ($self->html_javascript){$metatags .= qq{\n<script type="text/javascript" src="} .$self->html_javascript .'"></script>'}$bodyid=$self->backlink ? ' id="_podtop_"' : '';$self->{'scratch'}.= <<"HTML";$self->emit}}sub end_Document {my ($self)=@_;my$to_index=$self->{'to_index'};if ($self->index && @{$to_index}){my@out;my$level=0;my$indent=-1;my$space='';my$id=' id="index"';for my$h (@{$to_index},[0]){my$target_level=$h->[0];if ($level==$target_level){$out[-1].= '</li>'}elsif ($level > $target_level){$out[-1].= '</li>' if$out[-1]=~ /^\s+<li>/;while ($level > $target_level){--$level;push@out,('  ' x --$indent).'</li>' if@out && $out[-1]=~ m{^\s+<\/ul};push@out,('  ' x --$indent).'</ul>'}push@out,('  ' x --$indent).'</li>' if$level}else {while ($level < $target_level){++$level;push@out,('  ' x ++$indent).'<li>' if@out && $out[-1]=~ /^\s*<ul/;push@out,('  ' x ++$indent)."<ul$id>";$id=''}++$indent}next unless$level;$space='  ' x $indent;push@out,sprintf '%s<li><a href="#%s">%s</a>',$space,$h->[1],$h->[2]}my$offset=defined$self->html_header ? $self->html_header eq '' ? 0 : 1 : 1;splice @{$self->{'output'}},$offset,0,join "\n",@out}if (defined$self->html_footer){$self->{'scratch'}.= $self->html_footer;$self->emit unless$self->html_footer eq ""}else {$self->{'scratch'}.= "</body>\n</html>";$self->emit}if ($self->index){print {$self->{'output_fh'}}join ("\n\n",@{$self->{'output'}}),"\n\n";@{$self->{'output'}}=()}}sub start_B {$_[0]{'scratch'}.= '<b>'}sub end_B {$_[0]{'scratch'}.= '</b>'}sub start_C {push(@{$_[0]{'in_code'}},'C');$_[0]->start_code($_[0]{'in_code'}[-1])}sub end_C {$_[0]->end_code(pop(@{$_[0]{'in_code'}}))}sub start_F {$_[0]{'scratch'}.= '<i>'}sub end_F {$_[0]{'scratch'}.= '</i>'}sub start_I {$_[0]{'scratch'}.= '<i>'}sub end_I {$_[0]{'scratch'}.= '</i>'}sub start_L {my ($self,$flags)=@_;my ($type,$to,$section)=@{$flags}{'type','to','section'};my$url=$self->encode_entities($type eq 'url' ? $to : $type eq 'pod' ? $self->resolve_pod_page_link($to,$section): $type eq 'man' ? $self->resolve_man_page_link($to,$section): undef);$self->{'scratch'}.= '<a' .($url ? ' href="'.$url .'">' : '>')}sub end_L {$_[0]{'scratch'}.= '</a>'}sub start_S {$_[0]{'scratch'}.= '<span style="white-space: nowrap;">'}sub end_S {$_[0]{'scratch'}.= '</span>'}sub emit {my($self)=@_;if ($self->index){push @{$self->{'output'}},$self->{'scratch'}}else {print {$self->{'output_fh'}}$self->{'scratch'},"\n\n"}$self->{'scratch'}='';return}sub resolve_pod_page_link {my ($self,$to,$section)=@_;return undef unless defined$to || defined$section;if (defined$section){$section='#' .$self->idify($self->encode_entities($section),1);return$section unless defined$to}else {$section=''}return ($self->perldoc_url_prefix || '').$self->encode_entities($to).$section .($self->perldoc_url_postfix || '')}sub resolve_man_page_link {my ($self,$to,$section)=@_;return undef unless defined$to;my ($page,$part)=$to =~ /^([^(]+)(?:[(](\d+)[)])?$/;return undef unless$page;return ($self->man_url_prefix || '').($part || 1)."/" .$self->encode_entities($page).($self->man_url_postfix || '')}sub idify {my ($self,$t,$not_unique)=@_;for ($t){s/<[^>]+>//g;s/&[^;]+;//g;s/^\s+//;s/\s+$//;s/^([^a-zA-Z]+)$/pod$1/;s/^[^a-zA-Z]+//;s/[^-a-zA-Z0-9_:.]+/-/g;s/[-:.]+$//}return$t if$not_unique;my$i='';$i++ while$self->{ids}{"$t$i"}++;return "$t$i"}sub batch_mode_page_object_init {my ($self,$batchconvobj,$module,$infile,$outfile,$depth)=@_;$self->batch_mode(1);$self->batch_mode_current_level($depth);return$self}sub html_header_after_title {}1;
  $doctype
  <html>
  <head>
  <title>$title</title>
  $metatags
  </head>
  <body$bodyid>
  HTML
POD_SIMPLE_XHTML

$fatpacked{"Pod/Simple/XMLOutStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XMLOUTSTREAM';
  require 5;package Pod::Simple::XMLOutStream;use strict;use Carp ();use Pod::Simple ();use vars qw($ATTR_PAD @ISA $VERSION $SORT_ATTRS);$VERSION='3.35';BEGIN {@ISA=('Pod::Simple');*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}$ATTR_PAD="\n" unless defined$ATTR_PAD;$SORT_ATTRS=0 unless defined$SORT_ATTRS;sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print STDERR "++ $_[1]\n";print$fh "<",$_[1];if($SORT_ATTRS){for my$key (sort keys %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value=$_[2]{$key});print$fh $ATTR_PAD,$key,'="',$value,'"'}}}else {while(($key,$value)=each %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value);print$fh $ATTR_PAD,$key,'="',$value,'"'}}}print$fh ">";return}sub _handle_text {DEBUG and print STDERR "== \"$_[1]\"\n";if(length $_[1]){my$text=$_[1];_xml_escape($text);print {$_[0]{'output_fh'}}$text}return}sub _handle_element_end {DEBUG and print STDERR "-- $_[1]\n";print {$_[0]{'output_fh'}}"</",$_[1],">";return}sub _xml_escape {for my$x (@_){if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}}return}1;
POD_SIMPLE_XMLOUTSTREAM

$fatpacked{"Pod/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_USAGE';
  package Pod::Usage;use strict;use vars qw($VERSION @ISA @EXPORT);$VERSION='1.69';require 5.006;use Carp;use Config;use Exporter;use File::Spec;@EXPORT=qw(&pod2usage);BEGIN {$Pod::Usage::Formatter ||= 'Pod::Text';eval "require $Pod::Usage::Formatter";die $@ if $@;@ISA=($Pod::Usage::Formatter)}our$MAX_HEADING_LEVEL=3;sub pod2usage {local($_)=shift;my%opts;if (@_ > 0){%opts=($_,@_)}elsif (!defined $_){$_=''}elsif (ref $_){%opts=%{$_}if (ref($_)eq 'HASH')}elsif (/^[-+]?\d+$/){$opts{'-exitval'}=$_}else {$_ and $opts{'-message'}=$_}%opts=map {my ($key,$val)=($_,$opts{$_});$key =~ s/^(?=\w)/-/;$key =~ /^-msg/i and $key='-message';$key =~ /^-exit/i and $key='-exitval';lc($key)=>$val}(keys%opts);if ((!defined$opts{'-exitval'})&& (!defined$opts{'-verbose'})){$opts{'-exitval'}=2;$opts{'-verbose'}=0}elsif (!defined$opts{'-exitval'}){$opts{'-exitval'}=($opts{'-verbose'}> 0)? 1 : 2}elsif (!defined$opts{'-verbose'}){$opts{'-verbose'}=(lc($opts{'-exitval'})eq 'noexit' || $opts{'-exitval'}< 2)}$opts{'-output'}=(lc($opts{'-exitval'})eq 'noexit' || $opts{'-exitval'}< 2)? \*STDOUT : \*STDERR unless (defined$opts{'-output'});$opts{'-input'}=$0 unless (defined$opts{'-input'});unless ((ref$opts{'-input'})|| (-e $opts{'-input'})){my$basename=$opts{'-input'};my$pathsep=($^O =~ /^(?:dos|os2|MSWin32)$/i)? ';' : (($^O eq 'MacOS' || $^O eq 'VMS')? ',' : ':');my$pathspec=$opts{'-pathlist'}|| $ENV{PATH}|| $ENV{PERL5LIB};my@paths=(ref$pathspec)? @$pathspec : split($pathsep,$pathspec);for my$dirname (@paths){$_=File::Spec->catfile($dirname,$basename)if length;last if (-e $_)&& ($opts{'-input'}=$_)}}my$parser=new Pod::Usage(USAGE_OPTIONS=>\%opts);if ($opts{'-verbose'}==0){$parser->select('(?:SYNOPSIS|USAGE)\s*')}elsif ($opts{'-verbose'}==1){my$opt_re='(?i)' .'(?:OPTIONS|ARGUMENTS)' .'(?:\s*(?:AND|\/)\s*(?:OPTIONS|ARGUMENTS))?';$parser->select('(?:SYNOPSIS|USAGE)\s*',$opt_re,"DESCRIPTION/$opt_re")}elsif ($opts{'-verbose'}>= 2 && $opts{'-verbose'}!=99){$parser->select('.*')}elsif ($opts{'-verbose'}==99){my$sections=$opts{'-sections'};$parser->select((ref$sections)? @$sections : $sections);$opts{'-verbose'}=1}my$progpath=$opts{'-perldoc'}? $opts{'-perldoc'}: File::Spec->catfile($Config{scriptdirexp}|| $Config{scriptdir},'perldoc');my$version=sprintf("%vd",$^V);if ($Config{versiononly}and $Config{startperl}=~ /\Q$version\E$/){$progpath .= $version}$opts{'-noperldoc'}=1 unless -e $progpath;if (!$opts{'-noperldoc'}and $opts{'-verbose'}>= 2 and!ref($opts{'-input'})and $opts{'-output'}==\*STDOUT){print {$opts{'-output'}}($opts{'-message'},"\n")if($opts{'-message'});if(defined$opts{-input}&& $opts{-input}=~ /^\s*(\S.*?)\s*$/){my$f=$1;my@perldoc_cmd=($progpath);if ($opts{'-perldocopt'}){$opts{'-perldocopt'}=~ s/^\s+|\s+$//g;push@perldoc_cmd,split(/\s+/,$opts{'-perldocopt'})}push@perldoc_cmd,('-F',$f);unshift@perldoc_cmd,$opts{'-perlcmd'}if$opts{'-perlcmd'};system(@perldoc_cmd);if($?){system(($Config{pager}|| $ENV{PAGER}|| '/bin/more'),$1)}}else {croak "Unspecified input file or insecure argument.\n"}}else {$parser->parse_from_file($opts{'-input'},$opts{'-output'})}exit($opts{'-exitval'})unless (lc($opts{'-exitval'})eq 'noexit')}sub new {my$this=shift;my$class=ref($this)|| $this;my%params=@_;my$self={%params};bless$self,$class;if ($self->can('initialize')){$self->initialize()}else {my%opts;for (qw(alt code indent loose margin quotes sentence stderr utf8 width)){my$val=$params{USAGE_OPTIONS}{"-$_"};$opts{$_}=$val if defined$val}$self=$self->SUPER::new(%opts);%$self=(%$self,%params)}return$self}sub _compile_section_spec {my ($section_spec)=@_;my (@regexs,$negated);local $_=$section_spec;s{\\\\}{\001}g;s{\\/}{\002}g;@regexs=split(/\//,$_,$MAX_HEADING_LEVEL);for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$regexs[$i]='.*' unless ((defined$regexs[$i])&& (length$regexs[$i]))}my$bad_regexs=0;for (@regexs){$_ .= '.+' if ($_ eq '!');s{\001}{\\\\}g;s{\002}{\\/}g;$negated=s/^\!//;eval "m{$_}";if ($@){++$bad_regexs;carp qq{Bad regular expression /$_/ in "$section_spec": $@\n}}else {$_='^' .$_ unless (/^\^/);$_=$_ .'$' unless (/\$$/);$_='!' .$_ if ($negated)}}return (!$bad_regexs)? [@regexs ]: undef}sub select {my ($self,@sections)=@_;if ($ISA[0]->can('select')){$self->SUPER::select(@sections)}else {my$add=($sections[0]eq '+')? shift(@sections): '';unless (@sections){delete$self->{USAGE_SELECT}unless ($add);return}$self->{USAGE_SELECT}=[]unless ($add && $self->{USAGE_SELECT});my$sref=$self->{USAGE_SELECT};for my$spec (@sections){my$cs=_compile_section_spec($spec);if (defined$cs){push(@$sref,$cs)}else {carp qq{Ignoring section spec "$spec"!\n}}}}}sub seq_i {return $_[1]}sub cmd_i {return $_[2]}sub _handle_element_end {my ($self,$element)=@_;if ($element eq 'head1'){$self->{USAGE_HEADINGS}=[$$self{PENDING}[-1][1]];if ($self->{USAGE_OPTIONS}->{-verbose}< 2){$$self{PENDING}[-1][1]=~ s/^\s*SYNOPSIS\s*$/USAGE/}}elsif ($element =~ /^head(\d+)$/ && $1){my$idx=$1 - 1;$self->{USAGE_HEADINGS}=[]unless($self->{USAGE_HEADINGS});$self->{USAGE_HEADINGS}->[$idx]=$$self{PENDING}[-1][1];splice(@{$self->{USAGE_HEADINGS}},$idx+1)}if ($element =~ /^head\d+$/){$$self{USAGE_SKIPPING}=1;if (!$$self{USAGE_SELECT}||!@{$$self{USAGE_SELECT}}){$$self{USAGE_SKIPPING}=0}else {my@headings=@{$$self{USAGE_HEADINGS}};for my$section_spec (@{$$self{USAGE_SELECT}}){my$match=1;for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$headings[$i]='' unless defined$headings[$i];my$regex=$section_spec->[$i];my$negated=($regex =~ s/^\!//);$match &= ($negated ? ($headings[$i]!~ /${regex}/): ($headings[$i]=~ /${regex}/));last unless ($match)}if ($match){$$self{USAGE_SKIPPING}=0;last}}}if($self->{USAGE_OPTIONS}->{-verbose}< 2){local $_=$$self{PENDING}[-1][1];s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;s/\s*$/:/ unless (/:\s*$/);$_ .= "\n";$$self{PENDING}[-1][1]=$_}}if ($$self{USAGE_SKIPPING}&& $element !~ m/^over-|^[BCFILSZ]$/){pop @{$$self{PENDING}}}else {$self->SUPER::_handle_element_end($element)}}sub start_document {my$self=shift;$self->SUPER::start_document();my$msg=$self->{USAGE_OPTIONS}->{-message}or return 1;my$out_fh=$self->output_fh();print$out_fh "$msg\n"}sub begin_pod {my$self=shift;$self->SUPER::begin_pod();my$msg=$self->{USAGE_OPTIONS}->{-message}or return 1;my$out_fh=$self->output_handle();print$out_fh "$msg\n"}sub preprocess_paragraph {my$self=shift;local $_=shift;my$line=shift;if (($self->{USAGE_OPTIONS}->{-verbose}< 2)&& /^=head/){s/^=head1\s+SYNOPSIS\s*$/=head1 USAGE/;s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;s/\s*$/:/ unless (/:\s*$/);$_ .= "\n"}return$self->SUPER::preprocess_paragraph($_)}1;
POD_USAGE

$fatpacked{"Test/MonkeyMock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MONKEYMOCK';
  package Test::MonkeyMock;use strict;use warnings;require Carp;our$VERSION='0.09';my$registry={};my$magic_counter=0;sub new {my$class=shift;$class=ref$class if ref$class;my ($instance)=@_;my$new_package;if ($instance){$new_package=__PACKAGE__ .'::' .ref($instance).'::__instance__' .($magic_counter++);no strict 'refs';@{$new_package .'::ISA'}=(ref($instance))}else {$instance={};$new_package=__PACKAGE__ .'::' .($magic_counter++);no strict 'refs';@{$new_package .'::ISA'}=__PACKAGE__}no strict 'refs';for my$method (qw/mock mocked_called mocked_call_args mocked_call_stack mocked_return_args mocked_return_stack/){*{$new_package .'::' .$method}=sub {goto &$method}}bless$instance,$new_package;return$instance}sub mock {my$self=shift;my ($method,$code,%options)=@_;if (ref($self)=~ m/__instance__/){Carp::croak("Unknown method '$method'")unless my$orig_method=$self->can($method);if (exists$registry->{ref($self)}->{'mocks'}->{$method}){push @{$registry->{ref($self)}->{'mocks'}->{$method}},{code=>$code,orig_code=>$orig_method};return$self}my$ref_self=ref($self);my$package=__PACKAGE__;$ref_self =~ s/^${package}::(.*)::__instance__\d+/$1/;my$new_package=__PACKAGE__ .'::' .$ref_self .'::__instance__' .$magic_counter++;$registry->{$new_package}=$registry->{ref($self)};my$mocks=$registry->{$new_package}->{'mocks'}||= {};$mocks->{$method}=[{code=>$code,orig_code=>$orig_method,options=>\%options}];no strict 'refs';@{$new_package .'::ISA'}=ref($self);*{$new_package .'::' .$method}=sub {_dispatch($new_package,$method,@_)};bless$self,$new_package}else {my$mocks=$registry->{ref($self)}->{'mocks'}||= {};push @{$mocks->{$method}},{code=>$code,options=>\%options }}return$self}sub mocked_called {my$self=shift;my ($method)=@_;my$mocks=$registry->{ref($self)}->{'mocks'}||= {};my$calls=$registry->{ref($self)}->{'calls'}||= {};if (ref($self)=~ m/__instance__/){Carp::croak("Unknown method '$method'")unless$self->can($method)}else {Carp::croak("Unmocked method '$method'")unless exists$mocks->{$method}}return$calls->{$method}->{called}|| 0}sub mocked_call_args {my$self=shift;my ($method,$frame)=@_;$frame ||= 0;my$stack=$self->mocked_call_stack($method);Carp::croak("Unknown frame '$frame'")unless @$stack > $frame;return @{$stack->[$frame]}}sub mocked_call_stack {my$self=shift;my ($method)=@_;Carp::croak("Method is required")unless$method;my$calls=$registry->{ref($self)}->{'calls'}||= {};my$mocks=$registry->{ref($self)}->{'mocks'}||= {};if (ref($self)=~ m/__instance__/){Carp::croak("Unknown method '$method'")unless$self->can($method)}else {Carp::croak("Unmocked method '$method'")unless exists$mocks->{$method}}Carp::croak("Method '$method' was not called")unless exists$calls->{$method};return$calls->{$method}->{stack}}sub mocked_return_args {my$self=shift;my ($method,$frame)=@_;$frame ||= 0;my$stack=$self->mocked_return_stack($method);Carp::croak("Unknown frame '$frame'")unless @$stack > $frame;return @{$stack->[$frame]}}sub mocked_return_stack {my$self=shift;my ($method)=@_;Carp::croak("Method is required")unless$method;my$returns=$registry->{ref($self)}->{'returns'}||= {};my$mocks=$registry->{ref($self)}->{'mocks'}||= {};if (ref($self)=~ m/__instance__/){Carp::croak("Unknown method '$method'")unless$self->can($method)}else {Carp::croak("Unmocked method '$method'")unless exists$mocks->{$method}}Carp::croak("Method '$method' was not called")unless exists$returns->{$method};return$returns->{$method}->{stack}}sub can {my$self=shift;my ($method)=@_;if (ref($self)=~ m/__instance__/){return$self->can($method)}else {my$mocks=$registry->{ref($self)}->{'mocks'}||= {};return$mocks->{$method}->[0]->{code}}}our$AUTOLOAD;sub AUTOLOAD {my$self=shift;my ($method)=(split /::/,$AUTOLOAD)[-1];return if$method =~ /^[A-Z]+$/;return _dispatch(ref($self),$method,$self,@_)}sub _dispatch {my ($ref_self,$method,@args)=@_;my$calls=$registry->{$ref_self}->{'calls'}||= {};my$returns=$registry->{$ref_self}->{'returns'}||= {};my$mocks=$registry->{$ref_self}->{'mocks'}||= {};Carp::croak("Unmocked method '$method'")if!exists$mocks->{$method};for my$mock (@{$mocks->{$method}}){if (my$options=$mock->{options}){if (my$when=$options->{when}){next unless$when->(@args)}if (defined(my$frame=$options->{frame})){my$current_frame=$returns->{$method}->{stack}? @{$returns->{$method}->{stack}}: 0;next unless$frame==$current_frame}}$calls->{$method}->{called}++;push @{$calls->{$method}->{stack}},[@args[1 .. $#args]];my@result;if (my$code=$mock->{code}){@result=$code->(@args)}elsif (my$orig_code=$mock->{orig_code}){@result=$orig_code->(@args)}else {Carp::croak("Unmocked method '$method'")}push @{$returns->{$method}->{stack}},[@result];return wantarray ? @result : $result[0]}}1;
TEST_MONKEYMOCK

$fatpacked{"YAML/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TINY';
  use 5.008001;use strict;use warnings;package YAML::Tiny;our$VERSION='1.70';use Exporter;our@ISA=qw{Exporter};our@EXPORT=qw{Load Dump};our@EXPORT_OK=qw{LoadFile DumpFile freeze thaw};sub Dump {return YAML::Tiny->new(@_)->_dump_string}sub Load {my$self=YAML::Tiny->_load_string(@_);if (wantarray){return @$self}else {return$self->[-1]}}BEGIN {*freeze=\&Dump;*thaw=\&Load}sub DumpFile {my$file=shift;return YAML::Tiny->new(@_)->_dump_file($file)}sub LoadFile {my$file=shift;my$self=YAML::Tiny->_load_file($file);if (wantarray){return @$self}else {return$self->[-1]}}sub new {my$class=shift;bless [@_ ],$class}sub read_string {my$self=shift;$self->_load_string(@_)}sub write_string {my$self=shift;$self->_dump_string(@_)}sub read {my$self=shift;$self->_load_file(@_)}sub write {my$self=shift;$self->_dump_file(@_)}my@UNPRINTABLE=qw(0 x01 x02 x03 x04 x05 x06 a b t n v f r x0E x0F x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x1A e x1C x1D x1E x1F);my%UNESCAPES=(0=>"\x00",z=>"\x00",N=>"\x85",a=>"\x07",b=>"\x08",t=>"\x09",n=>"\x0a",v=>"\x0b",f=>"\x0c",r=>"\x0d",e=>"\x1b",'\\'=>'\\',);my%QUOTE=map {$_=>1}qw{null true false};my$re_capture_double_quoted=qr/\"([^\\"]*(?:\\.[^\\"]*)*)\"/;my$re_capture_single_quoted=qr/\'([^\']*(?:\'\'[^\']*)*)\'/;my$re_capture_unquoted_key=qr/([^:]+(?::+\S(?:[^:]*|.*?(?=:)))*)(?=\s*\:(?:\s+|$))/;my$re_trailing_comment=qr/(?:\s+\#.*)?/;my$re_key_value_separator=qr/\s*:(?:\s+(?:\#.*)?|$)/;sub _load_file {my$class=ref $_[0]? ref shift : shift;my$file=shift or $class->_error('You did not specify a file name');$class->_error("File '$file' does not exist")unless -e $file;$class->_error("'$file' is a directory, not a file")unless -f _;$class->_error("Insufficient permissions to read '$file'")unless -r _;open(my$fh,"<:unix:encoding(UTF-8)",$file);unless ($fh){$class->_error("Failed to open file '$file': $!")}if (_can_flock()){flock($fh,Fcntl::LOCK_SH())or warn "Couldn't lock '$file' for reading: $!"}my$contents=eval {use warnings FATAL=>'utf8';local $/;<$fh>};if (my$err=$@){$class->_error("Error reading from file '$file': $err")}unless (close$fh){$class->_error("Failed to close file '$file': $!")}$class->_load_string($contents)}sub _load_string {my$class=ref $_[0]? ref shift : shift;my$self=bless [],$class;my$string=$_[0];eval {unless (defined$string){die \"Did not provide a string to load"}if (utf8::is_utf8($string)&&!utf8::valid($string)){die \<<'...'}utf8::upgrade($string);$string =~ s/^\x{FEFF}//;return$self unless length$string;my@lines=grep {!/^\s*(?:\#.*)?\z/}split /(?:\015{1,2}\012|\015|\012)/,$string;@lines and $lines[0]=~ /^\%YAML[: ][\d\.]+.*\z/ and shift@lines;my$in_document=0;while (@lines){if ($lines[0]=~ /^---\s*(?:(.+)\s*)?\z/){shift@lines;if (defined $1 and $1 !~ /^(?:\#.+|\%YAML[: ][\d\.]+)\z/){push @$self,$self->_load_scalar("$1",[undef ],\@lines);next}$in_document=1}if (!@lines or $lines[0]=~ /^(?:---|\.\.\.)/){push @$self,undef;while (@lines and $lines[0]!~ /^---/){shift@lines}$in_document=0}elsif (!$in_document && @$self){die \"YAML::Tiny failed to classify the line '$lines[0]'"}elsif ($lines[0]=~ /^\s*\-(?:\s|$|-+$)/){my$document=[];push @$self,$document;$self->_load_array($document,[0 ],\@lines)}elsif ($lines[0]=~ /^(\s*)\S/){my$document={};push @$self,$document;$self->_load_hash($document,[length($1)],\@lines)}else {die \"YAML::Tiny failed to classify the line '$lines[0]'"}}};my$err=$@;if (ref$err eq 'SCALAR'){$self->_error(${$err})}elsif ($err){$self->_error($err)}return$self}sub _unquote_single {my ($self,$string)=@_;return '' unless length$string;$string =~ s/\'\'/\'/g;return$string}sub _unquote_double {my ($self,$string)=@_;return '' unless length$string;$string =~ s/\\"/"/g;$string =~ s{\\([Nnever\\fartz0b]|x([0-9a-fA-F]{2}))}
  Read an invalid UTF-8 string (maybe mixed UTF-8 and 8-bit character set).
  Did you decode with lax ":utf8" instead of strict ":encoding(UTF-8)"?
  ...
           {(length($1)>1)?pack("H2",$2):$UNESCAPES{$1}}gex;return$string}sub _load_scalar {my ($self,$string,$indent,$lines)=@_;$string =~ s/\s*\z//;return undef if$string eq '~';if ($string =~ /^$re_capture_single_quoted$re_trailing_comment\z/){return$self->_unquote_single($1)}if ($string =~ /^$re_capture_double_quoted$re_trailing_comment\z/){return$self->_unquote_double($1)}if ($string =~ /^[\'\"!&]/){die \"YAML::Tiny does not support a feature in line '$string'"}return {}if$string =~ /^{}(?:\s+\#.*)?\z/;return []if$string =~ /^\[\](?:\s+\#.*)?\z/;if ($string !~ /^[>|]/){die \"YAML::Tiny found illegal characters in plain scalar: '$string'" if$string =~ /^(?:-(?:\s|$)|[\@\%\`])/ or $string =~ /:(?:\s|$)/;$string =~ s/\s+#.*\z//;return$string}die \"YAML::Tiny failed to find multi-line scalar content" unless @$lines;$lines->[0]=~ /^(\s*)/;$indent->[-1]=length("$1");if (defined$indent->[-2]and $indent->[-1]<= $indent->[-2]){die \"YAML::Tiny found bad indenting in line '$lines->[0]'"}my@multiline=();while (@$lines){$lines->[0]=~ /^(\s*)/;last unless length($1)>= $indent->[-1];push@multiline,substr(shift(@$lines),length($1))}my$j=(substr($string,0,1)eq '>')? ' ' : "\n";my$t=(substr($string,1,1)eq '-')? '' : "\n";return join($j,@multiline).$t}sub _load_array {my ($self,$array,$indent,$lines)=@_;while (@$lines){if ($lines->[0]=~ /^(?:---|\.\.\.)/){while (@$lines and $lines->[0]!~ /^---/){shift @$lines}return 1}$lines->[0]=~ /^(\s*)/;if (length($1)< $indent->[-1]){return 1}elsif (length($1)> $indent->[-1]){die \"YAML::Tiny found bad indenting in line '$lines->[0]'"}if ($lines->[0]=~ /^(\s*\-\s+)[^\'\"]\S*\s*:(?:\s+|$)/){my$indent2=length("$1");$lines->[0]=~ s/-/ /;push @$array,{};$self->_load_hash($array->[-1],[@$indent,$indent2 ],$lines)}elsif ($lines->[0]=~ /^\s*\-\s*\z/){shift @$lines;unless (@$lines){push @$array,undef;return 1}if ($lines->[0]=~ /^(\s*)\-/){my$indent2=length("$1");if ($indent->[-1]==$indent2){push @$array,undef}else {push @$array,[];$self->_load_array($array->[-1],[@$indent,$indent2 ],$lines)}}elsif ($lines->[0]=~ /^(\s*)\S/){push @$array,{};$self->_load_hash($array->[-1],[@$indent,length("$1")],$lines)}else {die \"YAML::Tiny failed to classify line '$lines->[0]'"}}elsif ($lines->[0]=~ /^\s*\-(\s*)(.+?)\s*\z/){shift @$lines;push @$array,$self->_load_scalar("$2",[@$indent,undef ],$lines)}elsif (defined$indent->[-2]and $indent->[-1]==$indent->[-2]){return 1}else {die \"YAML::Tiny failed to classify line '$lines->[0]'"}}return 1}sub _load_hash {my ($self,$hash,$indent,$lines)=@_;while (@$lines){if ($lines->[0]=~ /^(?:---|\.\.\.)/){while (@$lines and $lines->[0]!~ /^---/){shift @$lines}return 1}$lines->[0]=~ /^(\s*)/;if (length($1)< $indent->[-1]){return 1}elsif (length($1)> $indent->[-1]){die \"YAML::Tiny found bad indenting in line '$lines->[0]'"}my$key;if ($lines->[0]=~ s/^\s*$re_capture_single_quoted$re_key_value_separator//){$key=$self->_unquote_single($1)}elsif ($lines->[0]=~ s/^\s*$re_capture_double_quoted$re_key_value_separator//){$key=$self->_unquote_double($1)}elsif ($lines->[0]=~ s/^\s*$re_capture_unquoted_key$re_key_value_separator//){$key=$1;$key =~ s/\s+$//}elsif ($lines->[0]=~ /^\s*\?/){die \"YAML::Tiny does not support a feature in line '$lines->[0]'"}else {die \"YAML::Tiny failed to classify line '$lines->[0]'"}if (exists$hash->{$key}){warn "YAML::Tiny found a duplicate key '$key' in line '$lines->[0]'"}if (length$lines->[0]){$hash->{$key}=$self->_load_scalar(shift(@$lines),[@$indent,undef ],$lines)}else {shift @$lines;unless (@$lines){$hash->{$key}=undef;return 1}if ($lines->[0]=~ /^(\s*)-/){$hash->{$key}=[];$self->_load_array($hash->{$key},[@$indent,length($1)],$lines)}elsif ($lines->[0]=~ /^(\s*)./){my$indent2=length("$1");if ($indent->[-1]>= $indent2){$hash->{$key}=undef}else {$hash->{$key}={};$self->_load_hash($hash->{$key},[@$indent,length($1)],$lines)}}}}return 1}sub _dump_file {my$self=shift;require Fcntl;my$file=shift or $self->_error('You did not specify a file name');my$fh;if (_can_flock()){my$flags=Fcntl::O_WRONLY()|Fcntl::O_CREAT();sysopen($fh,$file,$flags)or $self->_error("Failed to open file '$file' for writing: $!");binmode($fh,":raw:encoding(UTF-8)");flock($fh,Fcntl::LOCK_EX())or warn "Couldn't lock '$file' for reading: $!";truncate$fh,0;seek$fh,0,0}else {open$fh,">:unix:encoding(UTF-8)",$file}print {$fh}$self->_dump_string;unless (close$fh){$self->_error("Failed to close file '$file': $!")}return 1}sub _dump_string {my$self=shift;return '' unless ref$self && @$self;my$indent=0;my@lines=();eval {for my$cursor (@$self){push@lines,'---';if (!defined$cursor){}elsif (!ref$cursor){$lines[-1].= ' ' .$self->_dump_scalar($cursor)}elsif (ref$cursor eq 'ARRAY'){unless (@$cursor){$lines[-1].= ' []';next}push@lines,$self->_dump_array($cursor,$indent,{})}elsif (ref$cursor eq 'HASH'){unless (%$cursor){$lines[-1].= ' {}';next}push@lines,$self->_dump_hash($cursor,$indent,{})}else {die \("Cannot serialize " .ref($cursor))}}};if (ref $@ eq 'SCALAR'){$self->_error(${$@})}elsif ($@){$self->_error($@)}join '',map {"$_\n"}@lines}sub _has_internal_string_value {my$value=shift;my$b_obj=B::svref_2object(\$value);return$b_obj->FLAGS & B::SVf_POK()}sub _dump_scalar {my$string=$_[1];my$is_key=$_[2];my$has_string_flag=_has_internal_string_value($string);return '~' unless defined$string;return "''" unless length$string;if (Scalar::Util::looks_like_number($string)){if ($is_key || $has_string_flag){return qq['$string']}else {return$string}}if ($string =~ /[\x00-\x09\x0b-\x0d\x0e-\x1f\x7f-\x9f\'\n]/){$string =~ s/\\/\\\\/g;$string =~ s/"/\\"/g;$string =~ s/\n/\\n/g;$string =~ s/[\x85]/\\N/g;$string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;$string =~ s/([\x7f-\x9f])/'\x' . sprintf("%X",ord($1))/ge;return qq|"$string"|}if ($string =~ /(?:^[~!@#%&*|>?:,'"`{}\[\]]|^-+$|\s|:\z)/ or $QUOTE{$string}){return "'$string'"}return$string}sub _dump_array {my ($self,$array,$indent,$seen)=@_;if ($seen->{refaddr($array)}++){die \"YAML::Tiny does not support circular references"}my@lines=();for my$el (@$array){my$line=('  ' x $indent).'-';my$type=ref$el;if (!$type){$line .= ' ' .$self->_dump_scalar($el);push@lines,$line}elsif ($type eq 'ARRAY'){if (@$el){push@lines,$line;push@lines,$self->_dump_array($el,$indent + 1,$seen)}else {$line .= ' []';push@lines,$line}}elsif ($type eq 'HASH'){if (keys %$el){push@lines,$line;push@lines,$self->_dump_hash($el,$indent + 1,$seen)}else {$line .= ' {}';push@lines,$line}}else {die \"YAML::Tiny does not support $type references"}}@lines}sub _dump_hash {my ($self,$hash,$indent,$seen)=@_;if ($seen->{refaddr($hash)}++){die \"YAML::Tiny does not support circular references"}my@lines=();for my$name (sort keys %$hash){my$el=$hash->{$name};my$line=('  ' x $indent).$self->_dump_scalar($name,1).":";my$type=ref$el;if (!$type){$line .= ' ' .$self->_dump_scalar($el);push@lines,$line}elsif ($type eq 'ARRAY'){if (@$el){push@lines,$line;push@lines,$self->_dump_array($el,$indent + 1,$seen)}else {$line .= ' []';push@lines,$line}}elsif ($type eq 'HASH'){if (keys %$el){push@lines,$line;push@lines,$self->_dump_hash($el,$indent + 1,$seen)}else {$line .= ' {}';push@lines,$line}}else {die \"YAML::Tiny does not support $type references"}}@lines}our$errstr='';sub _error {require Carp;$errstr=$_[1];$errstr =~ s/ at \S+ line \d+.*//;Carp::croak($errstr)}my$errstr_warned;sub errstr {require Carp;Carp::carp("YAML::Tiny->errstr and \$YAML::Tiny::errstr is deprecated")unless$errstr_warned++;$errstr}use B;my$HAS_FLOCK;sub _can_flock {if (defined$HAS_FLOCK){return$HAS_FLOCK}else {require Config;my$c=\%Config::Config;$HAS_FLOCK=grep {$c->{$_}}qw/d_flock d_fcntl_can_lock d_lockf/;require Fcntl if$HAS_FLOCK;return$HAS_FLOCK}}use Scalar::Util ();BEGIN {local $@;if (eval {Scalar::Util->VERSION(1.18)}){*refaddr=*Scalar::Util::refaddr}else {eval <<'END_PERL'}}delete$YAML::Tiny::{refaddr};1;
  # Scalar::Util failed to load or too old
  sub refaddr {
      my $pkg = ref($_[0]) or return undef;
      if ( !! UNIVERSAL::can($_[0], 'can') ) {
          bless $_[0], 'Scalar::Util::Fake';
      } else {
          $pkg = undef;
      }
      "$_[0]" =~ /0x(\w+)/;
      my $i = do { no warnings 'portable'; hex $1 };
      bless $_[0], $pkg if defined $pkg;
      $i;
  }
  END_PERL
YAML_TINY

$fatpacked{"lib/core/only.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB_CORE_ONLY';
  package lib::core::only;use strict;use warnings FATAL=>'all';use Config;sub import {@INC=@Config{qw(privlibexp archlibexp)};return}1;
LIB_CORE_ONLY

$fatpacked{"local/lib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCAL_LIB';
  package local::lib;use 5.006;BEGIN {if ($ENV{RELEASE_TESTING}){require strict;strict->import;require warnings;warnings->import}}use Config ();our$VERSION='2.000024';$VERSION=eval$VERSION;BEGIN {*_WIN32=($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'symbian')? sub(){1}: sub(){0};*_USE_FSPEC=($^O eq 'MacOS' || $^O eq 'VMS' || $INC{'File/Spec.pm'})? sub(){1}: sub(){0}}my$_archname=$Config::Config{archname};my$_version=$Config::Config{version};my@_inc_version_list=reverse split / /,$Config::Config{inc_version_list};my$_path_sep=$Config::Config{path_sep};our$_DIR_JOIN=_WIN32 ? '\\' : '/';our$_DIR_SPLIT=(_WIN32 || $^O eq 'cygwin')? qr{[\\/]} : qr{/};our$_ROOT=_WIN32 ? do {my$UNC=qr{[\\/]{2}[^\\/]+[\\/][^\\/]+};qr{^(?:$UNC|[A-Za-z]:|)$_DIR_SPLIT}}: qr{^/};our$_PERL;sub _perl {if (!$_PERL){($_PERL,my$exe)=$^X =~ /((?:.*$_DIR_SPLIT)?(.+))/;$_PERL='perl' if$exe !~ /perl/;if (_is_abs($_PERL)){}elsif (-x $Config::Config{perlpath}){$_PERL=$Config::Config{perlpath}}elsif ($_PERL =~ $_DIR_SPLIT && -x $_PERL){$_PERL=_rel2abs($_PERL)}else {($_PERL)=map {/(.*)/}grep {-x $_}map {($_,_WIN32 ? ("$_.exe"): ())}map {join($_DIR_JOIN,$_,$_PERL)}split /\Q$_path_sep\E/,$ENV{PATH}}}$_PERL}sub _cwd {if (my$cwd =defined&Cwd::sys_cwd ? \&Cwd::sys_cwd : defined&Cwd::cwd ? \&Cwd::cwd : undef){no warnings 'redefine';*_cwd=$cwd;goto &$cwd}my$drive=shift;return Win32::Cwd()if _WIN32 && defined&Win32::Cwd &&!$drive;local@ENV{qw(PATH IFS CDPATH ENV BASH_ENV)};my$cmd=$drive ? "eval { Cwd::getdcwd(q($drive)) }" : 'getcwd';my$perl=_perl;my$cwd=`"$perl" -MCwd -le "print $cmd"`;chomp$cwd;if (!length$cwd && $drive){$cwd=$drive}$cwd =~ s/$_DIR_SPLIT?$/$_DIR_JOIN/;$cwd}sub _catdir {if (_USE_FSPEC){require File::Spec;File::Spec->catdir(@_)}else {my$dir=join($_DIR_JOIN,@_);$dir =~ s{($_DIR_SPLIT)(?:\.?$_DIR_SPLIT)+}{$1}g;$dir}}sub _is_abs {if (_USE_FSPEC){require File::Spec;File::Spec->file_name_is_absolute($_[0])}else {$_[0]=~ $_ROOT}}sub _rel2abs {my ($dir,$base)=@_;return$dir if _is_abs($dir);$base=_WIN32 && $dir =~ s/^([A-Za-z]:)// ? _cwd("$1"): $base ? _rel2abs($base): _cwd;return _catdir($base,$dir)}our$_DEVNULL;sub _devnull {return$_DEVNULL ||= _USE_FSPEC ? (require File::Spec,File::Spec->devnull): _WIN32 ? 'nul' : $^O eq 'os2' ? '/dev/nul' : '/dev/null'}sub import {my ($class,@args)=@_;if ($0 eq '-'){push@args,@ARGV;require Cwd}my@steps;my%opts;my%attr;my$shelltype;while (@args){my$arg=shift@args;if ($arg =~ /\xE2\x88\x92/){die <<'DEATH'}elsif ($arg eq '--self-contained'){die <<'DEATH'}elsif($arg =~ /^--deactivate(?:=(.*))?$/){my$path=defined $1 ? $1 : shift@args;push@steps,['deactivate',$path]}elsif ($arg eq '--deactivate-all'){push@steps,['deactivate_all']}elsif ($arg =~ /^--shelltype(?:=(.*))?$/){$shelltype=defined $1 ? $1 : shift@args}elsif ($arg eq '--no-create'){$opts{no_create}=1}elsif ($arg eq '--quiet'){$attr{quiet}=1}elsif ($arg =~ /^--/){die "Unknown import argument: $arg"}else {push@steps,['activate',$arg,\%opts]}}if (!@steps){push@steps,['activate',undef,\%opts]}my$self=$class->new(%attr);for (@steps){my ($method,@args)=@$_;$self=$self->$method(@args)}if ($0 eq '-'){print$self->environment_vars_string($shelltype);exit 0}else {$self->setup_local_lib}}sub new {my$class=shift;bless {@_},$class}sub clone {my$self=shift;bless {%$self,@_},ref$self}sub inc {$_[0]->{inc}||= \@INC}sub libs {$_[0]->{libs}||= [\'PERL5LIB' ]}sub bins {$_[0]->{bins}||= [\'PATH' ]}sub roots {$_[0]->{roots}||= [\'PERL_LOCAL_LIB_ROOT' ]}sub extra {$_[0]->{extra}||= {}}sub quiet {$_[0]->{quiet}}sub _as_list {my$list=shift;grep length,map {!(ref $_ && ref $_ eq 'SCALAR')? $_ : (defined$ENV{$$_}? split(/\Q$_path_sep/,$ENV{$$_}): ())}ref$list ? @$list : $list}sub _remove_from {my ($list,@remove)=@_;return @$list if!@remove;my%remove=map {$_=>1}@remove;grep!$remove{$_},_as_list($list)}my@_lib_subdirs=([$_version,$_archname],[$_version],[$_archname],(map [$_],@_inc_version_list),[],);sub install_base_bin_path {my ($class,$path)=@_;return _catdir($path,'bin')}sub install_base_perl_path {my ($class,$path)=@_;return _catdir($path,'lib','perl5')}sub install_base_arch_path {my ($class,$path)=@_;_catdir($class->install_base_perl_path($path),$_archname)}sub lib_paths_for {my ($class,$path)=@_;my$base=$class->install_base_perl_path($path);return map {_catdir($base,@$_)}@_lib_subdirs}sub _mm_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;if ($path =~ s/ /\\ /g){$path=qq{"$path"}}return$path}sub _mb_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;return qq{"$path"}}sub installer_options_for {my ($class,$path)=@_;return (PERL_MM_OPT=>defined$path ? "INSTALL_BASE="._mm_escape_path($path): undef,PERL_MB_OPT=>defined$path ? "--install_base "._mb_escape_path($path): undef,)}sub active_paths {my ($self)=@_;$self=ref$self ? $self : $self->new;return grep {my$active_ll=$self->install_base_perl_path($_);grep {$_ eq $active_ll}@{$self->inc}}_as_list($self->roots)}sub deactivate {my ($self,$path)=@_;$self=$self->new unless ref$self;$path=$self->resolve_path($path);$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (!grep {$_ eq $path}@active_lls){warn "Tried to deactivate inactive local::lib '$path'\n";return$self}my%args=(bins=>[_remove_from($self->bins,$self->install_base_bin_path($path))],libs=>[_remove_from($self->libs,$self->install_base_perl_path($path))],inc=>[_remove_from($self->inc,$self->lib_paths_for($path))],roots=>[_remove_from($self->roots,$path)],);$args{extra}={$self->installer_options_for($args{roots}[0])};$self->clone(%args)}sub deactivate_all {my ($self)=@_;$self=$self->new unless ref$self;my@active_lls=$self->active_paths;my%args;if (@active_lls){%args=(bins=>[_remove_from($self->bins,map$self->install_base_bin_path($_),@active_lls)],libs=>[_remove_from($self->libs,map$self->install_base_perl_path($_),@active_lls)],inc=>[_remove_from($self->inc,map$self->lib_paths_for($_),@active_lls)],roots=>[_remove_from($self->roots,@active_lls)],)}$args{extra}={$self->installer_options_for(undef)};$self->clone(%args)}sub activate {my ($self,$path,$opts)=@_;$opts ||= {};$self=$self->new unless ref$self;$path=$self->resolve_path($path);$self->ensure_dir_structure_for($path,{quiet=>$self->quiet })unless$opts->{no_create};$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (grep {$_ eq $path}@active_lls[1 .. $#active_lls]){$self=$self->deactivate($path)}my%args;if ($opts->{always}||!@active_lls || $active_lls[0]ne $path){%args=(bins=>[$self->install_base_bin_path($path),@{$self->bins}],libs=>[$self->install_base_perl_path($path),@{$self->libs}],inc=>[$self->lib_paths_for($path),@{$self->inc}],roots=>[$path,@{$self->roots}],)}$args{extra}={$self->installer_options_for($path)};$self->clone(%args)}sub normalize_path {my ($self,$path)=@_;$path=(Win32::GetShortPathName($path)|| $path)if $^O eq 'MSWin32';return$path}sub build_environment_vars_for {my$self=$_[0]->new->activate($_[1],{always=>1 });$self->build_environment_vars}sub build_activate_environment_vars_for {my$self=$_[0]->new->activate($_[1],{always=>1 });$self->build_environment_vars}sub build_deactivate_environment_vars_for {my$self=$_[0]->new->deactivate($_[1]);$self->build_environment_vars}sub build_deact_all_environment_vars_for {my$self=$_[0]->new->deactivate_all;$self->build_environment_vars}sub build_environment_vars {my$self=shift;(PATH=>join($_path_sep,_as_list($self->bins)),PERL5LIB=>join($_path_sep,_as_list($self->libs)),PERL_LOCAL_LIB_ROOT=>join($_path_sep,_as_list($self->roots)),%{$self->extra},)}sub setup_local_lib_for {my$self=$_[0]->new->activate($_[1]);$self->setup_local_lib}sub setup_local_lib {my$self=shift;require Carp::Heavy if$INC{'Carp.pm'};$self->setup_env_hash;@INC=@{$self->inc}}sub setup_env_hash_for {my$self=$_[0]->new->activate($_[1]);$self->setup_env_hash}sub setup_env_hash {my$self=shift;my%env=$self->build_environment_vars;for my$key (keys%env){if (defined$env{$key}){$ENV{$key}=$env{$key}}else {delete$ENV{$key}}}}sub print_environment_vars_for {print $_[0]->environment_vars_string_for(@_[1..$#_])}sub environment_vars_string_for {my$self=$_[0]->new->activate($_[1],{always=>1});$self->environment_vars_string}sub environment_vars_string {my ($self,$shelltype)=@_;$shelltype ||= $self->guess_shelltype;my$extra=$self->extra;my@envs=(PATH=>$self->bins,PERL5LIB=>$self->libs,PERL_LOCAL_LIB_ROOT=>$self->roots,map {$_=>$extra->{$_}}sort keys %$extra,);$self->_build_env_string($shelltype,\@envs)}sub _build_env_string {my ($self,$shelltype,$envs)=@_;my@envs=@$envs;my$build_method="build_${shelltype}_env_declaration";my$out='';while (@envs){my ($name,$value)=(shift(@envs),shift(@envs));if (ref$value && @$value==1 && ref$value->[0]&& ref$value->[0]eq 'SCALAR' && ${$value->[0]}eq $name){next}$out .= $self->$build_method($name,$value)}my$wrap_method="wrap_${shelltype}_output";if ($self->can($wrap_method)){return$self->$wrap_method($out)}return$out}sub build_bourne_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'${%s:-}',qr/["\\\$!`]/,'\\%s');if (!defined$value){return qq{unset $name;\n}}$value =~ s/(^|\G|$_path_sep)\$\{$name:-\}$_path_sep/$1\${$name}\${$name:+$_path_sep}/g;$value =~ s/$_path_sep\$\{$name:-\}$/\${$name:+$_path_sep\${$name}}/;qq{${name}="$value"; export ${name};\n}}sub build_csh_env_declaration {my ($class,$name,$args)=@_;my ($value,@vars)=$class->_interpolate($args,'${%s}',qr/["\$]/,'"\\%s"');if (!defined$value){return qq{unsetenv $name;\n}}my$out='';for my$var (@vars){$out .= qq{if ! \$?$name setenv $name '';\n}}my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$\{$name\}(?:$_path_sep|$)//g){$out .= qq{if "\${$name}" != '' setenv $name "$value";\n};$out .= qq{if "\${$name}" == '' }}$out .= qq{setenv $name "$value_without";\n};return$out}sub build_cmd_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'%%%s%%',qr(%),'%s');if (!$value){return qq{\@set $name=\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)%$name%(?:$_path_sep|$)//g){$out .= qq{\@if not "%$name%"=="" set "$name=$value"\n};$out .= qq{\@if "%$name%"=="" }}$out .= qq{\@set "$name=$value_without"\n};return$out}sub build_powershell_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$env:%s',qr/["\$]/,'`%s');if (!$value){return qq{Remove-Item -ErrorAction 0 Env:\\$name;\n}}my$maybe_path_sep=qq{\$(if("\$env:$name"-eq""){""}else{"$_path_sep"})};$value =~ s/(^|\G|$_path_sep)\$env:$name$_path_sep/$1\$env:$name"+$maybe_path_sep+"/g;$value =~ s/$_path_sep\$env:$name$/"+$maybe_path_sep+\$env:$name+"/;qq{\$env:$name = \$("$value");\n}}sub wrap_powershell_output {my ($class,$out)=@_;return$out || " \n"}sub build_fish_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$%s',qr/[\\"'$ ]/,'\\%s');if (!defined$value){return qq{set -e $name;\n}}if ($name =~ /^(?:CD|MAN)?PATH$/){$value =~ s/$_path_sep/ /g;my$silent=$name =~ /^(?:CD)?PATH$/ ? " ^"._devnull : '';return qq{set -x $name $value$silent;\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$$name(?:$_path_sep|$)//g){$out .= qq{set -q $name; and set -x $name $value;\n};$out .= qq{set -q $name; or }}$out .= qq{set -x $name $value_without;\n};$out}sub _interpolate {my ($class,$args,$var_pat,$escape,$escape_pat)=@_;return unless defined$args;my@args=ref$args ? @$args : $args;return unless@args;my@vars=map {$$_}grep {ref $_ eq 'SCALAR'}@args;my$string=join$_path_sep,map {ref $_ eq 'SCALAR' ? sprintf($var_pat,$$_): do {s/($escape)/sprintf($escape_pat, $1)/ge;$_}}@args;return wantarray ? ($string,\@vars): $string}sub pipeline;sub pipeline {my@methods=@_;my$last=pop(@methods);if (@methods){\sub {my ($obj,@args)=@_;$obj->${pipeline@methods}($obj->$last(@args))}}else {\sub {shift->$last(@_)}}}sub resolve_path {my ($class,$path)=@_;$path=$class->${pipeline qw(resolve_relative_path resolve_home_path resolve_empty_path)}($path);$path}sub resolve_empty_path {my ($class,$path)=@_;if (defined$path){$path}else {'~/perl5'}}sub resolve_home_path {my ($class,$path)=@_;$path =~ /^~([^\/]*)/ or return$path;my$user=$1;my$homedir=do {if (!length($user)&& defined$ENV{HOME}){$ENV{HOME}}else {require File::Glob;File::Glob::bsd_glob("~$user",File::Glob::GLOB_TILDE())}};unless (defined$homedir){require Carp;require Carp::Heavy;Carp::croak("Couldn't resolve homedir for " .(defined$user ? $user : 'current user'))}$path =~ s/^~[^\/]*/$homedir/;$path}sub resolve_relative_path {my ($class,$path)=@_;_rel2abs($path)}sub ensure_dir_structure_for {my ($class,$path,$opts)=@_;$opts ||= {};my@dirs;for my$dir ($class->lib_paths_for($path),$class->install_base_bin_path($path),){my$d=$dir;while (!-d $d){push@dirs,$d;require File::Basename;$d=File::Basename::dirname($d)}}warn "Attempting to create directory ${path}\n" if!$opts->{quiet}&& @dirs;my%seen;for my$dir (reverse@dirs){next if$seen{$dir}++;mkdir$dir or -d $dir or die "Unable to create $dir: $!"}return}sub guess_shelltype {my$shellbin =defined$ENV{SHELL}&& length$ENV{SHELL}? ($ENV{SHELL}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' && exists$ENV{'!EXITCODE'})? 'bash' : ($^O eq 'MSWin32' && $ENV{PROMPT}&& $ENV{COMSPEC})? ($ENV{COMSPEC}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' &&!$ENV{PROMPT})? 'powershell.exe' : 'sh';for ($shellbin){return /csh$/ ? 'csh' : /fish$/ ? 'fish' : /command(?:\.com)?$/i ? 'cmd' : /cmd(?:\.exe)?$/i ? 'cmd' : /4nt(?:\.exe)?$/i ? 'cmd' : /powershell(?:\.exe)?$/i ? 'powershell' : 'bourne'}}1;
  WHOA THERE! It looks like you've got some fancy dashes in your commandline!
  These are *not* the traditional -- dashes that software recognizes. You
  probably got these by copy-pasting from the perldoc for this module as
  rendered by a UTF8-capable formatter. This most typically happens on an OS X
  terminal, but can happen elsewhere too. Please try again after replacing the
  dashes with normal minus signs.
  DEATH
  FATAL: The local::lib --self-contained flag has never worked reliably and the
  original author, Mark Stosberg, was unable or unwilling to maintain it. As
  such, this flag has been removed from the local::lib codebase in order to
  prevent misunderstandings and potentially broken builds. The local::lib authors
  recommend that you look at the lib::core::only module shipped with this
  distribution in order to create a more robust environment that is equivalent to
  what --self-contained provided (although quite possibly not what you originally
  thought it provided due to the poor quality of the documentation, for which we
  apologise).
  DEATH
LOCAL_LIB

$fatpacked{"newgetopt.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NEWGETOPT.PL';
  {package newgetopt;$REQUIRE_ORDER=0;$PERMUTE=1;$RETURN_IN_ORDER=2;if (defined$ENV{"POSIXLY_CORRECT"}){$autoabbrev=0;$getopt_compat=0;$option_start="(--|-)";$order=$REQUIRE_ORDER;$bundling=0;$passthrough=0}else {$autoabbrev=1;$getopt_compat=1;$option_start="(--|-|\\+)";$order=$PERMUTE;$bundling=0;$passthrough=0}$debug=0;$ignorecase=1;$argv_end="--"}use Getopt::Long;sub NGetOpt {$Getopt::Long::debug=$newgetopt::debug if defined$newgetopt::debug;$Getopt::Long::autoabbrev=$newgetopt::autoabbrev if defined$newgetopt::autoabbrev;$Getopt::Long::getopt_compat=$newgetopt::getopt_compat if defined$newgetopt::getopt_compat;$Getopt::Long::option_start=$newgetopt::option_start if defined$newgetopt::option_start;$Getopt::Long::order=$newgetopt::order if defined$newgetopt::order;$Getopt::Long::bundling=$newgetopt::bundling if defined$newgetopt::bundling;$Getopt::Long::ignorecase=$newgetopt::ignorecase if defined$newgetopt::ignorecase;$Getopt::Long::ignorecase=$newgetopt::ignorecase if defined$newgetopt::ignorecase;$Getopt::Long::passthrough=$newgetopt::passthrough if defined$newgetopt::passthrough;&GetOptions}1;
NEWGETOPT.PL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use App::stew::cmdbuilder;
use App::stew::rc;

my $command = shift @ARGV;

my $rc       = App::stew::rc->new->load;
my $defaults = $command ? {%{$rc->{$command} || {}}, %{$rc->{_} || {}}} : {};
my @defaults = map { $_ => $defaults->{$_} } keys %$defaults;

App::stew::cmdbuilder->new->build($command)->run(@defaults, @ARGV);

__END__

=head1 NAME

stew - Stew your binaries

=head1 SYNOPSIS

stew [command] [options...]

Available commands:

   install         install package
   uninstall       uninstall package
   build           build package without installing
   autoremove      remove not required dependencies
   list-installed  list installed packages
   exec            execute command in local environment
   help            detailed command help

=head1 COMMANDS

=over 4

=item B<install>

See L<App::stew::cmd::install>.

=item B<uninstall>

See L<App::stew::cmd::uninstall>.

=item B<build>

See L<App::stew::cmd::build>.

=item B<autoremove>

See L<App::stew::cmd::autoremove>.

=item B<list-installed>

See L<App::stew::cmd::list_installed>.

=item B<exec>

See L<App::stew::cmd::exec>.

=back

=head1 DESCRIPTION

B<stew> will read the given input file(s) and do something
useful with the contents thereof.

=cut
